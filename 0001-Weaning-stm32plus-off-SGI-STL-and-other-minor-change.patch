From 1b00cd7e61d5b339ee5521fe3a8acde20cdc810e Mon Sep 17 00:00:00 2001
From: Tal-eigen <mohammedtalha89@gmail.com>
Date: Fri, 6 Jul 2018 00:36:09 +0530
Subject: [PATCH 1/1] Weaning-stm32plus-off-SGI-STL-and-other-minor-changes

---
 SConstruct                                         |    8 +-
 cmake/stm32plus-config.cmake.in                    |    2 +-
 .../can_master_send_receive.cpp                    |    6 +-
 .../Device/ST/STM32F4xx/Include/system_stm32f4xx.h |    5 +
 lib/include/config/event.h                         |    2 +-
 lib/include/config/net.h                           |   12 +-
 lib/include/config/stream.h                        |    2 +-
 lib/include/config/usb/device/device.h             |    2 -
 lib/include/device/BlockDeviceOutputStream.h       |   12 +
 lib/include/dma/features/f4/DmaInterruptFeature.h  |   66 +-
 lib/include/event/signal.h                         |   12 +-
 lib/include/filesystem/FileOutputStream.h          |   11 +
 lib/include/net/NetworkIntervalTicker.h            |    2 +-
 .../ip/features/IpPacketReassemblerFeature.h       |    2 +-
 lib/include/net/transport/tcp/Tcp.h                |   30 +-
 lib/include/spi/SpiPollingOutputStream.h           |   14 +-
 lib/include/stl/algorithm                          |   40 -
 lib/include/stl/basic_definitions                  |   48 -
 lib/include/stl/bitset                             | 1089 -------
 lib/include/stl/cctype                             |   37 -
 lib/include/stl/char_traits.h                      |  166 -
 lib/include/stl/concept_checks.h                   |  811 -----
 lib/include/stl/container_concepts.h               |  249 --
 lib/include/stl/cstddef                            |   58 -
 lib/include/stl/deque                              |   41 -
 lib/include/stl/functional                         |   26 -
 lib/include/stl/hash_map                           |   40 -
 lib/include/stl/hash_set                           |   40 -
 lib/include/stl/iomanip                            |  173 -
 lib/include/stl/ios                                |  525 ----
 lib/include/stl/iosfwd                             |   88 -
 lib/include/stl/iostream                           |  105 -
 lib/include/stl/istream                            |  601 ----
 lib/include/stl/istream_helpers                    |  344 --
 lib/include/stl/iterator                           |   47 -
 lib/include/stl/limits                             |  537 ----
 lib/include/stl/list                               |   40 -
 lib/include/stl/locale                             |   88 -
 lib/include/stl/map                                |   40 -
 lib/include/stl/memory                             |  134 -
 lib/include/stl/new                                |   18 -
 lib/include/stl/numeric                            |   51 -
 lib/include/stl/ostream                            |  497 ---
 lib/include/stl/ostream_helpers                    |  498 ---
 lib/include/stl/queue                              |   45 -
 lib/include/stl/sequence_concepts.h                |  204 --
 lib/include/stl/serstream                          |  293 --
 lib/include/stl/set                                |   40 -
 lib/include/stl/slist                              |   28 -
 lib/include/stl/sstream                            |  384 ---
 lib/include/stl/stack                              |   41 -
 lib/include/stl/stl_algo.h                         | 3297 --------------------
 lib/include/stl/stl_algobase.h                     |  698 -----
 lib/include/stl/stl_alloc.h                        |  913 ------
 lib/include/stl/stl_bvector.h                      |  897 ------
 lib/include/stl/stl_config.h                       |  607 ----
 lib/include/stl/stl_construct.h                    |  130 -
 lib/include/stl/stl_ctraits_fns.h                  |   69 -
 lib/include/stl/stl_deque.h                        | 1664 ----------
 lib/include/stl/stl_function.h                     |  729 -----
 lib/include/stl/stl_hash_fun.h                     |   93 -
 lib/include/stl/stl_hash_map.h                     |  532 ----
 lib/include/stl/stl_hash_set.h                     |  514 ---
 lib/include/stl/stl_hashtable.h                    | 1080 -------
 lib/include/stl/stl_heap.h                         |  297 --
 lib/include/stl/stl_iterator.h                     |  965 ------
 lib/include/stl/stl_iterator_base.h                |  367 ---
 lib/include/stl/stl_list.h                         |  885 ------
 lib/include/stl/stl_map.h                          |  295 --
 lib/include/stl/stl_multimap.h                     |  282 --
 lib/include/stl/stl_multiset.h                     |  274 --
 lib/include/stl/stl_numeric.h                      |  255 --
 lib/include/stl/stl_pair.h                         |  101 -
 lib/include/stl/stl_queue.h                        |  243 --
 lib/include/stl/stl_range_errors.h                 |   71 -
 lib/include/stl/stl_raw_storage_iter.h             |   81 -
 lib/include/stl/stl_relops.h                       |   62 -
 lib/include/stl/stl_set.h                          |  268 --
 lib/include/stl/stl_slist.h                        | 1048 -------
 lib/include/stl/stl_stack.h                        |  143 -
 lib/include/stl/stl_string_fwd.h                   |   40 -
 lib/include/stl/stl_tempbuf.h                      |  162 -
 lib/include/stl/stl_tree.h                         | 1369 --------
 lib/include/stl/stl_uninitialized.h                |  279 --
 lib/include/stl/stl_vector.h                       |  879 ------
 lib/include/stl/stm32_config.h                     |   38 -
 lib/include/stl/streambuf                          |  329 --
 lib/include/stl/string                             | 2453 ---------------
 lib/include/stl/type_traits.h                      |  373 ---
 lib/include/stl/utility                            |   38 -
 lib/include/stl/valarray                           | 1780 -----------
 lib/include/stl/vector                             |   42 -
 lib/include/stream/BufferedInputOutputStream.h     |   13 +
 lib/include/stream/ByteArrayOutputStream.h         |    8 +
 lib/include/stream/OutputStream.h                  |   12 +
 lib/include/stream/TextOutputStream.h              |   12 +
 lib/include/usart/UsartPollingOutputStream.h       |    3 +-
 .../usart/features/f4/UsartInterruptFeature.h      |   43 +-
 lib/src/device/BlockDeviceOutputStream.cpp         |    2 +-
 .../f4/interrupts/Dma1Stream1InterruptHandler.cpp  |    2 +-
 .../ip/features/IpPacketReassemblerFeature.cpp     |   27 +-
 lib/src/stream/ByteArrayOutputStream.cpp           |    2 +-
 lib/src/usart/UsartPollingOutputStream.cpp         |   16 +
 .../usart/interrupts/Usart3InterruptHandler.cpp    |    2 +-
 104 files changed, 226 insertions(+), 32212 deletions(-)
 delete mode 100644 lib/include/stl/algorithm
 delete mode 100644 lib/include/stl/basic_definitions
 delete mode 100644 lib/include/stl/bitset
 delete mode 100644 lib/include/stl/cctype
 delete mode 100644 lib/include/stl/char_traits.h
 delete mode 100644 lib/include/stl/concept_checks.h
 delete mode 100644 lib/include/stl/container_concepts.h
 delete mode 100644 lib/include/stl/cstddef
 delete mode 100644 lib/include/stl/deque
 delete mode 100644 lib/include/stl/functional
 delete mode 100644 lib/include/stl/hash_map
 delete mode 100644 lib/include/stl/hash_set
 delete mode 100644 lib/include/stl/iomanip
 delete mode 100644 lib/include/stl/ios
 delete mode 100644 lib/include/stl/iosfwd
 delete mode 100644 lib/include/stl/iostream
 delete mode 100644 lib/include/stl/istream
 delete mode 100644 lib/include/stl/istream_helpers
 delete mode 100644 lib/include/stl/iterator
 delete mode 100644 lib/include/stl/limits
 delete mode 100644 lib/include/stl/list
 delete mode 100644 lib/include/stl/locale
 delete mode 100644 lib/include/stl/map
 delete mode 100644 lib/include/stl/memory
 delete mode 100644 lib/include/stl/new
 delete mode 100644 lib/include/stl/numeric
 delete mode 100644 lib/include/stl/ostream
 delete mode 100644 lib/include/stl/ostream_helpers
 delete mode 100644 lib/include/stl/queue
 delete mode 100644 lib/include/stl/sequence_concepts.h
 delete mode 100644 lib/include/stl/serstream
 delete mode 100644 lib/include/stl/set
 delete mode 100644 lib/include/stl/slist
 delete mode 100644 lib/include/stl/sstream
 delete mode 100644 lib/include/stl/stack
 delete mode 100644 lib/include/stl/stl_algo.h
 delete mode 100644 lib/include/stl/stl_algobase.h
 delete mode 100644 lib/include/stl/stl_alloc.h
 delete mode 100644 lib/include/stl/stl_bvector.h
 delete mode 100644 lib/include/stl/stl_config.h
 delete mode 100644 lib/include/stl/stl_construct.h
 delete mode 100644 lib/include/stl/stl_ctraits_fns.h
 delete mode 100644 lib/include/stl/stl_deque.h
 delete mode 100644 lib/include/stl/stl_function.h
 delete mode 100644 lib/include/stl/stl_hash_fun.h
 delete mode 100644 lib/include/stl/stl_hash_map.h
 delete mode 100644 lib/include/stl/stl_hash_set.h
 delete mode 100644 lib/include/stl/stl_hashtable.h
 delete mode 100644 lib/include/stl/stl_heap.h
 delete mode 100644 lib/include/stl/stl_iterator.h
 delete mode 100644 lib/include/stl/stl_iterator_base.h
 delete mode 100644 lib/include/stl/stl_list.h
 delete mode 100644 lib/include/stl/stl_map.h
 delete mode 100644 lib/include/stl/stl_multimap.h
 delete mode 100644 lib/include/stl/stl_multiset.h
 delete mode 100644 lib/include/stl/stl_numeric.h
 delete mode 100644 lib/include/stl/stl_pair.h
 delete mode 100644 lib/include/stl/stl_queue.h
 delete mode 100644 lib/include/stl/stl_range_errors.h
 delete mode 100644 lib/include/stl/stl_raw_storage_iter.h
 delete mode 100644 lib/include/stl/stl_relops.h
 delete mode 100644 lib/include/stl/stl_set.h
 delete mode 100644 lib/include/stl/stl_slist.h
 delete mode 100644 lib/include/stl/stl_stack.h
 delete mode 100644 lib/include/stl/stl_string_fwd.h
 delete mode 100644 lib/include/stl/stl_tempbuf.h
 delete mode 100644 lib/include/stl/stl_tree.h
 delete mode 100644 lib/include/stl/stl_uninitialized.h
 delete mode 100644 lib/include/stl/stl_vector.h
 delete mode 100644 lib/include/stl/stm32_config.h
 delete mode 100644 lib/include/stl/streambuf
 delete mode 100644 lib/include/stl/string
 delete mode 100644 lib/include/stl/type_traits.h
 delete mode 100644 lib/include/stl/utility
 delete mode 100644 lib/include/stl/valarray
 delete mode 100644 lib/include/stl/vector

diff --git a/SConstruct b/SConstruct
index d3e7976..d3284cd 100644
--- a/SConstruct
+++ b/SConstruct
@@ -162,14 +162,14 @@ env.Replace(RANLIB="arm-none-eabi-ranlib")
 
 # set the include directories
 
-env.Append(CPPPATH=["#lib/include","#lib/include/stl","#lib"])
+env.Append(CPPPATH=["#lib/include","#lib"])
 
 # create the C and C++ flags that are needed. We can't use the extra or pedantic errors on the ST library code.
 
-env.Replace(CCFLAGS=["-Wall","-Werror","-ffunction-sections","-fdata-sections","-fno-exceptions","-mthumb","-gdwarf-2","-pipe"])
-env.Replace(CXXFLAGS=["-Wextra","-pedantic-errors","-fno-rtti","-std=gnu++0x","-fno-threadsafe-statics"])
+env.Replace(CCFLAGS=["-Wall","-Werror","-Wno-implicit-fallthrough","-Wno-error=attributes","-ffunction-sections","-fdata-sections","-fno-exceptions","-mthumb","-gdwarf-2","-pipe"])
+env.Replace(CXXFLAGS=["-Wextra","-Wno-sized-deallocation","-pedantic-errors","-fno-rtti","-std=gnu++0x","-fno-threadsafe-statics"])
 env.Append(CCFLAGS="-D"+osc_def+"="+osc)
-env.Append(LINKFLAGS=["-Xlinker","--gc-sections","-mthumb","-g3","-gdwarf-2"])
+env.Append(LINKFLAGS=["-Xlinker","--gc-sections","--specs=nosys.specs","-mthumb","-g3","-gdwarf-2"])
 
 # add on the MCU-specific definitions
 
diff --git a/cmake/stm32plus-config.cmake.in b/cmake/stm32plus-config.cmake.in
index c12682a..4bd7ab1 100644
--- a/cmake/stm32plus-config.cmake.in
+++ b/cmake/stm32plus-config.cmake.in
@@ -4,5 +4,5 @@ include(${CMAKE_CURRENT_LIST_DIR}/stm32plus-config-${STM32PLUS_CONFIGURATION}.cm
 if(NOT "${STM32PLUS_CONFIG_FILE}")
   # If we couldn't find the requested config, try with an "e" appended, for
   # explicit external oscillator. This config name change was made in 4.0.3.
-  include(${CMAKE_CURRENT_LIST_DIR}/stm32plus-config-${STM32PLUS_CONFIGURATION}e.cmake)
+  include(${CMAKE_CURRENT_LIST_DIR}/stm32plus-config-${STM32PLUS_CONFIGURATION}e-hard.cmake)
 endif()
diff --git a/examples/can_master_send_receive/can_master_send_receive.cpp b/examples/can_master_send_receive/can_master_send_receive.cpp
index d6c99ea..9b210f6 100644
--- a/examples/can_master_send_receive/can_master_send_receive.cpp
+++ b/examples/can_master_send_receive/can_master_send_receive.cpp
@@ -52,11 +52,11 @@ class CanMasterSendReceive {
     volatile bool _ready;
     volatile uint8_t _receiveData[8];
 
-    enum { LED_PIN = 6 };
+    enum { LED_PIN = 14 };
 
   public:
 
-    CanMasterSendReceive() : _can( { 500000,875 } ) {
+    CanMasterSendReceive() : _can( { 125000,875 } ) {
     }
 
     void run() {
@@ -77,7 +77,7 @@ class CanMasterSendReceive {
        * set up the LED on PF6
        */
 
-      GpioF<DefaultDigitalOutputFeature<LED_PIN>> pf;
+      GpioG<DefaultDigitalOutputFeature<LED_PIN>> pf;
 
       /*
        * Go into an infinite loop sending a message per second
diff --git a/lib/fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/system_stm32f4xx.h b/lib/fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/system_stm32f4xx.h
index 856d8de..dd11284 100644
--- a/lib/fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/system_stm32f4xx.h
+++ b/lib/fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/system_stm32f4xx.h
@@ -46,6 +46,11 @@
 /**
   * @brief Define to prevent recursive inclusion
   */
+
+/*Change definitions of RCC_CONFIG according to SetSysClock*/
+
+#define RCC_CONFIG				(RCC_CFGR_HPRE_DIV1 | RCC_CFGR_PPRE2_DIV2 | RCC_CFGR_PPRE1_DIV4)
+
 #ifndef __SYSTEM_STM32F4XX_H
 #define __SYSTEM_STM32F4XX_H
 
diff --git a/lib/include/config/event.h b/lib/include/config/event.h
index 9d5778e..f028827 100644
--- a/lib/include/config/event.h
+++ b/lib/include/config/event.h
@@ -20,7 +20,7 @@
 #ifdef EXT_SLIST
     #include "ext/slist"
 #else
-    #include "slist"
+    #include <forward_list>
 #endif
 
 // include the event/slot signal classes
diff --git a/lib/include/config/net.h b/lib/include/config/net.h
index fc0a21d..82d51d9 100644
--- a/lib/include/config/net.h
+++ b/lib/include/config/net.h
@@ -32,12 +32,12 @@
 #include "memory/scoped_ptr.h"
 #include "memory/linked_ptr.h"
 #include "util/Meta.h"
-#include "iterator"
-#include "slist"
-#include "vector"
-#include "list"
-#include "algorithm"
-#include "string"
+#include <iterator>
+#include <forward_list>
+#include <vector>
+#include <list>
+#include <algorithm>
+#include <string>
 
 // generic includes
 
diff --git a/lib/include/config/stream.h b/lib/include/config/stream.h
index 834715c..c50a142 100644
--- a/lib/include/config/stream.h
+++ b/lib/include/config/stream.h
@@ -18,7 +18,7 @@
 #include "config/timing.h"
 #include "util/DoublePrecision.h"
 #include "memory/Memblock.h"
-#include "string"
+#include "config/string.h"
 
 // includes for the feature
 
diff --git a/lib/include/config/usb/device/device.h b/lib/include/config/usb/device/device.h
index f7339a3..95a9e84 100644
--- a/lib/include/config/usb/device/device.h
+++ b/lib/include/config/usb/device/device.h
@@ -16,7 +16,6 @@
   #include "config/event.h"
   #include "config/nvic.h"
   #include "util/BitHacks.h"
-  #include "util/StdExt.h"
 
   // core includes
 
@@ -64,7 +63,6 @@
   #include "config/rcc.h"
   #include "config/exti.h"
   #include "util/Meta.h"
-  #include "util/StdExt.h"
 
   #include "usb/f4/device/HalUsbdStatus.h"
 
diff --git a/lib/include/device/BlockDeviceOutputStream.h b/lib/include/device/BlockDeviceOutputStream.h
index 9a2ff3c..96d8c38 100644
--- a/lib/include/device/BlockDeviceOutputStream.h
+++ b/lib/include/device/BlockDeviceOutputStream.h
@@ -45,7 +45,19 @@ namespace stm32plus {
 
       virtual bool write(uint8_t c) override;
       virtual bool write(const void *buffer,uint32_t size) override;
+			virtual size_t write(const void* buffer,size_t size) override;
       virtual bool close() override;
       virtual bool flush() override;
   };
+
+	/**
+   * Seven Robotics extension. Dummy Implementation.
+   */
+
+		inline size_t BlockDeviceOutputStream::write(const void* buffer,size_t size) {
+			
+			(void)buffer;
+			(void)size;
+			return 0;
+		} 
 }
diff --git a/lib/include/dma/features/f4/DmaInterruptFeature.h b/lib/include/dma/features/f4/DmaInterruptFeature.h
index f487505..c707945 100644
--- a/lib/include/dma/features/f4/DmaInterruptFeature.h
+++ b/lib/include/dma/features/f4/DmaInterruptFeature.h
@@ -52,7 +52,7 @@ namespace stm32plus {
       static FPTR _forceLinkage;
 
     public:
-      static void enable(uint8_t priority,uint8_t subPriority);
+      static void enable(uint8_t priority,uint8_t subpriority);
   };
 
 
@@ -172,51 +172,51 @@ namespace stm32plus {
    */
 
   template<>
-  inline void DmaInterruptFeatureEnabler<1,0>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<1,0>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA1_Stream0_IRQHandler;
-    Nvic::configureIrq(DMA1_Stream0_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA1_Stream0_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<1,1>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<1,1>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA1_Stream1_IRQHandler;
-    Nvic::configureIrq(DMA1_Stream1_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA1_Stream1_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<1,2>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<1,2>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA1_Stream2_IRQHandler;
-    Nvic::configureIrq(DMA1_Stream2_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA1_Stream2_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<1,3>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<1,3>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA1_Stream3_IRQHandler;
-    Nvic::configureIrq(DMA1_Stream3_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA1_Stream3_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<1,4>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<1,4>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA1_Stream4_IRQHandler;
-    Nvic::configureIrq(DMA1_Stream4_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA1_Stream4_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<1,5>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<1,5>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA1_Stream5_IRQHandler;
-    Nvic::configureIrq(DMA1_Stream5_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA1_Stream5_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<1,6>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<1,6>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA1_Stream6_IRQHandler;
-    Nvic::configureIrq(DMA1_Stream6_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA1_Stream6_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<1,7>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<1,7>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA1_Stream7_IRQHandler;
-    Nvic::configureIrq(DMA1_Stream7_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA1_Stream7_IRQn,ENABLE,priority,subpriority);
   }
 
   /**
@@ -224,50 +224,50 @@ namespace stm32plus {
    */
 
   template<>
-  inline void DmaInterruptFeatureEnabler<2,0>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<2,0>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA2_Stream0_IRQHandler;
-    Nvic::configureIrq(DMA2_Stream0_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA2_Stream0_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<2,1>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<2,1>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA2_Stream1_IRQHandler;
-    Nvic::configureIrq(DMA2_Stream1_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA2_Stream1_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<2,2>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<2,2>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA2_Stream2_IRQHandler;
-    Nvic::configureIrq(DMA2_Stream2_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA2_Stream2_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<2,3>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<2,3>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA2_Stream3_IRQHandler;
-    Nvic::configureIrq(DMA2_Stream3_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA2_Stream3_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<2,4>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<2,4>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA2_Stream4_IRQHandler;
-    Nvic::configureIrq(DMA2_Stream4_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA2_Stream4_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<2,5>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<2,5>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA2_Stream5_IRQHandler;
-    Nvic::configureIrq(DMA2_Stream5_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA2_Stream5_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<2,6>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<2,6>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA2_Stream6_IRQHandler;
-    Nvic::configureIrq(DMA2_Stream6_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA2_Stream6_IRQn,ENABLE,priority,subpriority);
   }
 
   template<>
-  inline void DmaInterruptFeatureEnabler<2,7>::enable(uint8_t priority,uint8_t subPriority) {
+  inline void DmaInterruptFeatureEnabler<2,7>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&DMA2_Stream7_IRQHandler;
-    Nvic::configureIrq(DMA2_Stream7_IRQn,ENABLE,priority,subPriority);
+    Nvic::configureIrq(DMA2_Stream7_IRQn,ENABLE,priority,subpriority);
   }
 }
diff --git a/lib/include/event/signal.h b/lib/include/event/signal.h
index 8c65365..02fb0dc 100644
--- a/lib/include/event/signal.h
+++ b/lib/include/event/signal.h
@@ -46,7 +46,7 @@ namespace wink {
 #ifdef EXT_SLIST     
       __gnu_cxx::slist<slot_type> _slots;
 #else
-      std::slist<slot_type> _slots;
+      std::forward_list<slot_type> _slots;
 #endif
     public:
 
@@ -56,7 +56,7 @@ namespace wink {
 
       void insertSubscriber(const slot_type& slot) {
 
-        if(_slots.size()==0)
+        if(_slots.empty())
           _firstSlot=slot;
 
         _slots.push_front(slot);
@@ -68,9 +68,9 @@ namespace wink {
 
       bool removeSubscriber(const slot_type& slot) {
 
-        for(auto it=_slots.begin();it!=_slots.end();it++) {
-          if(*it==slot) {
-            _slots.erase(it);
+        for(auto it=_slots.before_begin();it!=_slots.end();it++) {
+          if(*next(it)==slot) {
+            _slots.erase_after(it);
             return true;
           }
         }
@@ -82,7 +82,7 @@ namespace wink {
       template <class ...Args>
       void raiseEvent(Args&&... args) const {
 
-        if(_slots.size()==1)
+        if(std::distance(_slots.begin(),_slots.end()) == 1)
           _firstSlot(args...);
         else {
           for(auto it=_slots.begin();it!=_slots.end();it++)
diff --git a/lib/include/filesystem/FileOutputStream.h b/lib/include/filesystem/FileOutputStream.h
index d828cef..e4e2b8e 100644
--- a/lib/include/filesystem/FileOutputStream.h
+++ b/lib/include/filesystem/FileOutputStream.h
@@ -26,6 +26,7 @@ namespace stm32plus {
 
       virtual bool write(uint8_t c) override;
       virtual bool write(const void *buffer,uint32_t size) override;
+			virtual size_t write(const void* buffer,size_t size) override;
       virtual bool close() override;
 
       virtual bool flush() override;
@@ -52,6 +53,16 @@ namespace stm32plus {
     return _file.write(buffer,size);
   }
 
+	/**
+   * Seven Robotics Extension. Dummy Implementation.
+   */ 
+
+	inline size_t FileOutputStream::write(const void* buffer,size_t size) {
+		
+		(void)buffer;
+		(void)size;
+		return 0;
+	}
 
   /**
    * no-op close
diff --git a/lib/include/net/NetworkIntervalTicker.h b/lib/include/net/NetworkIntervalTicker.h
index a575561..cf016c4 100644
--- a/lib/include/net/NetworkIntervalTicker.h
+++ b/lib/include/net/NetworkIntervalTicker.h
@@ -69,7 +69,7 @@ namespace stm32plus {
 
         RtcBase *_rtc;
         RtcSecondInterruptFeature *_rtcInterruptFeature;
-        std::slist<SubscriberInfo> _subscribers;
+        std::forward_list<SubscriberInfo> _subscribers;
         bool _ready;
 
       protected:
diff --git a/lib/include/net/network/ip/features/IpPacketReassemblerFeature.h b/lib/include/net/network/ip/features/IpPacketReassemblerFeature.h
index e7d441e..73e45e3 100644
--- a/lib/include/net/network/ip/features/IpPacketReassemblerFeature.h
+++ b/lib/include/net/network/ip/features/IpPacketReassemblerFeature.h
@@ -56,7 +56,7 @@ namespace stm32plus {
 
       private:
         Parameters _params;
-        std::slist<IpFragmentedPacket *> _frags;
+        std::forward_list<IpFragmentedPacket *> _frags;
         uint32_t _totalFragmentSize;
         uint32_t _inFlightPacketCount;
         NetworkUtilityObjects *_utilityObjects;
diff --git a/lib/include/net/transport/tcp/Tcp.h b/lib/include/net/transport/tcp/Tcp.h
index a6b72b8..832c352 100644
--- a/lib/include/net/transport/tcp/Tcp.h
+++ b/lib/include/net/transport/tcp/Tcp.h
@@ -60,7 +60,7 @@ namespace stm32plus {
       protected:
         Parameters _params;
         uint16_t _serverCount;
-        std::slist<TcpClosingConnectionState> _closingConnections;
+        std::forward_list<TcpClosingConnectionState> _closingConnections;
 
       protected:
         void onNotification(NetEventDescriptor& ned);
@@ -190,7 +190,7 @@ namespace stm32plus {
 
       // check if this segment is for one of the closing connections
 
-      std::slist<TcpClosingConnectionState>::iterator it,previt;
+      std::forward_list<TcpClosingConnectionState>::iterator it,previt;
       bool notfound;
 
       {
@@ -235,7 +235,7 @@ namespace stm32plus {
               IrqSuspend suspender;
 
               if(it==_closingConnections.begin())
-                _closingConnections.erase(_closingConnections.begin());
+                _closingConnections.erase_after(_closingConnections.before_begin());
               else
                 _closingConnections.erase_after(previt);
             }
@@ -338,32 +338,32 @@ namespace stm32plus {
     template<class TNetworkLayer>
     __attribute__((noinline)) inline void Tcp<TNetworkLayer>::onTick(NetworkIntervalTickData& nitd) {
 
-      std::slist<TcpClosingConnectionState>::iterator previt,it;
+      std::forward_list<TcpClosingConnectionState>::iterator previt,it;
 
       // iterate the closing connections
 
-      for(it=previt=_closingConnections.begin();it!=_closingConnections.end();) {
+      for(it=previt=_closingConnections.before_begin();it!=_closingConnections.end();) {
 
         // check if it's expired
 
-        if(nitd.timeNow>it->cleanupTime) {
+        if(nitd.timeNow > (next(it))->cleanupTime) {
 
           // if the state is not CLOSED or TIME_WAIT then the close sequence has not
           // completed as it should. we send a RST to the other end to tell it to shutdown.
 
-          if(it->state!=TcpState::TIME_WAIT && it->state!=TcpState::CLOSED)
-            it->sendRstAck(*this,0);
+          if((next(it))->state!=TcpState::TIME_WAIT && (next(it))->state!=TcpState::CLOSED)
+            (next(it))->sendRstAck(*this,0);
 
           // if the local port is ephemeral then release it
 
-          if(it->localPortIsEphemeral)
-            this->ip_releaseEphemeralPort(it->localPort);
+          if((next(it))->localPortIsEphemeral)
+            this->ip_releaseEphemeralPort((next(it))->localPort);
 
           // if this is the head of the list, remove it and continue again from the start
 
-          if(it==_closingConnections.begin()) {
-            _closingConnections.erase(_closingConnections.begin());
-            it=previt=_closingConnections.begin();
+          if(it==_closingConnections.before_begin()) {
+            _closingConnections.erase_after(_closingConnections.before_begin());
+            it=previt=_closingConnections.before_begin();
           }
           else {
 
@@ -412,7 +412,7 @@ namespace stm32plus {
 
       // add to the list (struct copy)
 
-      std::slist<TcpClosingConnectionState>::iterator it;
+      std::forward_list<TcpClosingConnectionState>::iterator it;
 
       {
         IrqSuspend suspender;
@@ -612,7 +612,7 @@ namespace stm32plus {
      * @param remoteAddress The remote IP address to connect to
      * @param remotePort The remote server port to connect to
      * @param connection The new connection object. Delete when you're done.
-     * @tparam TConnection Your most-derived subclass of TcpConnection that you're using to handle the connection.
+   	 * @tparam TConnection Your most-derived subclass of TcpConnection that you're using to handle the connection.
      * @return true if it works, false if not
      */
 
diff --git a/lib/include/spi/SpiPollingOutputStream.h b/lib/include/spi/SpiPollingOutputStream.h
index 583ce95..6f00286 100644
--- a/lib/include/spi/SpiPollingOutputStream.h
+++ b/lib/include/spi/SpiPollingOutputStream.h
@@ -27,7 +27,7 @@ namespace stm32plus {
 
       virtual bool write(uint8_t c) override;
       virtual bool write(const void *buffer,uint32_t size) override;
-
+			virtual size_t write(const void* buffer,size_t size) override;
       /**
        * Always true.
        * @return always true
@@ -46,4 +46,16 @@ namespace stm32plus {
         return true;
       }
   };
+
+	/**
+ 	 * Seven Robotics Extension. Dummy implementation. 
+ 	 * TODO: provide a usable implementation.
+ 	 */
+		
+		inline size_t SpiPollingOutputStream::write(const void* buffer,size_t size) {
+		
+			(void)buffer;
+			(void)size;
+			return 0;
+		} 
 }
diff --git a/lib/include/stl/algorithm b/lib/include/stl/algorithm
deleted file mode 100644
index 1ba584f..0000000
--- a/lib/include/stl/algorithm
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_ALGORITHM
-#define __SGI_STL_ALGORITHM
-
-#include <stl_algobase.h>
-#include <stl_construct.h>
-#include <stl_uninitialized.h>
-#include <stl_tempbuf.h>
-#include <stl_algo.h>
-
-#endif /* __SGI_STL_ALGORITHM */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/basic_definitions b/lib/include/stl/basic_definitions
deleted file mode 100644
index 966cc7b..0000000
--- a/lib/include/stl/basic_definitions
+++ /dev/null
@@ -1,48 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-	This file is part of the uClibc++ Library.
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#ifndef __BASIC_DEFINITIONS
-#define __BASIC_DEFINITIONS 1
-
-#pragma GCC visibility push(default)
-
-//The following is used to support GCC symbol visibility patch
-
-#define _UCXXEXPORT __attribute__ ((visibility("default")))
-#define _UCXXLOCAL __attribute__ ((visibility("hidden")))
-#define __UCLIBCXX_NORETURN __attribute__ ((__noreturn__))
-#define __UCLIBCXX_TLS
-
-
-//Testing purposes
-#define __STRING_MAX_UNITS 65535
-
-namespace std{
-	typedef signed long int streamsize;
-}
-
-#pragma GCC visibility pop
-
-#endif
-
-
-#ifdef __DODEBUG__
-	#define UCLIBCXX_DEBUG 1
-#else
-	#define UCLIBCXX_DEBUG 0
-
-#endif
diff --git a/lib/include/stl/bitset b/lib/include/stl/bitset
deleted file mode 100644
index d50c93e..0000000
--- a/lib/include/stl/bitset
+++ /dev/null
@@ -1,1089 +0,0 @@
-/*
- * Copyright (c) 1998
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */ 
-
-#ifndef __SGI_STL_BITSET
-#define __SGI_STL_BITSET
-
-// A bitset of size N has N % (sizeof(unsigned long) * CHAR_BIT) unused 
-// bits.  (They are the high- order bits in the highest word.)  It is
-// a class invariant of class bitset<> that those unused bits are
-// always zero.
-
-// Most of the actual code isn't contained in bitset<> itself, but in the 
-// base class _Base_bitset.  The base class works with whole words, not with
-// individual bits.  This allows us to specialize _Base_bitset for the
-// important special case where the bitset is only a single word.
-
-// The C++ standard does not define the precise semantics of operator[].
-// In this implementation the const version of operator[] is equivalent
-// to test(), except that it does no range checking.  The non-const version
-// returns a reference to a bit, again without doing any range checking.
-
-
-#include <stddef.h>     // for size_t
-#include <string.h>     // for memset
-#include <string>
-
-#ifndef STM32PLUS_BUILD
-#include <stdexcept>    // for invalid_argument, out_of_range, overflow_error
-#endif
-
-#ifdef __STL_USE_NEW_IOSTREAMS 
-#include <iostream>
-#else
-#include <iostream.h>   // for istream, ostream
-#endif
-
-#define __BITS_PER_WORD (CHAR_BIT*sizeof(unsigned long))
-#define __BITSET_WORDS(__n) \
- ((__n) < 1 ? 1 : ((__n) + __BITS_PER_WORD - 1)/__BITS_PER_WORD)
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1209
-#endif
-
-// structure to aid in counting bits
-template<bool __dummy> 
-struct _Bit_count {
-  static unsigned char _S_bit_count[256];
-};
-
-// Mapping from 8 bit unsigned integers to the index of the first one
-// bit:
-template<bool __dummy> 
-struct _First_one {
-  static unsigned char _S_first_one[256];
-};
-
-//
-// Base class: general case.
-//
-
-template<size_t _Nw>
-struct _Base_bitset {
-  typedef unsigned long _WordT;
-
-  _WordT _M_w[_Nw];                // 0 is the least significant word.
-
-  _Base_bitset( void ) { _M_do_reset(); }
-  _Base_bitset(unsigned long __val) {
-    _M_do_reset();
-    _M_w[0] = __val;
-  }
-
-  static size_t _S_whichword( size_t __pos )
-    { return __pos / __BITS_PER_WORD; }
-  static size_t _S_whichbyte( size_t __pos )
-    { return (__pos % __BITS_PER_WORD) / CHAR_BIT; }
-  static size_t _S_whichbit( size_t __pos )
-    { return __pos % __BITS_PER_WORD; }
-  static _WordT _S_maskbit( size_t __pos )
-    { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
-
-  _WordT& _M_getword(size_t __pos)       { return _M_w[_S_whichword(__pos)]; }
-  _WordT  _M_getword(size_t __pos) const { return _M_w[_S_whichword(__pos)]; }
-
-  _WordT& _M_hiword()       { return _M_w[_Nw - 1]; }
-  _WordT  _M_hiword() const { return _M_w[_Nw - 1]; }
-
-  void _M_do_and(const _Base_bitset<_Nw>& __x) {
-    for ( size_t __i = 0; __i < _Nw; __i++ ) {
-      _M_w[__i] &= __x._M_w[__i];
-    }
-  }
-
-  void _M_do_or(const _Base_bitset<_Nw>& __x) {
-    for ( size_t __i = 0; __i < _Nw; __i++ ) {
-      _M_w[__i] |= __x._M_w[__i];
-    }
-  }
-
-  void _M_do_xor(const _Base_bitset<_Nw>& __x) {
-    for ( size_t __i = 0; __i < _Nw; __i++ ) {
-      _M_w[__i] ^= __x._M_w[__i];
-    }
-  }
-
-  void _M_do_left_shift(size_t __shift);
-  void _M_do_right_shift(size_t __shift);
-
-  void _M_do_flip() {
-    for ( size_t __i = 0; __i < _Nw; __i++ ) {
-      _M_w[__i] = ~_M_w[__i];
-    }
-  }
-
-  void _M_do_set() {
-    for ( size_t __i = 0; __i < _Nw; __i++ ) {
-      _M_w[__i] = ~static_cast<_WordT>(0);
-    }
-  }
-
-  void _M_do_reset() { memset(_M_w, 0, _Nw * sizeof(_WordT)); }
-
-  bool _M_is_equal(const _Base_bitset<_Nw>& __x) const {
-    for (size_t __i = 0; __i < _Nw; ++__i) {
-      if (_M_w[__i] != __x._M_w[__i])
-        return false;
-    }
-    return true;
-  }
-
-  bool _M_is_any() const {
-    for ( size_t __i = 0; __i < _Nw; __i++ ) {
-      if ( _M_w[__i] != static_cast<_WordT>(0) )
-        return true;
-    }
-    return false;
-  }
-
-  size_t _M_do_count() const {
-    size_t __result = 0;
-    const unsigned char* __byte_ptr = (const unsigned char*)_M_w;
-    const unsigned char* __end_ptr = (const unsigned char*)(_M_w+_Nw);
-
-    while ( __byte_ptr < __end_ptr ) {
-      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];
-      __byte_ptr++;
-    }
-    return __result;
-  }
-
-  unsigned long _M_do_to_ulong() const; 
-
-  // find first "on" bit
-  size_t _M_do_find_first(size_t __not_found) const;
-
-  // find the next "on" bit that follows "prev"
-  size_t _M_do_find_next(size_t __prev, size_t __not_found) const;
-};
-
-//
-// Definitions of non-inline functions from _Base_bitset.
-// 
-
-template<size_t _Nw>
-void _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) 
-{
-  if (__shift != 0) {
-    const size_t __wshift = __shift / __BITS_PER_WORD;
-    const size_t __offset = __shift % __BITS_PER_WORD;
-
-    if (__offset == 0)
-      for (size_t __n = _Nw - 1; __n >= __wshift; --__n)
-        _M_w[__n] = _M_w[__n - __wshift];
-
-    else {
-      const size_t __sub_offset = __BITS_PER_WORD - __offset;
-      for (size_t __n = _Nw - 1; __n > __wshift; --__n)
-        _M_w[__n] = (_M_w[__n - __wshift] << __offset) | 
-                    (_M_w[__n - __wshift - 1] >> __sub_offset);
-      _M_w[__wshift] = _M_w[0] << __offset;
-    }
-
-    fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));
-  }
-}
-
-template<size_t _Nw>
-void _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) 
-{
-  if (__shift != 0) {
-    const size_t __wshift = __shift / __BITS_PER_WORD;
-    const size_t __offset = __shift % __BITS_PER_WORD;
-    const size_t __limit = _Nw - __wshift - 1;
-
-    if (__offset == 0)
-      for (size_t __n = 0; __n <= __limit; ++__n)
-        _M_w[__n] = _M_w[__n + __wshift];
-
-    else {
-      const size_t __sub_offset = __BITS_PER_WORD - __offset;
-      for (size_t __n = 0; __n < __limit; ++__n)
-        _M_w[__n] = (_M_w[__n + __wshift] >> __offset) |
-                    (_M_w[__n + __wshift + 1] << __sub_offset);
-      _M_w[__limit] = _M_w[_Nw-1] >> __offset;
-    }
-
-    fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));
-  }
-}
-
-template<size_t _Nw>
-unsigned long _Base_bitset<_Nw>::_M_do_to_ulong() const
-{
-  for (size_t __i = 1; __i < _Nw; ++__i) 
-    if (_M_w[__i]) {
-      __STL_THROW(overflow_error("bitset"));
-    }
-  
-  return _M_w[0];
-}
-
-template<size_t _Nw>
-size_t _Base_bitset<_Nw>::_M_do_find_first(size_t __not_found) const 
-{
-  for ( size_t __i = 0; __i < _Nw; __i++ ) {
-    _WordT __thisword = _M_w[__i];
-    if ( __thisword != static_cast<_WordT>(0) ) {
-      // find byte within word
-      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {
-        unsigned char __this_byte
-          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));
-        if ( __this_byte )
-          return __i*__BITS_PER_WORD + __j*CHAR_BIT +
-            _First_one<true>::_S_first_one[__this_byte];
-
-        __thisword >>= CHAR_BIT;
-      }
-    }
-  }
-  // not found, so return an indication of failure.
-  return __not_found;
-}
-
-template<size_t _Nw>
-size_t
-_Base_bitset<_Nw>::_M_do_find_next(size_t __prev, size_t __not_found) const
-{
-  // make bound inclusive
-  ++__prev;
-
-  // check out of bounds
-  if ( __prev >= _Nw * __BITS_PER_WORD )
-    return __not_found;
-
-    // search first word
-  size_t __i = _S_whichword(__prev);
-  _WordT __thisword = _M_w[__i];
-
-    // mask off bits below bound
-  __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);
-
-  if ( __thisword != static_cast<_WordT>(0) ) {
-    // find byte within word
-    // get first byte into place
-    __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;
-    for ( size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++ ) {
-      unsigned char __this_byte
-        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));
-      if ( __this_byte )
-        return __i*__BITS_PER_WORD + __j*CHAR_BIT +
-          _First_one<true>::_S_first_one[__this_byte];
-
-      __thisword >>= CHAR_BIT;
-    }
-  }
-
-  // check subsequent words
-  __i++;
-  for ( ; __i < _Nw; __i++ ) {
-    _WordT __thisword = _M_w[__i];
-    if ( __thisword != static_cast<_WordT>(0) ) {
-      // find byte within word
-      for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {
-        unsigned char __this_byte
-          = static_cast<unsigned char>(__thisword & (~(unsigned char)0));
-        if ( __this_byte )
-          return __i*__BITS_PER_WORD + __j*CHAR_BIT +
-            _First_one<true>::_S_first_one[__this_byte];
-
-        __thisword >>= CHAR_BIT;
-      }
-    }
-  }
-
-  // not found, so return an indication of failure.
-  return __not_found;
-} // end _M_do_find_next
-
-
-// ------------------------------------------------------------
-
-//
-// Base class: specialization for a single word.
-//
-
-__STL_TEMPLATE_NULL struct _Base_bitset<1> {
-  typedef unsigned long _WordT;
-  _WordT _M_w;
-
-  _Base_bitset( void ) : _M_w(0) {}
-  _Base_bitset(unsigned long __val) : _M_w(__val) {}
-
-  static size_t _S_whichword( size_t __pos )
-    { return __pos / __BITS_PER_WORD; }
-  static size_t _S_whichbyte( size_t __pos )
-    { return (__pos % __BITS_PER_WORD) / CHAR_BIT; }
-  static size_t _S_whichbit( size_t __pos )
-    {  return __pos % __BITS_PER_WORD; }
-  static _WordT _S_maskbit( size_t __pos )
-    { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
-
-  _WordT& _M_getword(size_t)       { return _M_w; }
-  _WordT  _M_getword(size_t) const { return _M_w; }
-
-  _WordT& _M_hiword()       { return _M_w; }
-  _WordT  _M_hiword() const { return _M_w; }
-
-  void _M_do_and(const _Base_bitset<1>& __x) { _M_w &= __x._M_w; }
-  void _M_do_or(const _Base_bitset<1>& __x)  { _M_w |= __x._M_w; }
-  void _M_do_xor(const _Base_bitset<1>& __x) { _M_w ^= __x._M_w; }
-  void _M_do_left_shift(size_t __shift)     { _M_w <<= __shift; }
-  void _M_do_right_shift(size_t __shift)    { _M_w >>= __shift; }
-  void _M_do_flip()                       { _M_w = ~_M_w; }
-  void _M_do_set()                        { _M_w = ~static_cast<_WordT>(0); }
-  void _M_do_reset()                      { _M_w = 0; }
-
-  bool _M_is_equal(const _Base_bitset<1>& __x) const
-    { return _M_w == __x._M_w; }
-  bool _M_is_any() const
-    { return _M_w != 0; }
-
-  size_t _M_do_count() const {
-    size_t __result = 0;
-    const unsigned char* __byte_ptr = (const unsigned char*)&_M_w;
-    const unsigned char* __end_ptr
-      = ((const unsigned char*)&_M_w)+sizeof(_M_w);
-    while ( __byte_ptr < __end_ptr ) {
-      __result += _Bit_count<true>::_S_bit_count[*__byte_ptr];
-      __byte_ptr++;
-    }
-    return __result;
-  }
-
-  unsigned long _M_do_to_ulong() const { return _M_w; }
-
-  size_t _M_do_find_first(size_t __not_found) const;
-
-  // find the next "on" bit that follows "prev"
-  size_t _M_do_find_next(size_t __prev, size_t __not_found) const; 
-
-};
-
-//
-// Definitions of non-inline functions from the single-word version of
-//  _Base_bitset.
-//
-
-size_t _Base_bitset<1>::_M_do_find_first(size_t __not_found) const
-{
-  _WordT __thisword = _M_w;
-
-  if ( __thisword != static_cast<_WordT>(0) ) {
-    // find byte within word
-    for ( size_t __j = 0; __j < sizeof(_WordT); __j++ ) {
-      unsigned char __this_byte
-        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));
-      if ( __this_byte )
-        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];
-
-      __thisword >>= CHAR_BIT;
-    }
-  }
-  // not found, so return a value that indicates failure.
-  return __not_found;
-}
-
-size_t _Base_bitset<1>::_M_do_find_next(size_t __prev, size_t __not_found ) const
-{
-  // make bound inclusive
-  ++__prev;
-
-  // check out of bounds
-  if ( __prev >= __BITS_PER_WORD )
-    return __not_found;
-
-    // search first (and only) word
-  _WordT __thisword = _M_w;
-
-  // mask off bits below bound
-  __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);
-
-  if ( __thisword != static_cast<_WordT>(0) ) {
-    // find byte within word
-    // get first byte into place
-    __thisword >>= _S_whichbyte(__prev) * CHAR_BIT;
-    for ( size_t __j = _S_whichbyte(__prev); __j < sizeof(_WordT); __j++ ) {
-      unsigned char __this_byte
-        = static_cast<unsigned char>(__thisword & (~(unsigned char)0));
-      if ( __this_byte )
-        return __j*CHAR_BIT + _First_one<true>::_S_first_one[__this_byte];
-
-      __thisword >>= CHAR_BIT;
-    }
-  }
-
-  // not found, so return a value that indicates failure.
-  return __not_found;
-} // end _M_do_find_next
-
-
-// ------------------------------------------------------------
-// Helper class to zero out the unused high-order bits in the highest word.
-
-template <size_t _Extrabits> struct _Sanitize {
-  static void _M_do_sanitize(unsigned long& __val)
-    { __val &= ~((~static_cast<unsigned long>(0)) << _Extrabits); }
-};
-
-__STL_TEMPLATE_NULL struct _Sanitize<0> {
-  static void _M_do_sanitize(unsigned long) {}
-};
-
-
-
-// ------------------------------------------------------------
-// Class bitset.
-//   _Nb may be any nonzero number of type size_t.
-
-template<size_t _Nb>
-class bitset : private _Base_bitset<__BITSET_WORDS(_Nb)>
-{
-private:
-  typedef _Base_bitset<__BITSET_WORDS(_Nb)> _Base;
-  typedef unsigned long _WordT;
-
-private:
-  void _M_do_sanitize() {
-    _Sanitize<_Nb%__BITS_PER_WORD>::_M_do_sanitize(this->_M_hiword());
-  }
-
-public:
-
-  // bit reference:
-  class reference;
-  friend class reference;
-
-  class reference {
-    friend class bitset;
-
-    _WordT *_M_wp;
-    size_t _M_bpos;
-
-    // left undefined
-    reference();
-
-  public:
-    reference( bitset& __b, size_t __pos ) {
-      _M_wp = &__b._M_getword(__pos);
-      _M_bpos = _Base::_S_whichbit(__pos);
-    }
-
-    ~reference() {}
-
-    // for b[i] = __x;
-    reference& operator=(bool __x) {
-      if ( __x )
-        *_M_wp |= _Base::_S_maskbit(_M_bpos);
-      else
-        *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
-
-      return *this;
-    }
-
-    // for b[i] = b[__j];
-    reference& operator=(const reference& __j) {
-      if ( (*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)) )
-        *_M_wp |= _Base::_S_maskbit(_M_bpos);
-      else
-        *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
-
-      return *this;
-    }
-
-    // flips the bit
-    bool operator~() const
-      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }
-
-    // for __x = b[i];
-    operator bool() const
-      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }
-
-    // for b[i].flip();
-    reference& flip() {
-      *_M_wp ^= _Base::_S_maskbit(_M_bpos);
-      return *this;
-    }
-  };
-
-  // 23.3.5.1 constructors:
-  bitset() {}
-  bitset(unsigned long __val) : _Base_bitset<__BITSET_WORDS(_Nb)>(__val) 
-    { _M_do_sanitize(); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template<class _CharT, class _Traits, class _Alloc>
-  explicit bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,
-                  size_t __pos = 0)
-    : _Base() 
-  {
-    if (__pos > __s.size()) {
-      __STL_THROW(out_of_range("bitset"));
-    }
-
-    _M_copy_from_string(__s, __pos,
-                        basic_string<_CharT, _Traits, _Alloc>::npos);
-  }
-  template<class _CharT, class _Traits, class _Alloc>
-  bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,
-         size_t __pos,
-         size_t __n)
-    : _Base() 
-  {
-    if (__pos > __s.size()) {
-      __STL_THROW(out_of_range("bitset"));
-    }
-    _M_copy_from_string(__s, __pos, __n);
-  }
-#else /* __STL_MEMBER_TEMPLATES */
-  explicit bitset(const basic_string<char>& __s,
-                  size_t __pos = 0,
-                  size_t __n = basic_string<char>::npos) 
-    : _Base() 
-  {
-    if (__pos > __s.size()) {
-      __STL_THROW(out_of_range("bitset"));
-    }
-
-    _M_copy_from_string(__s, __pos, __n);
-  }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  // 23.3.5.2 bitset operations:
-  bitset<_Nb>& operator&=(const bitset<_Nb>& __rhs) {
-    this->_M_do_and(__rhs);
-    return *this;
-  }
-
-  bitset<_Nb>& operator|=(const bitset<_Nb>& __rhs) {
-    this->_M_do_or(__rhs);
-    return *this;
-  }
-
-  bitset<_Nb>& operator^=(const bitset<_Nb>& __rhs) {
-    this->_M_do_xor(__rhs);
-    return *this;
-  }
-
-  bitset<_Nb>& operator<<=(size_t __pos) {
-    this->_M_do_left_shift(__pos);
-    this->_M_do_sanitize();
-    return *this;
-  }
-
-  bitset<_Nb>& operator>>=(size_t __pos) {
-    this->_M_do_right_shift(__pos);
-    this->_M_do_sanitize();
-    return *this;
-  }
-
-  //
-  // Extension:
-  // Versions of single-bit set, reset, flip, test with no range checking.
-  //
-
-  bitset<_Nb>& _Unchecked_set(size_t __pos) {
-    this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
-    return *this;
-  }
-
-  bitset<_Nb>& _Unchecked_set(size_t __pos, int __val) {
-    if (__val)
-      this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
-    else
-      this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
-
-    return *this;
-  }
-
-  bitset<_Nb>& _Unchecked_reset(size_t __pos) {
-    this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
-    return *this;
-  }
-
-  bitset<_Nb>& _Unchecked_flip(size_t __pos) {
-    this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
-    return *this;
-  }
-
-  bool _Unchecked_test(size_t __pos) const {
-    return (this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
-      != static_cast<_WordT>(0);
-  }
-
-  // Set, reset, and flip.
-
-  bitset<_Nb>& set() {
-    this->_M_do_set();
-    this->_M_do_sanitize();
-    return *this;
-  }
-
-  bitset<_Nb>& set(size_t __pos) {
-    if (__pos >= _Nb) {
-      __STL_THROW(out_of_range("bitset"));
-    }
-
-    return _Unchecked_set(__pos);
-  }
-
-  bitset<_Nb>& set(size_t __pos, int __val) {
-    if (__pos >= _Nb) {
-      __STL_THROW(out_of_range("bitset"));
-    }
-
-    return _Unchecked_set(__pos, __val);
-  }
-
-  bitset<_Nb>& reset() {
-    this->_M_do_reset();
-    return *this;
-  }
-
-  bitset<_Nb>& reset(size_t __pos) {
-    if (__pos >= _Nb) {
-      __STL_THROW(out_of_range("bitset"));
-    }
-
-    return _Unchecked_reset(__pos);
-  }
-
-  bitset<_Nb>& flip() {
-    this->_M_do_flip();
-    this->_M_do_sanitize();
-    return *this;
-  }
-
-  bitset<_Nb>& flip(size_t __pos) {
-    if (__pos >= _Nb) {
-      __STL_THROW(out_of_range("bitset"));
-    }
-
-    return _Unchecked_flip(__pos);
-  }
-
-  bitset<_Nb> operator~() const { 
-    return bitset<_Nb>(*this).flip();
-  }
-
-  // element access:
-  //for b[i];
-  reference operator[](size_t __pos) { return reference(*this,__pos); }
-  bool operator[](size_t __pos) const { return _Unchecked_test(__pos); }
-
-  unsigned long to_ulong() const { return this->_M_do_to_ulong(); }
-
-#if defined(__STL_MEMBER_TEMPLATES) && \
-    defined(__STL_EXPLICIT_FUNCTION_TMPL_ARGS)
-  template <class _CharT, class _Traits, class _Alloc>
-  basic_string<_CharT, _Traits, _Alloc> to_string() const {
-    basic_string<_CharT, _Traits, _Alloc> __result;
-    _M_copy_to_string(__result);
-    return __result;
-  }
-#endif /* member templates and explicit function template args */
-
-  // Helper functions for string operations.
-#ifdef __STL_MEMBER_TEMPLATES
-  template<class _CharT, class _Traits, class _Alloc>
-  void _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,
-                          size_t,
-                          size_t);
-
-  template<class _CharT, class _Traits, class _Alloc>
-  void _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;
-#else /* __STL_MEMBER_TEMPLATES */
-  void _M_copy_from_string(const basic_string<char>&, size_t, size_t);
-  void _M_copy_to_string(basic_string<char>&) const;
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  size_t count() const { return this->_M_do_count(); }
-
-  size_t size() const { return _Nb; }
-
-  bool operator==(const bitset<_Nb>& __rhs) const {
-    return this->_M_is_equal(__rhs);
-  }
-  bool operator!=(const bitset<_Nb>& __rhs) const {
-    return !this->_M_is_equal(__rhs);
-  }
-
-  bool test(size_t __pos) const {
-    if (__pos > _Nb) {
-      __STL_THROW(out_of_range("bitset"));
-    }
-
-    return _Unchecked_test(__pos);
-  }
-
-  bool any() const { return this->_M_is_any(); }
-  bool none() const { return !this->_M_is_any(); }
-
-  bitset<_Nb> operator<<(size_t __pos) const
-    { return bitset<_Nb>(*this) <<= __pos; }
-  bitset<_Nb> operator>>(size_t __pos) const
-    { return bitset<_Nb>(*this) >>= __pos; }
-
-  //
-  // EXTENSIONS: bit-find operations.  These operations are
-  // experimental, and are subject to change or removal in future
-  // versions.
-  // 
-
-  // find the index of the first "on" bit
-  size_t _Find_first() const 
-    { return this->_M_do_find_first(_Nb); }
-
-  // find the index of the next "on" bit after prev
-  size_t _Find_next( size_t __prev ) const 
-    { return this->_M_do_find_next(__prev, _Nb); }
-
-};
-
-//
-// Definitions of non-inline member functions.
-//
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <size_t _Nb>
-template<class _CharT, class _Traits, class _Alloc>
-void bitset<_Nb>
-  ::_M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,
-                        size_t __pos,
-                        size_t __n)
-{
-  reset();
-  const size_t __nbits = min(_Nb, min(__n, __s.size() - __pos));
-  for (size_t __i = 0; __i < __nbits; ++__i) {
-    switch(__s[__pos + __nbits - __i - 1]) {
-    case '0':
-      break;
-    case '1':
-      set(__i);
-      break;
-    default:
-      __STL_THROW(invalid_argument("bitset"));
-    }
-  }
-}
-
-template <size_t _Nb>
-template <class _CharT, class _Traits, class _Alloc>
-void bitset<_Nb>
-  ::_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>& __s) const
-{
-  __s.assign(_Nb, '0');
-  
-  for (size_t __i = 0; __i < _Nb; ++__i) 
-    if (_Unchecked_test(__i))
-      __s[_Nb - 1 - __i] = '1';
-}
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-template <size_t _Nb>
-void bitset<_Nb>::_M_copy_from_string(const basic_string<char>& __s,
-                                      size_t __pos, size_t __n)
-{
-  reset();
-  size_t __tmp = _Nb;
-  const size_t __nbits = min(__tmp, min(__n, __s.size() - __pos));
-  for (size_t __i = 0; __i < __nbits; ++__i) {
-    switch(__s[__pos + __nbits - __i - 1]) {
-    case '0':
-      break;
-    case '1':
-      set(__i);
-      break;
-    default:
-      __STL_THROW(invalid_argument("bitset"));
-    }
-  }
-}
-
-template <size_t _Nb>
-void bitset<_Nb>::_M_copy_to_string(basic_string<char>& __s) const
-{
-  __s.assign(_Nb, '0');
-  
-  for (size_t __i = 0; __i < _Nb; ++__i) 
-    if (_Unchecked_test(__i))
-      __s[_Nb - 1 - __i] = '1';
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-// ------------------------------------------------------------
-
-//
-// 23.3.5.3 bitset operations:
-//
-
-template <size_t _Nb>
-inline bitset<_Nb> operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {
-  bitset<_Nb> __result(__x);
-  __result &= __y;
-  return __result;
-}
-
-
-template <size_t _Nb>
-inline bitset<_Nb> operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {
-  bitset<_Nb> __result(__x);
-  __result |= __y;
-  return __result;
-}
-
-template <size_t _Nb>
-inline bitset<_Nb> operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) {
-  bitset<_Nb> __result(__x);
-  __result ^= __y;
-  return __result;
-}
-
-#ifdef __STL_USE_NEW_IOSTREAMS
-
-template <class _CharT, class _Traits, size_t _Nb>
-basic_istream<_CharT, _Traits>&
-operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)
-{
-  basic_string<_CharT, _Traits> __tmp;
-  __tmp.reserve(_Nb);
-
-  // Skip whitespace
-  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is);
-  if (__sentry) {
-    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
-    for (size_t __i = 0; __i < _Nb; ++__i) {
-      static typename _Traits::int_type __eof = _Traits::eof();
-
-      typename _Traits::int_type __c1 = __buf->sbumpc();
-      if (_Traits::eq_int_type(__c1, __eof)) {
-        __is.setstate(ios_base::eofbit);
-        break;
-      }
-      else {
-        char __c2 = _Traits::to_char_type(__c1);
-        char __c  = __is.narrow(__c2, '*');
-
-        if (__c == '0' || __c == '1')
-          __tmp.push_back(__c);
-        else if (_Traits::eq_int_type(__buf->sputbackc(__c2), __eof)) {
-          __is.setstate(ios_base::failbit);
-          break;
-        }
-      }
-    }
-
-    if (__tmp.empty())
-      __is.setstate(ios_base::failbit);
-    else
-      __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);
-  }
-
-  return __is;
-}
-
-template <class _CharT, class _Traits, size_t _Nb>
-basic_ostream<_CharT, _Traits>&
-operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Nb>& __x)
-{
-  basic_string<_CharT, _Traits> __tmp;
-  __x._M_copy_to_string(__tmp);
-  return __os << __tmp;
-}
-
-#else /* __STL_USE_NEW_IOSTREAMS */
-
-template <size_t _Nb>
-istream& operator>>(istream& __is, bitset<_Nb>& __x) {
-  string __tmp;
-  __tmp.reserve(_Nb);
-
-  if (__is.flags() & ios::skipws) {
-    char __c;
-    do 
-      __is.get(__c);
-    while (__is && isspace(__c));
-    if (__is)
-      __is.putback(__c);
-  }
-
-  for (size_t __i = 0; __i < _Nb; ++__i) {
-    char __c;
-    __is.get(__c);
-
-    if (!__is)
-      break;
-    else if (__c != '0' && __c != '1') {
-      __is.putback(__c);
-      break;
-    }
-    else
-      __tmp.push_back(__c);
-  }
-
-  if (__tmp.empty()) 
-    __is.clear(__is.rdstate() | ios::failbit);
-  else
-    __x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb);
-
-  return __is;
-}
-
-template <size_t _Nb>
-ostream& operator<<(ostream& __os, const bitset<_Nb>& __x) {
-  string __tmp;
-  __x._M_copy_to_string(__tmp);
-  return __os << __tmp;
-}
-
-#endif /* __STL_USE_NEW_IOSTREAMS */
-
-
-// ------------------------------------------------------------
-// Lookup tables for find and count operations.
-
-template<bool __dummy>
-unsigned char _Bit_count<__dummy>::_S_bit_count[] = {
-  0, /*   0 */ 1, /*   1 */ 1, /*   2 */ 2, /*   3 */ 1, /*   4 */
-  2, /*   5 */ 2, /*   6 */ 3, /*   7 */ 1, /*   8 */ 2, /*   9 */
-  2, /*  10 */ 3, /*  11 */ 2, /*  12 */ 3, /*  13 */ 3, /*  14 */
-  4, /*  15 */ 1, /*  16 */ 2, /*  17 */ 2, /*  18 */ 3, /*  19 */
-  2, /*  20 */ 3, /*  21 */ 3, /*  22 */ 4, /*  23 */ 2, /*  24 */
-  3, /*  25 */ 3, /*  26 */ 4, /*  27 */ 3, /*  28 */ 4, /*  29 */
-  4, /*  30 */ 5, /*  31 */ 1, /*  32 */ 2, /*  33 */ 2, /*  34 */
-  3, /*  35 */ 2, /*  36 */ 3, /*  37 */ 3, /*  38 */ 4, /*  39 */
-  2, /*  40 */ 3, /*  41 */ 3, /*  42 */ 4, /*  43 */ 3, /*  44 */
-  4, /*  45 */ 4, /*  46 */ 5, /*  47 */ 2, /*  48 */ 3, /*  49 */
-  3, /*  50 */ 4, /*  51 */ 3, /*  52 */ 4, /*  53 */ 4, /*  54 */
-  5, /*  55 */ 3, /*  56 */ 4, /*  57 */ 4, /*  58 */ 5, /*  59 */
-  4, /*  60 */ 5, /*  61 */ 5, /*  62 */ 6, /*  63 */ 1, /*  64 */
-  2, /*  65 */ 2, /*  66 */ 3, /*  67 */ 2, /*  68 */ 3, /*  69 */
-  3, /*  70 */ 4, /*  71 */ 2, /*  72 */ 3, /*  73 */ 3, /*  74 */
-  4, /*  75 */ 3, /*  76 */ 4, /*  77 */ 4, /*  78 */ 5, /*  79 */
-  2, /*  80 */ 3, /*  81 */ 3, /*  82 */ 4, /*  83 */ 3, /*  84 */
-  4, /*  85 */ 4, /*  86 */ 5, /*  87 */ 3, /*  88 */ 4, /*  89 */
-  4, /*  90 */ 5, /*  91 */ 4, /*  92 */ 5, /*  93 */ 5, /*  94 */
-  6, /*  95 */ 2, /*  96 */ 3, /*  97 */ 3, /*  98 */ 4, /*  99 */
-  3, /* 100 */ 4, /* 101 */ 4, /* 102 */ 5, /* 103 */ 3, /* 104 */
-  4, /* 105 */ 4, /* 106 */ 5, /* 107 */ 4, /* 108 */ 5, /* 109 */
-  5, /* 110 */ 6, /* 111 */ 3, /* 112 */ 4, /* 113 */ 4, /* 114 */
-  5, /* 115 */ 4, /* 116 */ 5, /* 117 */ 5, /* 118 */ 6, /* 119 */
-  4, /* 120 */ 5, /* 121 */ 5, /* 122 */ 6, /* 123 */ 5, /* 124 */
-  6, /* 125 */ 6, /* 126 */ 7, /* 127 */ 1, /* 128 */ 2, /* 129 */
-  2, /* 130 */ 3, /* 131 */ 2, /* 132 */ 3, /* 133 */ 3, /* 134 */
-  4, /* 135 */ 2, /* 136 */ 3, /* 137 */ 3, /* 138 */ 4, /* 139 */
-  3, /* 140 */ 4, /* 141 */ 4, /* 142 */ 5, /* 143 */ 2, /* 144 */
-  3, /* 145 */ 3, /* 146 */ 4, /* 147 */ 3, /* 148 */ 4, /* 149 */
-  4, /* 150 */ 5, /* 151 */ 3, /* 152 */ 4, /* 153 */ 4, /* 154 */
-  5, /* 155 */ 4, /* 156 */ 5, /* 157 */ 5, /* 158 */ 6, /* 159 */
-  2, /* 160 */ 3, /* 161 */ 3, /* 162 */ 4, /* 163 */ 3, /* 164 */
-  4, /* 165 */ 4, /* 166 */ 5, /* 167 */ 3, /* 168 */ 4, /* 169 */
-  4, /* 170 */ 5, /* 171 */ 4, /* 172 */ 5, /* 173 */ 5, /* 174 */
-  6, /* 175 */ 3, /* 176 */ 4, /* 177 */ 4, /* 178 */ 5, /* 179 */
-  4, /* 180 */ 5, /* 181 */ 5, /* 182 */ 6, /* 183 */ 4, /* 184 */
-  5, /* 185 */ 5, /* 186 */ 6, /* 187 */ 5, /* 188 */ 6, /* 189 */
-  6, /* 190 */ 7, /* 191 */ 2, /* 192 */ 3, /* 193 */ 3, /* 194 */
-  4, /* 195 */ 3, /* 196 */ 4, /* 197 */ 4, /* 198 */ 5, /* 199 */
-  3, /* 200 */ 4, /* 201 */ 4, /* 202 */ 5, /* 203 */ 4, /* 204 */
-  5, /* 205 */ 5, /* 206 */ 6, /* 207 */ 3, /* 208 */ 4, /* 209 */
-  4, /* 210 */ 5, /* 211 */ 4, /* 212 */ 5, /* 213 */ 5, /* 214 */
-  6, /* 215 */ 4, /* 216 */ 5, /* 217 */ 5, /* 218 */ 6, /* 219 */
-  5, /* 220 */ 6, /* 221 */ 6, /* 222 */ 7, /* 223 */ 3, /* 224 */
-  4, /* 225 */ 4, /* 226 */ 5, /* 227 */ 4, /* 228 */ 5, /* 229 */
-  5, /* 230 */ 6, /* 231 */ 4, /* 232 */ 5, /* 233 */ 5, /* 234 */
-  6, /* 235 */ 5, /* 236 */ 6, /* 237 */ 6, /* 238 */ 7, /* 239 */
-  4, /* 240 */ 5, /* 241 */ 5, /* 242 */ 6, /* 243 */ 5, /* 244 */
-  6, /* 245 */ 6, /* 246 */ 7, /* 247 */ 5, /* 248 */ 6, /* 249 */
-  6, /* 250 */ 7, /* 251 */ 6, /* 252 */ 7, /* 253 */ 7, /* 254 */
-  8  /* 255 */
-}; // end _Bit_count
-
-template<bool __dummy>
-unsigned char _First_one<__dummy>::_S_first_one[] = {
-  0, /*   0 */ 0, /*   1 */ 1, /*   2 */ 0, /*   3 */ 2, /*   4 */
-  0, /*   5 */ 1, /*   6 */ 0, /*   7 */ 3, /*   8 */ 0, /*   9 */
-  1, /*  10 */ 0, /*  11 */ 2, /*  12 */ 0, /*  13 */ 1, /*  14 */
-  0, /*  15 */ 4, /*  16 */ 0, /*  17 */ 1, /*  18 */ 0, /*  19 */
-  2, /*  20 */ 0, /*  21 */ 1, /*  22 */ 0, /*  23 */ 3, /*  24 */
-  0, /*  25 */ 1, /*  26 */ 0, /*  27 */ 2, /*  28 */ 0, /*  29 */
-  1, /*  30 */ 0, /*  31 */ 5, /*  32 */ 0, /*  33 */ 1, /*  34 */
-  0, /*  35 */ 2, /*  36 */ 0, /*  37 */ 1, /*  38 */ 0, /*  39 */
-  3, /*  40 */ 0, /*  41 */ 1, /*  42 */ 0, /*  43 */ 2, /*  44 */
-  0, /*  45 */ 1, /*  46 */ 0, /*  47 */ 4, /*  48 */ 0, /*  49 */
-  1, /*  50 */ 0, /*  51 */ 2, /*  52 */ 0, /*  53 */ 1, /*  54 */
-  0, /*  55 */ 3, /*  56 */ 0, /*  57 */ 1, /*  58 */ 0, /*  59 */
-  2, /*  60 */ 0, /*  61 */ 1, /*  62 */ 0, /*  63 */ 6, /*  64 */
-  0, /*  65 */ 1, /*  66 */ 0, /*  67 */ 2, /*  68 */ 0, /*  69 */
-  1, /*  70 */ 0, /*  71 */ 3, /*  72 */ 0, /*  73 */ 1, /*  74 */
-  0, /*  75 */ 2, /*  76 */ 0, /*  77 */ 1, /*  78 */ 0, /*  79 */
-  4, /*  80 */ 0, /*  81 */ 1, /*  82 */ 0, /*  83 */ 2, /*  84 */
-  0, /*  85 */ 1, /*  86 */ 0, /*  87 */ 3, /*  88 */ 0, /*  89 */
-  1, /*  90 */ 0, /*  91 */ 2, /*  92 */ 0, /*  93 */ 1, /*  94 */
-  0, /*  95 */ 5, /*  96 */ 0, /*  97 */ 1, /*  98 */ 0, /*  99 */
-  2, /* 100 */ 0, /* 101 */ 1, /* 102 */ 0, /* 103 */ 3, /* 104 */
-  0, /* 105 */ 1, /* 106 */ 0, /* 107 */ 2, /* 108 */ 0, /* 109 */
-  1, /* 110 */ 0, /* 111 */ 4, /* 112 */ 0, /* 113 */ 1, /* 114 */
-  0, /* 115 */ 2, /* 116 */ 0, /* 117 */ 1, /* 118 */ 0, /* 119 */
-  3, /* 120 */ 0, /* 121 */ 1, /* 122 */ 0, /* 123 */ 2, /* 124 */
-  0, /* 125 */ 1, /* 126 */ 0, /* 127 */ 7, /* 128 */ 0, /* 129 */
-  1, /* 130 */ 0, /* 131 */ 2, /* 132 */ 0, /* 133 */ 1, /* 134 */
-  0, /* 135 */ 3, /* 136 */ 0, /* 137 */ 1, /* 138 */ 0, /* 139 */
-  2, /* 140 */ 0, /* 141 */ 1, /* 142 */ 0, /* 143 */ 4, /* 144 */
-  0, /* 145 */ 1, /* 146 */ 0, /* 147 */ 2, /* 148 */ 0, /* 149 */
-  1, /* 150 */ 0, /* 151 */ 3, /* 152 */ 0, /* 153 */ 1, /* 154 */
-  0, /* 155 */ 2, /* 156 */ 0, /* 157 */ 1, /* 158 */ 0, /* 159 */
-  5, /* 160 */ 0, /* 161 */ 1, /* 162 */ 0, /* 163 */ 2, /* 164 */
-  0, /* 165 */ 1, /* 166 */ 0, /* 167 */ 3, /* 168 */ 0, /* 169 */
-  1, /* 170 */ 0, /* 171 */ 2, /* 172 */ 0, /* 173 */ 1, /* 174 */
-  0, /* 175 */ 4, /* 176 */ 0, /* 177 */ 1, /* 178 */ 0, /* 179 */
-  2, /* 180 */ 0, /* 181 */ 1, /* 182 */ 0, /* 183 */ 3, /* 184 */
-  0, /* 185 */ 1, /* 186 */ 0, /* 187 */ 2, /* 188 */ 0, /* 189 */
-  1, /* 190 */ 0, /* 191 */ 6, /* 192 */ 0, /* 193 */ 1, /* 194 */
-  0, /* 195 */ 2, /* 196 */ 0, /* 197 */ 1, /* 198 */ 0, /* 199 */
-  3, /* 200 */ 0, /* 201 */ 1, /* 202 */ 0, /* 203 */ 2, /* 204 */
-  0, /* 205 */ 1, /* 206 */ 0, /* 207 */ 4, /* 208 */ 0, /* 209 */
-  1, /* 210 */ 0, /* 211 */ 2, /* 212 */ 0, /* 213 */ 1, /* 214 */
-  0, /* 215 */ 3, /* 216 */ 0, /* 217 */ 1, /* 218 */ 0, /* 219 */
-  2, /* 220 */ 0, /* 221 */ 1, /* 222 */ 0, /* 223 */ 5, /* 224 */
-  0, /* 225 */ 1, /* 226 */ 0, /* 227 */ 2, /* 228 */ 0, /* 229 */
-  1, /* 230 */ 0, /* 231 */ 3, /* 232 */ 0, /* 233 */ 1, /* 234 */
-  0, /* 235 */ 2, /* 236 */ 0, /* 237 */ 1, /* 238 */ 0, /* 239 */
-  4, /* 240 */ 0, /* 241 */ 1, /* 242 */ 0, /* 243 */ 2, /* 244 */
-  0, /* 245 */ 1, /* 246 */ 0, /* 247 */ 3, /* 248 */ 0, /* 249 */
-  1, /* 250 */ 0, /* 251 */ 2, /* 252 */ 0, /* 253 */ 1, /* 254 */
-  0, /* 255 */
-}; // end _First_one
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1209
-#endif
-
-__STL_END_NAMESPACE
-
-
-#undef __BITS_PER_WORD
-#undef __BITSET_WORDS
-
-#endif /* __SGI_STL_BITSET */
-
-
-// Local Variables:
-// mode:C++
-// End:
-
diff --git a/lib/include/stl/cctype b/lib/include/stl/cctype
deleted file mode 100644
index ef12b1f..0000000
--- a/lib/include/stl/cctype
+++ /dev/null
@@ -1,37 +0,0 @@
-/*	Copyright (C) 2006 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <ctype.h>
-
-namespace std{
-
-	using ::isalnum;
-	using ::isalpha;
-	using ::iscntrl;
-	using ::isdigit;
-	using ::isgraph;
-	using ::islower;
-	using ::isprint;
-	using ::ispunct;
-	using ::isspace;
-	using ::isupper;
-	using ::isxdigit;
-	using ::tolower;
-	using ::toupper;
-
-}
diff --git a/lib/include/stl/char_traits.h b/lib/include/stl/char_traits.h
deleted file mode 100644
index b89aa73..0000000
--- a/lib/include/stl/char_traits.h
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */ 
-
-#ifndef __SGI_STL_CHAR_TRAITS_H
-#define __SGI_STL_CHAR_TRAITS_H
-
-#include <string.h>
-
-#ifndef STM32PLUS_BUILD
-#include <wchar.h>
-#endif
-
-#ifndef STM32PLUS_BUILD
-#if defined(__STL_USE_NEW_IOSTREAMS) && !defined(__SGI_STL_IOSFWD)
-#include <iosfwd>
-#endif /* use new iostreams */
-#endif
-
-__STL_BEGIN_NAMESPACE
-
-// Class __char_traits_base.
-
-template <class _CharT, class _IntT> class __char_traits_base {
-public:
-  typedef _CharT char_type;
-  typedef _IntT int_type;
-
-#ifdef STM32PLUS_BUILD
-  typedef signed int char_traits_off_type;
-  typedef char state_type;
-  typedef char_traits_off_type off_type;
-  typedef char_traits_off_type pos_type;
-#else
-#ifdef __STL_USE_NEW_IOSTREAMS
-  typedef streamoff off_type;
-  typedef streampos pos_type;
-  typedef mbstate_t state_type;
-#endif /* __STL_USE_NEW_IOSTREAMS */
-#endif // STM32PLUS_BUILD
-
-  static void assign(char_type& __c1, const char_type& __c2) { __c1 = __c2; }
-  static bool eq(const _CharT& __c1, const _CharT& __c2) 
-    { return __c1 == __c2; }
-  static bool lt(const _CharT& __c1, const _CharT& __c2) 
-    { return __c1 < __c2; }
-
-  static int compare(const _CharT* __s1, const _CharT* __s2, size_t __n) {
-    for (size_t __i = 0; __i < __n; ++__i)
-      if (!eq(__s1[__i], __s2[__i]))
-        return __s1[__i] < __s2[__i] ? -1 : 1;
-    return 0;
-  }
-
-  static size_t length(const _CharT* __s) {
-    const _CharT __nullchar = _CharT();
-    size_t __i;
-    for (__i = 0; !eq(__s[__i], __nullchar); ++__i)
-      {}
-    return __i;
-  }
-
-  static const _CharT* find(const _CharT* __s, size_t __n, const _CharT& __c)
-  {
-    for ( ; __n > 0 ; ++__s, --__n)
-      if (eq(*__s, __c))
-        return __s;
-    return 0;
-  }
-
-  static _CharT* move(_CharT* __s1, const _CharT* __s2, size_t __n) {
-    memmove(__s1, __s2, __n * sizeof(_CharT));
-    return __s1;
-  }
-    
-  static _CharT* copy(_CharT* __s1, const _CharT* __s2, size_t __n) {
-    memcpy(__s1, __s2, __n * sizeof(_CharT));
-    return __s1;
-  } 
-
-  static _CharT* assign(_CharT* __s, size_t __n, _CharT __c) {
-    for (size_t __i = 0; __i < __n; ++__i)
-      __s[__i] = __c;
-    return __s;
-  }
-
-  static int_type not_eof(const int_type& __c) {
-    return !eq_int_type(__c, eof()) ? __c : 0;
-  }
-
-  static char_type to_char_type(const int_type& __c) {
-    return static_cast<char_type>(__c);
-  }
-
-  static int_type to_int_type(const char_type& __c) {
-    return static_cast<int_type>(__c);
-  }
-
-  static bool eq_int_type(const int_type& __c1, const int_type& __c2) {
-    return __c1 == __c2;
-  }
-
-  static int_type eof() {
-    return static_cast<int_type>(-1);
-  }
-};
-
-// Generic char_traits class.  Note that this class is provided only
-//  as a base for explicit specialization; it is unlikely to be useful
-//  as is for any particular user-defined type.  In particular, it 
-//  *will not work* for a non-POD type.
-
-template <class _CharT> class char_traits
-  : public __char_traits_base<_CharT, _CharT>
-{};
-
-// Specialization for char.
-
-__STL_TEMPLATE_nullptr class char_traits<char> 
-  : public __char_traits_base<char, int>
-{
-public:
-  static char_type to_char_type(const int_type& __c) {
-    return static_cast<char_type>(static_cast<unsigned char>(__c));
-  }
-
-  static int_type to_int_type(const char_type& __c) {
-    return static_cast<unsigned char>(__c);
-  }
-
-  static int compare(const char* __s1, const char* __s2, size_t __n) 
-    { return memcmp(__s1, __s2, __n); }
-  
-  static size_t length(const char* __s) { return strlen(__s); }
-
-  static void assign(char& __c1, const char& __c2) { __c1 = __c2; }
-
-  static char* assign(char* __s, size_t __n, char __c)
-    { memset(__s, __c, __n); return __s; }
-};
-
-#ifndef STM32PLUS_BUILD
-// Specialization for wchar_t.
-
-__STL_TEMPLATE_nullptr class char_traits<wchar_t>
-  : public __char_traits_base<wchar_t, wint_t>
-{};
-#endif // ! STM32PLUS_BUILD
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_CHAR_TRAITS_H */
-
-// Local Variables:
-// mode:C++
-// End:
-
diff --git a/lib/include/stl/concept_checks.h b/lib/include/stl/concept_checks.h
deleted file mode 100644
index 36df283..0000000
--- a/lib/include/stl/concept_checks.h
+++ /dev/null
@@ -1,811 +0,0 @@
-/*
- * Copyright (c) 1999
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __CONCEPT_CHECKS_H
-#define __CONCEPT_CHECKS_H
-
-/*
-  Use these macro like assertions, but they assert properties
-  on types (usually template arguments). In technical terms they
-  verify whether a type "models" a "concept".
-
-  This set of requirements and the terminology used here is derived
-  from the book "Generic Programming and the STL" by Matt Austern
-  (Addison Wesley). For further information please consult that
-  book. The requirements also are intended to match the ANSI/ISO C++
-  standard.
-
-  This file covers the basic concepts and the iterator concepts.
-  There are several other files that provide the requirements
-  for the STL containers:
-    container_concepts.h
-    sequence_concepts.h
-    assoc_container_concepts.h
-
-  Jeremy Siek, 1999
-
-  TO DO:
-    - some issues with regards to concept classification and mutability
-      including AssociativeContianer -> ForwardContainer
-      and SortedAssociativeContainer -> ReversibleContainer
-    - HashedAssociativeContainer
-    - Allocator
-    - Function Object Concepts
-
-  */
-
-#ifndef __STL_USE_CONCEPT_CHECKS
-
-// Some compilers lack the features that are necessary for concept checks.
-// On those compilers we define the concept check macros to do nothing.
-#define __STL_REQUIRES(__type_var, __concept) do {} while(0)
-#define __STL_CLASS_REQUIRES(__type_var, __concept) \
-  static int  __##__type_var##_##__concept
-#define __STL_CONVERTIBLE(__type_x, __type_y) do {} while(0)
-#define __STL_REQUIRES_SAME_TYPE(__type_x, __type_y) do {} while(0)
-#define __STL_CLASS_REQUIRES_SAME_TYPE(__type_x, __type_y) \
-  static int  __##__type_x##__type_y##_require_same_type
-#define __STL_GENERATOR_CHECK(__func, __ret) do {} while(0)
-#define __STL_CLASS_GENERATOR_CHECK(__func, __ret) \
-  static int  __##__func##__ret##_generator_check
-#define __STL_UNARY_FUNCTION_CHECK(__func, __ret, __arg) do {} while(0)
-#define __STL_CLASS_UNARY_FUNCTION_CHECK(__func, __ret, __arg) \
-  static int  __##__func##__ret##__arg##_unary_function_check
-#define __STL_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \
-  do {} while(0)
-#define __STL_CLASS_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \
-  static int  __##__func##__ret##__first##__second##_binary_function_check
-#define __STL_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \
-  do {} while(0)
-#define __STL_CLASS_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \
-  static int __##__opname##__ret##__first##__second##_require_binary_op
-
-#else /* __STL_USE_CONCEPT_CHECKS */
-
-// This macro tests whether the template argument "__type_var"
-// satisfies the requirements of "__concept".  Here is a list of concepts
-// that we know how to check:
-//       _Allocator
-//       _Assignable
-//       _DefaultConstructible
-//       _EqualityComparable
-//       _LessThanComparable
-//       _TrivialIterator
-//       _InputIterator
-//       _OutputIterator
-//       _ForwardIterator
-//       _BidirectionalIterator
-//       _RandomAccessIterator
-//       _Mutable_TrivialIterator
-//       _Mutable_ForwardIterator
-//       _Mutable_BidirectionalIterator
-//       _Mutable_RandomAccessIterator
-
-#define __STL_REQUIRES(__type_var, __concept) \
-do { \
-  void (*__x)( __type_var ) = __concept##_concept_specification< __type_var >\
-    ::__concept##_requirement_violation; __x = __x; } while (0)
-
-// Use this to check whether type X is convertible to type Y
-#define __STL_CONVERTIBLE(__type_x, __type_y) \
-do { \
-  void (*__x)( __type_x , __type_y ) = _STL_CONVERT_ERROR< __type_x , \
-  __type_y >::__type_X_is_not_convertible_to_type_Y; \
-  __x = __x; } while (0)
-
-// Use this to test whether two template arguments are the same type
-#define __STL_REQUIRES_SAME_TYPE(__type_x, __type_y) \
-do { \
-  void (*__x)( __type_x , __type_y ) = _STL_SAME_TYPE_ERROR< __type_x, \
-    __type_y  >::__type_X_not_same_as_type_Y; \
-  __x = __x; } while (0)
-
-
-// function object checks
-#define __STL_GENERATOR_CHECK(__func, __ret) \
-do { \
-  __ret (*__x)( __func&) = \
-     _STL_GENERATOR_ERROR< \
-  __func, __ret>::__generator_requirement_violation; \
-  __x = __x; } while (0)
-
-
-#define __STL_UNARY_FUNCTION_CHECK(__func, __ret, __arg) \
-do { \
-  __ret (*__x)( __func&, const __arg& ) = \
-     _STL_UNARY_FUNCTION_ERROR< \
-  __func, __ret, __arg>::__unary_function_requirement_violation; \
-  __x = __x; } while (0)
-
-
-#define __STL_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \
-do { \
-  __ret (*__x)( __func&, const __first&, const __second& ) = \
-     _STL_BINARY_FUNCTION_ERROR< \
-  __func, __ret, __first, __second>::__binary_function_requirement_violation; \
-  __x = __x; } while (0)
-
-
-#define __STL_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \
-    do { \
-  __ret (*__x)( __first&, __second& ) = _STL_BINARY##__opname##_ERROR< \
-    __ret, __first, __second>::__binary_operator_requirement_violation; \
-  __ret (*__y)( const __first&, const __second& ) = \
-    _STL_BINARY##__opname##_ERROR< __ret, __first, __second>:: \
-      __const_binary_operator_requirement_violation; \
-  __y = __y; __x = __x; } while (0)
-
-
-#ifdef __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE
-
-#define __STL_CLASS_REQUIRES(__type_var, __concept)
-#define __STL_CLASS_REQUIRES_SAME_TYPE(__type_x, __type_y)
-#define __STL_CLASS_GENERATOR_CHECK(__func, __ret)
-#define __STL_CLASS_UNARY_FUNCTION_CHECK(__func, __ret, __arg)
-#define __STL_CLASS_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second)
-#define __STL_CLASS_REQUIRES_BINARY_OP(__opname, __ret, __first, __second)
-
-#else
-
-// Use this macro inside of template classes, where you would
-// like to place requirements on the template arguments to the class
-// Warning: do not pass pointers and such (e.g. T*) in as the __type_var,
-// since the type_var is used to construct identifiers. Instead typedef
-// the pointer type, then use the typedef name for the __type_var.
-#define __STL_CLASS_REQUIRES(__type_var, __concept) \
-  typedef void (* __func##__type_var##__concept)( __type_var ); \
-  template <__func##__type_var##__concept _Tp1> \
-  struct __dummy_struct_##__type_var##__concept { }; \
-  static __dummy_struct_##__type_var##__concept< \
-    __concept##_concept_specification< \
-      __type_var>::__concept##_requirement_violation>  \
-  __dummy_ptr_##__type_var##__concept
-
-
-#define __STL_CLASS_REQUIRES_SAME_TYPE(__type_x, __type_y) \
-  typedef void (* __func_##__type_x##__type_y##same_type)( __type_x, \
-                                                            __type_y ); \
-  template < __func_##__type_x##__type_y##same_type _Tp1> \
-  struct __dummy_struct_##__type_x##__type_y##_same_type { }; \
-  static __dummy_struct_##__type_x##__type_y##_same_type< \
-    _STL_SAME_TYPE_ERROR<__type_x, __type_y>::__type_X_not_same_as_type_Y>  \
-  __dummy_ptr_##__type_x##__type_y##_same_type
-
-
-#define __STL_CLASS_GENERATOR_CHECK(__func, __ret) \
-  typedef __ret (* __f_##__func##__ret##_generator)( __func& ); \
-  template <__f_##__func##__ret##_generator _Tp1> \
-  struct __dummy_struct_##__func##__ret##_generator { }; \
-  static __dummy_struct_##__func##__ret##_generator< \
-    _STL_GENERATOR_ERROR< \
-      __func, __ret>::__generator_requirement_violation>  \
-  __dummy_ptr_##__func##__ret##_generator
-
-
-#define __STL_CLASS_UNARY_FUNCTION_CHECK(__func, __ret, __arg) \
-  typedef __ret (* __f_##__func##__ret##__arg##_unary_check)( __func&, \
-                                                         const __arg& ); \
-  template <__f_##__func##__ret##__arg##_unary_check _Tp1> \
-  struct __dummy_struct_##__func##__ret##__arg##_unary_check { }; \
-  static __dummy_struct_##__func##__ret##__arg##_unary_check< \
-    _STL_UNARY_FUNCTION_ERROR< \
-      __func, __ret, __arg>::__unary_function_requirement_violation>  \
-  __dummy_ptr_##__func##__ret##__arg##_unary_check
-
-
-#define __STL_CLASS_BINARY_FUNCTION_CHECK(__func, __ret, __first, __second) \
-  typedef __ret (* __f_##__func##__ret##__first##__second##_binary_check)( __func&, const __first&,\
-                                                    const __second& ); \
-  template <__f_##__func##__ret##__first##__second##_binary_check _Tp1> \
-  struct __dummy_struct_##__func##__ret##__first##__second##_binary_check { }; \
-  static __dummy_struct_##__func##__ret##__first##__second##_binary_check< \
-    _STL_BINARY_FUNCTION_ERROR<__func, __ret, __first, __second>:: \
-  __binary_function_requirement_violation>  \
-  __dummy_ptr_##__func##__ret##__first##__second##_binary_check
-
-
-#define __STL_CLASS_REQUIRES_BINARY_OP(__opname, __ret, __first, __second) \
-  typedef __ret (* __f_##__func##__ret##__first##__second##_binary_op)(const __first&, \
-                                                    const __second& ); \
-  template <__f_##__func##__ret##__first##__second##_binary_op _Tp1> \
-  struct __dummy_struct_##__func##__ret##__first##__second##_binary_op { }; \
-  static __dummy_struct_##__func##__ret##__first##__second##_binary_op< \
-    _STL_BINARY##__opname##_ERROR<__ret, __first, __second>:: \
-  __binary_operator_requirement_violation>  \
-  __dummy_ptr_##__func##__ret##__first##__second##_binary_op
-
-#endif
-
-/* helper class for finding non-const version of a type. Need to have
-   something to assign to etc. when testing constant iterators. */
-
-template <class _Tp>
-struct _Mutable_trait {
-  typedef _Tp _Type;
-};
-template <class _Tp>
-struct _Mutable_trait<const _Tp> {
-  typedef _Tp _Type;
-};
-
-
-/* helper function for avoiding compiler warnings about unused variables */
-template <class _Type>
-void __sink_unused_warning(_Type) { }
-
-template <class _TypeX, class _TypeY>
-struct _STL_CONVERT_ERROR {
-  static void
-  __type_X_is_not_convertible_to_type_Y(_TypeX __x, _TypeY) {
-    _TypeY __y = __x;
-    __sink_unused_warning(__y);
-  }
-};
-
-
-template <class _Type> struct __check_equal { };
-
-template <class _TypeX, class _TypeY>
-struct _STL_SAME_TYPE_ERROR {
-  static void
-  __type_X_not_same_as_type_Y(_TypeX , _TypeY ) { 
-    __check_equal<_TypeX> t1 = __check_equal<_TypeY>();
-  }
-};
-
-
-// Some Functon Object Checks
-
-template <class _Func, class _Ret>
-struct _STL_GENERATOR_ERROR {
-  static _Ret __generator_requirement_violation(_Func& __f) {
-    return __f();
-  }
-};
-
-template <class _Func>
-struct _STL_GENERATOR_ERROR<_Func, void> {
-  static void __generator_requirement_violation(_Func& __f) {
-    __f();
-  }
-};
-
-
-template <class _Func, class _Ret, class _Arg>
-struct _STL_UNARY_FUNCTION_ERROR {
-  static _Ret
-  __unary_function_requirement_violation(_Func& __f,
-                                          const _Arg& __arg) {
-    return __f(__arg);
-  }
-};
-
-template <class _Func, class _Arg>
-struct _STL_UNARY_FUNCTION_ERROR<_Func, void, _Arg> {
-  static void
-  __unary_function_requirement_violation(_Func& __f,
-                                          const _Arg& __arg) {
-    __f(__arg);
-  }
-};
-
-template <class _Func, class _Ret, class _First, class _Second>
-struct _STL_BINARY_FUNCTION_ERROR {
-  static _Ret
-  __binary_function_requirement_violation(_Func& __f,
-                                          const _First& __first, 
-                                          const _Second& __second) {
-    return __f(__first, __second);
-  }
-};
-
-template <class _Func, class _First, class _Second>
-struct _STL_BINARY_FUNCTION_ERROR<_Func, void, _First, _Second> {
-  static void
-  __binary_function_requirement_violation(_Func& __f,
-                                          const _First& __first, 
-                                          const _Second& __second) {
-    __f(__first, __second);
-  }
-};
-
-
-#define __STL_DEFINE_BINARY_OP_CHECK(_OP, _NAME) \
-template <class _Ret, class _First, class _Second> \
-struct _STL_BINARY##_NAME##_ERROR { \
-  static _Ret \
-  __const_binary_operator_requirement_violation(const _First& __first,  \
-                                                const _Second& __second) { \
-    return __first _OP __second; \
-  } \
-  static _Ret \
-  __binary_operator_requirement_violation(_First& __first,  \
-                                          _Second& __second) { \
-    return __first _OP __second; \
-  } \
-}
-
-__STL_DEFINE_BINARY_OP_CHECK(==, _OP_EQUAL);
-__STL_DEFINE_BINARY_OP_CHECK(!=, _OP_NOT_EQUAL);
-__STL_DEFINE_BINARY_OP_CHECK(<, _OP_LESS_THAN);
-__STL_DEFINE_BINARY_OP_CHECK(<=, _OP_LESS_EQUAL);
-__STL_DEFINE_BINARY_OP_CHECK(>, _OP_GREATER_THAN);
-__STL_DEFINE_BINARY_OP_CHECK(>=, _OP_GREATER_EQUAL);
-__STL_DEFINE_BINARY_OP_CHECK(+, _OP_PLUS);
-__STL_DEFINE_BINARY_OP_CHECK(*, _OP_TIMES);
-__STL_DEFINE_BINARY_OP_CHECK(/, _OP_DIVIDE);
-__STL_DEFINE_BINARY_OP_CHECK(-, _OP_SUBTRACT);
-__STL_DEFINE_BINARY_OP_CHECK(%, _OP_MOD);
-// ...
-
-// TODO, add unary operators (prefix and postfix)
-
-/*
-  The presence of this class is just to trick EDG into displaying
-  these error messages before any other errors. Without the
-  classes, the errors in the functions get reported after
-  other class errors deep inside the library. The name
-  choice just makes for an eye catching error message :)
- */
-struct _STL_ERROR {
-
-  template <class _Type>
-  static _Type
-  __default_constructor_requirement_violation(_Type) {
-    return _Type();
-  }
-  template <class _Type>
-  static _Type
-  __assignment_operator_requirement_violation(_Type __a) {
-    __a = __a;
-    return __a;
-  }
-  template <class _Type>
-  static _Type
-  __copy_constructor_requirement_violation(_Type __a) {
-    _Type __c(__a);
-    return __c;
-  }
-  template <class _Type>
-  static _Type
-  __const_parameter_required_for_copy_constructor(_Type /* __a */, 
-                                                  const _Type& __b) {
-    _Type __c(__b);
-    return __c;
-  }
-  template <class _Type>
-  static _Type
-  __const_parameter_required_for_assignment_operator(_Type __a, 
-                                                     const _Type& __b) {
-    __a = __b;
-    return __a;
-  }
-  template <class _Type>
-  static _Type
-  __less_than_comparable_requirement_violation(_Type __a, _Type __b) {
-    if (__a < __b || __a > __b || __a <= __b || __a >= __b) return __a;
-    return __b;
-  }
-  template <class _Type>
-  static _Type
-  __equality_comparable_requirement_violation(_Type __a, _Type __b) {
-    if (__a == __b || __a != __b) return __a;
-    return __b;
-  }
-  template <class _Iterator>
-  static void
-  __dereference_operator_requirement_violation(_Iterator __i) {
-    __sink_unused_warning(*__i);
-  }
-  template <class _Iterator>
-  static void
-  __dereference_operator_and_assignment_requirement_violation(_Iterator __i) {
-    *__i = *__i;
-  }
-  template <class _Iterator>
-  static void
-  __preincrement_operator_requirement_violation(_Iterator __i) {
-    ++__i;
-  }
-  template <class _Iterator>
-  static void
-  __postincrement_operator_requirement_violation(_Iterator __i) {
-    __i++;
-  }
-  template <class _Iterator>
-  static void
-  __predecrement_operator_requirement_violation(_Iterator __i) {
-    --__i;
-  }
-  template <class _Iterator>
-  static void
-  __postdecrement_operator_requirement_violation(_Iterator __i) {
-    __i--;
-  }
-  template <class _Iterator, class _Type>
-  static void
-  __postincrement_operator_and_assignment_requirement_violation(_Iterator __i,
-                                                                _Type __t) {
-    *__i++ = __t;
-  }
-  template <class _Iterator, class _Distance>
-  static _Iterator
-  __iterator_addition_assignment_requirement_violation(_Iterator __i, 
-                                                       _Distance __n) {
-    __i += __n;
-    return __i;
-  }
-  template <class _Iterator, class _Distance>
-  static _Iterator
-  __iterator_addition_requirement_violation(_Iterator __i, _Distance __n) {
-    __i = __i + __n;
-    __i = __n + __i;
-    return __i;
-  }
-  template <class _Iterator, class _Distance>
-  static _Iterator
-  __iterator_subtraction_assignment_requirement_violation(_Iterator __i,
-                                                          _Distance __n) {
-    __i -= __n;
-    return __i;
-  }
-  template <class _Iterator, class _Distance>
-  static _Iterator
-  __iterator_subtraction_requirement_violation(_Iterator __i, _Distance __n) {
-    __i = __i - __n;
-    return __i;
-  }
-  template <class _Iterator, class _Distance>
-  static _Distance
-  __difference_operator_requirement_violation(_Iterator __i, _Iterator __j,
-                                              _Distance __n) {
-    __n = __i - __j;
-    return __n;
-  }
-  template <class _Exp, class _Type, class _Distance>
-  static _Type
-  __element_access_operator_requirement_violation(_Exp __x, _Type*,
-                                                  _Distance __n) {
-    return __x[__n];
-  }
-  template <class _Exp, class _Type, class _Distance>
-  static void
-  __element_assignment_operator_requirement_violation(_Exp __x,
-                                                      _Type* __t,
-                                                      _Distance __n) {
-    __x[__n] = *__t;
-  }
-
-}; /* _STL_ERROR */
-
-/* Associated Type Requirements */
-
-__STL_BEGIN_NAMESPACE
-template <class _Iterator> struct iterator_traits;
-__STL_END_NAMESPACE
-
-template <class _Iter> 
-struct __value_type_type_definition_requirement_violation {
-  typedef typename __STD::iterator_traits<_Iter>::value_type value_type;
-};
-
-template <class _Iter> 
-struct __difference_type_type_definition_requirement_violation {
-  typedef typename __STD::iterator_traits<_Iter>::difference_type
-          difference_type;
-};
-
-template <class _Iter> 
-struct __reference_type_definition_requirement_violation {
-  typedef typename __STD::iterator_traits<_Iter>::reference reference;
-};
-
-template <class _Iter> 
-struct __pointer_type_definition_requirement_violation {
-  typedef typename __STD::iterator_traits<_Iter>::pointer pointer;
-};
-
-template <class _Iter> 
-struct __iterator_category_type_definition_requirement_violation {
-  typedef typename __STD::iterator_traits<_Iter>::iterator_category 
-          iterator_category;
-};
-
-/* Assignable Requirements */
-
-
-template <class _Type>
-struct _Assignable_concept_specification {
-  static void _Assignable_requirement_violation(_Type __a) {
-    _STL_ERROR::__assignment_operator_requirement_violation(__a);
-    _STL_ERROR::__copy_constructor_requirement_violation(__a);
-    _STL_ERROR::__const_parameter_required_for_copy_constructor(__a,__a);
-    _STL_ERROR::__const_parameter_required_for_assignment_operator(__a,__a);
-  }
-};
-
-/* DefaultConstructible Requirements */
-
-
-template <class _Type>
-struct _DefaultConstructible_concept_specification {
-  static void _DefaultConstructible_requirement_violation(_Type __a) {
-    _STL_ERROR::__default_constructor_requirement_violation(__a);
-  }
-};
-
-/* EqualityComparable Requirements */
-
-template <class _Type>
-struct _EqualityComparable_concept_specification {
-  static void _EqualityComparable_requirement_violation(_Type __a) {
-    _STL_ERROR::__equality_comparable_requirement_violation(__a, __a);
-  }
-};
-
-/* LessThanComparable Requirements */
-template <class _Type>
-struct _LessThanComparable_concept_specification {
-  static void _LessThanComparable_requirement_violation(_Type __a) {
-    _STL_ERROR::__less_than_comparable_requirement_violation(__a, __a);
-  }
-};
-
-/* TrivialIterator Requirements */
-
-template <class _TrivialIterator>
-struct _TrivialIterator_concept_specification {
-static void
-_TrivialIterator_requirement_violation(_TrivialIterator __i) {
-  typedef typename
-    __value_type_type_definition_requirement_violation<_TrivialIterator>::
-    value_type __T;
-  // Refinement of Assignable
-  _Assignable_concept_specification<_TrivialIterator>::
-    _Assignable_requirement_violation(__i);
-  // Refinement of DefaultConstructible
-  _DefaultConstructible_concept_specification<_TrivialIterator>::
-    _DefaultConstructible_requirement_violation(__i);
-  // Refinement of EqualityComparable
-  _EqualityComparable_concept_specification<_TrivialIterator>::
-    _EqualityComparable_requirement_violation(__i);
-  // Valid Expressions
-  _STL_ERROR::__dereference_operator_requirement_violation(__i);
-}
-};
-
-template <class _TrivialIterator>
-struct _Mutable_TrivialIterator_concept_specification {
-static void
-_Mutable_TrivialIterator_requirement_violation(_TrivialIterator __i) {
-  _TrivialIterator_concept_specification<_TrivialIterator>::
-    _TrivialIterator_requirement_violation(__i);
-  // Valid Expressions
-  _STL_ERROR::__dereference_operator_and_assignment_requirement_violation(__i);
-}
-};
-
-/* InputIterator Requirements */
-
-template <class _InputIterator>
-struct _InputIterator_concept_specification {
-static void
-_InputIterator_requirement_violation(_InputIterator __i) {
-  // Refinement of TrivialIterator
-  _TrivialIterator_concept_specification<_InputIterator>::
-    _TrivialIterator_requirement_violation(__i);
-  // Associated Types
-  __difference_type_type_definition_requirement_violation<_InputIterator>();
-  __reference_type_definition_requirement_violation<_InputIterator>();
-  __pointer_type_definition_requirement_violation<_InputIterator>();
-  __iterator_category_type_definition_requirement_violation<_InputIterator>();
-  // Valid Expressions
-  _STL_ERROR::__preincrement_operator_requirement_violation(__i);
-  _STL_ERROR::__postincrement_operator_requirement_violation(__i);
-}
-};
-
-/* OutputIterator Requirements */
-
-template <class _OutputIterator>
-struct _OutputIterator_concept_specification {
-static void
-_OutputIterator_requirement_violation(_OutputIterator __i) {
-  // Refinement of Assignable
-  _Assignable_concept_specification<_OutputIterator>::
-    _Assignable_requirement_violation(__i);
-  // Associated Types
-  __iterator_category_type_definition_requirement_violation<_OutputIterator>();
-  // Valid Expressions
-  _STL_ERROR::__dereference_operator_requirement_violation(__i);
-  _STL_ERROR::__preincrement_operator_requirement_violation(__i);
-  _STL_ERROR::__postincrement_operator_requirement_violation(__i);
-  _STL_ERROR::
-    __postincrement_operator_and_assignment_requirement_violation(__i, *__i);
-}
-};
-
-/* ForwardIterator Requirements */
-
-template <class _ForwardIterator>
-struct _ForwardIterator_concept_specification {
-static void
-_ForwardIterator_requirement_violation(_ForwardIterator __i) {
-  // Refinement of InputIterator
-  _InputIterator_concept_specification<_ForwardIterator>::
-    _InputIterator_requirement_violation(__i);
-}
-};
-
-template <class _ForwardIterator>
-struct _Mutable_ForwardIterator_concept_specification {
-static void
-_Mutable_ForwardIterator_requirement_violation(_ForwardIterator __i) {
-  _ForwardIterator_concept_specification<_ForwardIterator>::
-    _ForwardIterator_requirement_violation(__i);
-  // Refinement of OutputIterator
-  _OutputIterator_concept_specification<_ForwardIterator>::
-    _OutputIterator_requirement_violation(__i);
-}
-};
-
-/* BidirectionalIterator Requirements */
-
-template <class _BidirectionalIterator>
-struct _BidirectionalIterator_concept_specification {
-static void
-_BidirectionalIterator_requirement_violation(_BidirectionalIterator __i) {
-  // Refinement of ForwardIterator
-  _ForwardIterator_concept_specification<_BidirectionalIterator>::
-    _ForwardIterator_requirement_violation(__i);
-  // Valid Expressions
-  _STL_ERROR::__predecrement_operator_requirement_violation(__i);
-  _STL_ERROR::__postdecrement_operator_requirement_violation(__i);
-}
-};
-
-template <class _BidirectionalIterator>
-struct _Mutable_BidirectionalIterator_concept_specification {
-static void
-_Mutable_BidirectionalIterator_requirement_violation(
-       _BidirectionalIterator __i)
-{
-  _BidirectionalIterator_concept_specification<_BidirectionalIterator>::
-    _BidirectionalIterator_requirement_violation(__i);
-  // Refinement of mutable_ForwardIterator
-  _Mutable_ForwardIterator_concept_specification<_BidirectionalIterator>::
-    _Mutable_ForwardIterator_requirement_violation(__i);
-  typedef typename
-    __value_type_type_definition_requirement_violation<
-    _BidirectionalIterator>::value_type __T;
-  typename _Mutable_trait<__T>::_Type* __tmp_ptr = 0;
-  // Valid Expressions
-  _STL_ERROR::
-    __postincrement_operator_and_assignment_requirement_violation(__i,
-                                                                  *__tmp_ptr);
-}
-};
-
-/* RandomAccessIterator Requirements */
-
-template <class _RandAccIter>
-struct _RandomAccessIterator_concept_specification {
-static void
-_RandomAccessIterator_requirement_violation(_RandAccIter __i) {
-  // Refinement of BidirectionalIterator
-  _BidirectionalIterator_concept_specification<_RandAccIter>::
-    _BidirectionalIterator_requirement_violation(__i);
-  // Refinement of LessThanComparable
-  _LessThanComparable_concept_specification<_RandAccIter>::
-    _LessThanComparable_requirement_violation(__i);
-  typedef typename 
-        __value_type_type_definition_requirement_violation<_RandAccIter>
-        ::value_type
-    value_type;
-  typedef typename
-        __difference_type_type_definition_requirement_violation<_RandAccIter>
-        ::difference_type 
-    _Dist;
-  typedef typename _Mutable_trait<_Dist>::_Type _MutDist;
-
-  // Valid Expressions
-  _STL_ERROR::__iterator_addition_assignment_requirement_violation(__i,
-                                                                   _MutDist());
-  _STL_ERROR::__iterator_addition_requirement_violation(__i,
-                                                        _MutDist());
-  _STL_ERROR::
-    __iterator_subtraction_assignment_requirement_violation(__i,
-                                                            _MutDist());
-  _STL_ERROR::__iterator_subtraction_requirement_violation(__i,
-                                                           _MutDist());
-  _STL_ERROR::__difference_operator_requirement_violation(__i, __i,
-                                                          _MutDist());
-  typename _Mutable_trait<value_type>::_Type* __dummy_ptr = 0;
-  _STL_ERROR::__element_access_operator_requirement_violation(__i,
-                                                              __dummy_ptr,
-                                                              _MutDist());
-}
-};
-
-template <class _RandAccIter>
-struct _Mutable_RandomAccessIterator_concept_specification {
-static void
-_Mutable_RandomAccessIterator_requirement_violation(_RandAccIter __i)
-{
-  _RandomAccessIterator_concept_specification<_RandAccIter>::
-    _RandomAccessIterator_requirement_violation(__i);
-  // Refinement of mutable_BidirectionalIterator
-  _Mutable_BidirectionalIterator_concept_specification<_RandAccIter>::
-    _Mutable_BidirectionalIterator_requirement_violation(__i);
-  typedef typename
-        __value_type_type_definition_requirement_violation<_RandAccIter>
-        ::value_type
-    value_type;
-  typedef typename
-        __difference_type_type_definition_requirement_violation<_RandAccIter>
-        ::difference_type
-    _Dist;
-
-  typename _Mutable_trait<value_type>::_Type* __tmp_ptr = 0;
-  // Valid Expressions
-  _STL_ERROR::__element_assignment_operator_requirement_violation(__i,
-                  __tmp_ptr, _Dist());
-}
-};
-
-#define __STL_TYPEDEF_REQUIREMENT(__REQUIREMENT) \
-template <class Type> \
-struct __##__REQUIREMENT##__typedef_requirement_violation { \
-  typedef typename Type::__REQUIREMENT __REQUIREMENT; \
-}
-
-__STL_TYPEDEF_REQUIREMENT(value_type);
-__STL_TYPEDEF_REQUIREMENT(difference_type);
-__STL_TYPEDEF_REQUIREMENT(size_type);
-__STL_TYPEDEF_REQUIREMENT(reference);
-__STL_TYPEDEF_REQUIREMENT(const_reference);
-__STL_TYPEDEF_REQUIREMENT(pointer);
-__STL_TYPEDEF_REQUIREMENT(const_pointer);
-
-
-template <class _Alloc>
-struct _Allocator_concept_specification {
-static void
-_Allocator_requirement_violation(_Alloc __a) {
-  // Refinement of DefaultConstructible
-  _DefaultConstructible_concept_specification<_Alloc>::
-    _DefaultConstructible_requirement_violation(__a);
-  // Refinement of EqualityComparable
-  _EqualityComparable_concept_specification<_Alloc>::
-    _EqualityComparable_requirement_violation(__a);
-  // Associated Types
-  __value_type__typedef_requirement_violation<_Alloc>();
-  __difference_type__typedef_requirement_violation<_Alloc>();
-  __size_type__typedef_requirement_violation<_Alloc>();
-  __reference__typedef_requirement_violation<_Alloc>();
-  __const_reference__typedef_requirement_violation<_Alloc>();
-  __pointer__typedef_requirement_violation<_Alloc>();
-  __const_pointer__typedef_requirement_violation<_Alloc>();
-  typedef typename _Alloc::value_type _Tp;
-  //__STL_REQUIRES_SAME_TYPE(typename _Alloc::__STL_TEMPLATE rebind<_Tp>::other,
-  //                         _Alloc);
-}
-};
-
-#endif /* __STL_USE_CONCEPT_CHECKS */
-
-#endif /* __CONCEPT_CHECKS_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/container_concepts.h b/lib/include/stl/container_concepts.h
deleted file mode 100644
index 372807b..0000000
--- a/lib/include/stl/container_concepts.h
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Copyright (c) 1999
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __STL_CONTAINER_CONCEPTS_H
-#define __STL_CONTAINER_CONCEPTS_H
-
-
-#include <concept_checks.h>
-
-#ifdef __STL_USE_CONCEPT_CHECKS
-
-
-// This file covers the following concepts:
-//       _Container
-//       _ForwardContainer
-//       _ReversibleContainer
-//       _const_ReversibleContainer
-//       _RandomAccessContainer
-//
-
-struct _ERROR_IN_STL_CONTAINER {
-
-  /* Container expresssions */
-
-  template <class _Container>
-  static void
-  __begin_iterator_accessor_requirement_violation(_Container __c) {
-    __c.begin();
-  }
-  template <class _Container>
-  static void
-  __const_begin_iterator_accessor_requirement_violation(const _Container& __c) {
-    __c.begin();
-  }
-  template <class _Container>
-  static void
-  __end_iterator_accessor_requirement_violation(_Container __c) {
-    __c.end();
-  }
-  template <class _Container>
-  static void
-  __const_end_iterator_accessor_requirement_violation(const _Container& __c) {
-    __c.end();
-  }
-
-  template <class _Container>
-  static void
-  __rbegin_iterator_accessor_requirement_violation(_Container __c) {
-    __c.rbegin();
-  }
-  template <class _Container>
-  static void
-  __const_rbegin_iterator_accessor_requirement_violation(const _Container& __c) {
-    __c.rbegin();
-  }
-  template <class _Container>
-  static void
-  __rend_iterator_accessor_requirement_violation(_Container __c) {
-    __c.rend();
-  }
-  template <class _Container>
-  static void
-  __const_rend_iterator_accessor_requirement_violation(const _Container& __c) {
-    __c.rend();
-  }
-  template <class _Container>
-  static void
-  __size_function_must_be_const(const _Container& __c) {
-    __c.size();
-  }
-  template <class _Container>
-  static void
-  __size_function_requirement_violation(_Container& __c) {
-    __c.size();
-    __size_function_must_be_const(__c);
-  }
-  template <class _Container>
-  static void
-  __max_size_function_must_be_const(const _Container& __c) {
-    __c.max_size();
-  }
-  template <class _Container>
-  static void
-  __max_size_function_requirement_violation(_Container& __c) {
-    __c.max_size();
-    __max_size_function_must_be_const(__c);
-  }
-  template <class _Container>
-  static void
-  __empty_function_must_be_const(const _Container& __c) {
-    __c.empty();
-  }
-  template <class _Container>
-  static void
-  __empty_function_requirement_violation(_Container& __c) {
-    __c.empty();
-    __empty_function_must_be_const(__c);
-  }
-  template <class _Container>
-  static void
-  __swap_function_requirement_violation(_Container& __c) {
-    __c.swap(__c);
-  }
-
-};
-
-
-__STL_TYPEDEF_REQUIREMENT(iterator);
-__STL_TYPEDEF_REQUIREMENT(const_iterator);
-
-/* Containers */
-
-template <class _Container>
-struct _Container_concept_specification {
-static void
-_Container_requirement_violation(_Container __c) {
-  // Refinement of Assignable
-  _Assignable_concept_specification<_Container>::_Assignable_requirement_violation(__c);
-  // Associated Types
-  __value_type__typedef_requirement_violation<_Container>();
-  __difference_type__typedef_requirement_violation<_Container>();
-  __size_type__typedef_requirement_violation<_Container>();
-  __reference__typedef_requirement_violation<_Container>();
-  __const_reference__typedef_requirement_violation<_Container>();
-  __pointer__typedef_requirement_violation<_Container>();
-  __const_pointer__typedef_requirement_violation<_Container>();
-  __iterator__typedef_requirement_violation<_Container>();
-  __const_iterator__typedef_requirement_violation<_Container>();
-  // Valid Expressions
-  _ERROR_IN_STL_CONTAINER::__const_begin_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__const_end_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__begin_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__end_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__size_function_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__max_size_function_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__empty_function_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__swap_function_requirement_violation(__c);
-  // Requirements on Iterators
-  typedef typename _Container::iterator iter;
-  typedef typename _Container::const_iterator const_iter;
-  _InputIterator_concept_specification<const_iter>::_InputIterator_requirement_violation(const_iter());
-  _InputIterator_concept_specification<iter>::_InputIterator_requirement_violation(iter());
-}
-};
-
-template <class _ForwardContainer>
-struct _ForwardContainer_concept_specification {
-static void
-_ForwardContainer_requirement_violation(_ForwardContainer __c) {
-  // Refinement of Container
-  _Container_concept_specification<_ForwardContainer>::_Container_requirement_violation(__c);
-  // Requirements on Iterators
-  typedef typename _ForwardContainer::iterator iter;
-  typedef typename _ForwardContainer::const_iterator const_iter;
-  _ForwardIterator_concept_specification<const_iter>::_ForwardIterator_requirement_violation(const_iter());
-  _Mutable_ForwardIterator_concept_specification<iter>::_Mutable_ForwardIterator_requirement_violation(iter());
-}
-};
-
-
-__STL_TYPEDEF_REQUIREMENT(reverse_iterator);
-__STL_TYPEDEF_REQUIREMENT(const_reverse_iterator);
-
-template <class _ReversibleContainer>
-struct _ReversibleContainer_concept_specification {
-static void
-_ReversibleContainer_requirement_violation(_ReversibleContainer __c) {
-  // Refinement of ForwardContainer
-  _ForwardContainer_concept_specification<_ReversibleContainer>::_ForwardContainer_requirement_violation(__c);
-  // Associated types
-  __reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();
-  __const_reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();
-  // Valid Expressions
-  _ERROR_IN_STL_CONTAINER::__const_rbegin_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__const_rend_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__rbegin_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__rend_iterator_accessor_requirement_violation(__c);
-  // Requirements on Iterators
-  typedef typename _ReversibleContainer::iterator iter;
-  typedef typename _ReversibleContainer::const_iterator const_iter;
-  _BidirectionalIterator_concept_specification<const_iter>::_BidirectionalIterator_requirement_violation(const_iter());
-  _Mutable_BidirectionalIterator_concept_specification<iter>::_Mutable_BidirectionalIterator_requirement_violation(iter());
-}
-};
-
-template <class _ReversibleContainer>
-struct _const_ReversibleContainer_concept_specification {
-static void
-_const_ReversibleContainer_requirement_violation(_ReversibleContainer __c) {
-  // Refinement of Container (JGS, not ForwardContainer)
-  _Container_concept_specification<_ReversibleContainer>::_Container_requirement_violation(__c);
-  // Associated types
-  __reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();
-  __const_reverse_iterator__typedef_requirement_violation<_ReversibleContainer>();
-  // Valid Expressions
-  _ERROR_IN_STL_CONTAINER::__const_rbegin_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__const_rend_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__rbegin_iterator_accessor_requirement_violation(__c);
-  _ERROR_IN_STL_CONTAINER::__rend_iterator_accessor_requirement_violation(__c);
-  // Requirements on Iterators
-  typedef typename _ReversibleContainer::iterator iter;
-  typedef typename _ReversibleContainer::const_iterator const_iter;
-  
-  // This line won't compile on gcc 2.91 due to a compiler bug
-  // Doesn't seem happy on avr-gcc 4.5.1 either
-
-#if !(__GNUC__ == 2 && __GNUC_MINOR__ == 91) && !defined(STM32PLUS_BUILD)
-  __BidirectionalIterator_concept_specification<const_iter>::_BidirectionalIterator_requirement_violation(const_iter());
-#endif
-}
-};
-
-
-template <class _RandomAccessContainer>
-struct _RandomAccessContainer_concept_specification {
-static void
-_RandomAccessContainer_requirement_violation(_RandomAccessContainer __c) {
-  // Refinement of ReversibleContainer
-  _ReversibleContainer_concept_specification<_RandomAccessContainer>::_ReversibleContainer_requirement_violation(__c);
-  // Valid Expressions
-  typedef typename _RandomAccessContainer::value_type __T;
-  typedef typename _RandomAccessContainer::difference_type _Dist;
-  typedef typename _Mutable_trait<__T>::_Type Type;
-  typedef Type* _TypePtr;
-  typedef typename _Mutable_trait<_Dist>::_Type Dist;
-  _STL_ERROR::__element_access_operator_requirement_violation(__c,
-                    _TypePtr(), 
-                    Dist());
-  // Requirements on Iterators
-  typedef typename _RandomAccessContainer::iterator iter;
-  typedef typename _RandomAccessContainer::const_iterator const_iter;
-  _RandomAccessIterator_concept_specification<const_iter>::_RandomAccessIterator_requirement_violation(const_iter());
-  _Mutable_RandomAccessIterator_concept_specification<iter>::_Mutable_RandomAccessIterator_requirement_violation(iter());
-}
-};
-
-#endif /* if __STL_USE_CONCEPT_CHECKS */
-
-#endif /* __STL_CONTAINER_CONCEPTS_H */
diff --git a/lib/include/stl/cstddef b/lib/include/stl/cstddef
deleted file mode 100644
index d44834b..0000000
--- a/lib/include/stl/cstddef
+++ /dev/null
@@ -1,58 +0,0 @@
-// -*- C++ -*- forwarding header.
-
-// Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
-//
-// This file is part of the GNU ISO C++ Library.  This library is free
-// software; you can redistribute it and/or modify it under the
-// terms of the GNU General Public License as published by the
-// Free Software Foundation; either version 2, or (at your option)
-// any later version.
-
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-
-// You should have received a copy of the GNU General Public License along
-// with this library; see the file COPYING.  If not, write to the Free
-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-// USA.
-
-// As a special exception, you may use this file as part of a free software
-// library without restriction.  Specifically, if other files instantiate
-// templates or use macros or inline functions from this file, or you compile
-// this file and link it with other files to produce an executable, this
-// file does not by itself cause the resulting executable to be covered by
-// the GNU General Public License.  This exception does not however
-// invalidate any other reasons why the executable file might be covered by
-// the GNU General Public License.
-
-//
-// ISO C++ 14882: 18.1  Types
-//
-
-/** @file cstddef
- *  This is a Standard C++ Library file.  You should @c #include this file
- *  in your programs, rather than any of the "*.h" implementation files.
- *
- *  This is the C++ version of the Standard C Library header @c stddef.h,
- *  and its contents are (mostly) the same as that header, but are all
- *  contained in the namespace @c std.
- */
-
-#ifndef _CPP_CSTDDEF
-#define _CPP_CSTDDEF 1
-
-#ifdef __GCC__
-#pragma GCC system_header
-#endif
-
-#include <stddef.h>
-
-namespace std 
-{
-  using ::ptrdiff_t;
-  using ::size_t;
-}
-
-#endif
diff --git a/lib/include/stl/deque b/lib/include/stl/deque
deleted file mode 100644
index b823fa4..0000000
--- a/lib/include/stl/deque
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_DEQUE
-#define __SGI_STL_DEQUE
-
-#include <stl_range_errors.h>
-#include <stl_algobase.h>
-#include <stl_alloc.h>
-#include <stl_construct.h>
-#include <stl_uninitialized.h>
-#include <stl_deque.h>
-
-#endif /* __SGI_STL_DEQUE */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/functional b/lib/include/stl/functional
deleted file mode 100644
index d046dbb..0000000
--- a/lib/include/stl/functional
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef __SGI_STL_FUNCTIONAL
-#define __SGI_STL_FUNCTIONAL
-
-#include <stl_config.h>
-#include <stddef.h>
-#include <stl_function.h>
-
-#endif /* __SGI_STL_FUNCTIONAL */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/hash_map b/lib/include/stl/hash_map
deleted file mode 100644
index f7421e0..0000000
--- a/lib/include/stl/hash_map
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 1996
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef __SGI_STL_HASH_MAP
-#define __SGI_STL_HASH_MAP
-
-#ifndef __SGI_STL_INTERNAL_HASHTABLE_H
-#include <stl_hashtable.h>
-#endif 
-
-#include <stl_hash_map.h>
-
-#endif /* __SGI_STL_HASH_MAP */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/hash_set b/lib/include/stl/hash_set
deleted file mode 100644
index 2244f47..0000000
--- a/lib/include/stl/hash_set
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 1996
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef __SGI_STL_HASH_SET
-#define __SGI_STL_HASH_SET
-
-#ifndef __SGI_STL_INTERNAL_HASHTABLE_H
-#include <stl_hashtable.h>
-#endif 
-
-#include <stl_hash_set.h>
-
-#endif /* __SGI_STL_HASH_SET */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/iomanip b/lib/include/stl/iomanip
deleted file mode 100644
index b76f67a..0000000
--- a/lib/include/stl/iomanip
+++ /dev/null
@@ -1,173 +0,0 @@
-/*	Copyright (C) 2005 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#ifndef STM32PLUS_BUILD
-#include <exception>
-#endif
-
-#include <ios>
-
-#ifndef __STD_IOMANIP
-#define __STD_IOMANIP 1
-
-#pragma GCC visibility push(default)
-
-namespace std{
-
-// These are the helper classes which we are going to be using to
-// hold the required data
-
-class _UCXXEXPORT __resetiosflags{
-public:
-	ios_base::fmtflags m;
-	_UCXXEXPORT __resetiosflags(ios_base::fmtflags mask) : m(mask){ }
-};
-
-class _UCXXEXPORT __setiosflags{
-public:
-	ios_base::fmtflags m;
-	_UCXXEXPORT __setiosflags(ios_base::fmtflags mask) : m(mask){ }
-};
-
-class _UCXXEXPORT __setbase{
-public:
-	int base;
-	_UCXXEXPORT __setbase(int b) : base(b){ }
-};
-
-class _UCXXEXPORT __setfill{
-public:
-	int character;
-	_UCXXEXPORT __setfill(int c): character(c){  }
-};
-
-class _UCXXEXPORT __setprecision{
-public:
-	int digits;
-	_UCXXEXPORT __setprecision(int n): digits(n) {  }
-};
-
-class _UCXXEXPORT __setw{
-public:
-	int width;
-	_UCXXEXPORT __setw(int n): width(n) {  }
-};
-
-
-//Actual manipulator functions
-
-inline __resetiosflags resetiosflags(ios_base::fmtflags mask){
-	return __resetiosflags(mask);
-}
-
-inline __setiosflags setiosflags(ios_base::fmtflags mask){
-	return __setiosflags(mask);
-}
-
-inline __setbase setbase(int b){
-	return __setbase(b);
-}
-
-inline __setfill setfill(int c){
-	return __setfill(c);
-}
-
-inline __setprecision setprecision(int n){
-	return __setprecision(n);
-}
-
-inline __setw setw(int n){
-	return __setw(n);
-}
-
-
-//How to handle interaction with [i|o]stream classes
-
-template<class Ch, class Tr> _UCXXEXPORT basic_ostream<Ch, Tr>&
-	operator<<(basic_ostream<Ch, Tr>& os, const __resetiosflags s)
-{
-	os.setf(ios_base::fmtflags(0),s.m);
-	return os;
-}
-
-template<class Ch, class Tr> _UCXXEXPORT basic_istream<Ch, Tr>&
-	operator>>(basic_istream<Ch, Tr>& is, const __resetiosflags s)
-{
-	is.setf(ios_base::fmtflags(0),s.m);
-	return is;
-}
-
-template<class Ch, class Tr> _UCXXEXPORT basic_ostream<Ch, Tr>&
-	operator<<(basic_ostream<Ch, Tr>& os, const __setiosflags s)
-{
-	os.setf(s.m);
-	return os;
-}
-
-template<class Ch, class Tr> _UCXXEXPORT basic_ostream<Ch, Tr>&
-	operator<<(basic_ostream<Ch, Tr>& os, const __setbase s)
-{
-	ios_base::fmtflags f(0);
-	switch(s.base){
-		case 8:
-			f = ios_base::oct;
-			break;
-		case 10:
-			f = ios_base::dec;
-			break;
-		case 16:
-			f = ios_base::hex;
-			break;
-		default:
-			break;
-
-	}
-	os.setf(f, ios_base::basefield);
-	return os;
-}
-
-template<class Ch, class Tr> _UCXXEXPORT basic_ostream<Ch, Tr>&
-	operator<<(basic_ostream<Ch, Tr>& os, const __setfill s)
-{
-	os.fill(s.character);
-	return os;
-}
-
-template<class Ch, class Tr> _UCXXEXPORT basic_ostream<Ch, Tr>&
-	operator<<(basic_ostream<Ch, Tr>& os, const __setprecision s)
-{
-	os.precision(s.digits);
-	return os;
-}
-
-template<class Ch, class Tr> _UCXXEXPORT basic_ostream<Ch, Tr>&
-	operator<<(basic_ostream<Ch, Tr>& os, const __setw s)
-{
-	os.width(s.width);
-	return os;
-}
-
-
-
-}
-
-#pragma GCC visibility pop
-
-#endif
-
diff --git a/lib/include/stl/ios b/lib/include/stl/ios
deleted file mode 100644
index 5167231..0000000
--- a/lib/include/stl/ios
+++ /dev/null
@@ -1,525 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <basic_definitions>
-#include <cstddef>
-#include <locale>
-#include <iosfwd>
-#include <new>
-
-#ifndef __HEADER_STD_IOS
-#define __HEADER_STD_IOS 1
-
-#pragma GCC visibility push(default)
-
-namespace std{
-	typedef signed long int streamoff;
-
-	template <class stateT> class fpos;
-
-	class _UCXXEXPORT ios_base {
-	public:
-		class failure;
-#ifdef __UCLIBCXX_EXCEPTION_SUPPORT__
-		class failure : public exception {
-		public:
-			explicit failure(const std::string& msg) { }
-			explicit failure() { }
-			virtual const char* what() const throw() {
-				return "std::ios_base failure exception";
-			}
-		};
-#endif
-#ifdef __UCLIBCXX_SUPPORT_CDIR__
-		class _UCXXLOCAL Init{
-		public:
-			_UCXXEXPORT Init();
-			_UCXXEXPORT ~Init();
-		private:
-			static int init_cnt;
-		};
-#endif
-
-	public:
-
-		typedef unsigned short int fmtflags;
-
-		static const fmtflags skipws 		= 0x0001;
-
-		static const fmtflags left		= 0x0002;
-		static const fmtflags right		= 0x0004;
-		static const fmtflags internal		= 0x0008;
-
-		static const fmtflags boolalpha		= 0x0010;
-
-		static const fmtflags dec	 	= 0x0020;
-		static const fmtflags oct 		= 0x0040;
-		static const fmtflags hex 		= 0x0080;
-
-		static const fmtflags scientific	= 0x0100;
-		static const fmtflags fixed 		= 0x0200;
-
-		static const fmtflags showbase 		= 0x0400;
-		static const fmtflags showpoint		= 0x0800;
-		static const fmtflags showpos		= 0x1000;
-		static const fmtflags uppercase		= 0x2000;
-
-		static const fmtflags adjustfield	= left | right | internal;
-		static const fmtflags basefield		= dec | oct | hex;
-		static const fmtflags floatfield	= fixed | scientific;
-
-		static const fmtflags unitbuf		= 0x4000;
-
-		typedef unsigned char iostate;
-		static const iostate goodbit		= 0x00;
-		static const iostate badbit		= 0x01;
-		static const iostate eofbit		= 0x02;
-		static const iostate failbit 		= 0x04;
-
-		typedef unsigned char openmode;
-		static const openmode app		= 0x01;
-		static const openmode ate		= 0x02;
-		static const openmode binary		= 0x04;
-		static const openmode in		= 0x08;
-		static const openmode out		= 0x10;
-		static const openmode trunc		= 0x20;
-
-		typedef unsigned char seekdir;
-		static const seekdir beg		= 0x01;
-		static const seekdir cur		= 0x02;
-		static const seekdir end		= 0x04;
-
-		_UCXXEXPORT fmtflags flags() const{
-			return mformat;
-		}
-
-		_UCXXEXPORT fmtflags flags(fmtflags fmtfl) {
-			fmtflags temp = mformat;
-			mformat = fmtfl;
-			return temp;
-		}
-
-
-		fmtflags setf(fmtflags fmtfl) {
-			return flags(flags() | fmtfl);
-		}
-
-		fmtflags setf(fmtflags fmtfl, fmtflags mask ) {
-			return flags( (flags()& ~mask) | (fmtfl & mask));
-		}
-
-		_UCXXEXPORT void unsetf(fmtflags mask){
-			mformat&= ~mask;
-		}
-
-		_UCXXEXPORT streamsize precision() const{
-			return mprecision;
-		}
-
-		_UCXXEXPORT streamsize precision(streamsize prec) {
-			streamsize temp = mprecision;
-			mprecision = prec;
-			return temp;
-		}
-
-		_UCXXEXPORT streamsize width() const{
-			return mwidth;
-		}
-
-		_UCXXEXPORT streamsize width(streamsize wide) {
-			streamsize temp = mwidth;
-			mwidth = wide;
-			return temp;
-		}
-
-		_UCXXEXPORT locale imbue(const locale& loc) {
-			locale retval = mLocale;
-			mLocale = loc;
-			return retval;
-		}
-
-		_UCXXEXPORT locale getloc() const{
-			return mLocale;
-		}
-
-//		FIXME - These need to be implemented
-//		static int xalloc();
-//		long&  iword(int index);
-//		void*& pword(int index);
-
-		_UCXXEXPORT ~ios_base() { }
-
-		enum event { erase_event, imbue_event, copyfmt_event };
-
-		typedef void (*event_callback)(event, ios_base&, int index);
-//		void register_callback(event_call_back fn, int index);
-
-		//We are going to wrap stdio so we don't need implementation of the following:
-		inline static bool sync_with_stdio(bool = true) { return true; }
-
-	protected:
-		_UCXXEXPORT ios_base() : mLocale(), mformat(dec | skipws ), mstate(goodbit), 
-			mmode(), mdir(), mprecision(6), mwidth(0)
-#ifdef __UCLIBCXX_SUPPORT_CDIR__
-			,mInit()
-#endif
-		{
-
-		}
-		locale mLocale;
-		fmtflags mformat;
-		iostate mstate;
-		openmode mmode;
-		seekdir mdir;
-		streamsize mprecision;
-		streamsize mwidth;
-#ifdef __UCLIBCXX_SUPPORT_CDIR__
-		Init mInit;
-#endif
-	};
-
-
-	//ios_base manipulators
-
-
-	inline ios_base& boolalpha  (ios_base& str){
-		str.setf(ios_base::boolalpha);
-		return str;
-	}
-	inline ios_base& noboolalpha(ios_base& str){
-		str.unsetf(ios_base::boolalpha);
-		return str;
-	}
-	inline ios_base& showbase   (ios_base& str){
-		str.setf(ios_base::showbase);
-		return str;
-	}
-	inline ios_base& noshowbase (ios_base& str){
-		str.unsetf(ios_base::showbase);
-		return str;
-	}
-	inline ios_base& showpoint  (ios_base& str){
-		str.setf(ios_base::showpoint);
-		return str;
-	}
-	inline ios_base& noshowpoint(ios_base& str){
-		str.unsetf(ios_base::showpoint);
-		return str;
-	}
-	inline ios_base& showpos    (ios_base& str){
-		str.setf(ios_base::showpos);
-		return str;
-	}
-	inline ios_base& noshowpos  (ios_base& str){
-		str.unsetf(ios_base::showpos);
-		return str;
-	}
-	inline ios_base& skipws     (ios_base& str){
-		str.setf(ios_base::skipws);
-		return str;
-	}
-	inline ios_base& noskipws   (ios_base& str){
-		str.unsetf(ios_base::skipws);
-		return str;
-	}
-	inline ios_base& uppercase  (ios_base& str){
-		str.setf(ios_base::uppercase);
-		return str;
-	}
-	inline ios_base& nouppercase(ios_base& str){
-		str.unsetf(ios_base::uppercase);
-		return str;
-	}
-
-	inline ios_base& unitbuf    (ios_base& str){
-		str.setf(ios_base::unitbuf);
-		return str;
-	}
-	inline ios_base& nounitbuf  (ios_base& str){
-		str.unsetf(ios_base::unitbuf);
-		return str;
-	}
-	inline ios_base& internal   (ios_base& str){
-		str.setf(ios_base::internal, ios_base::adjustfield);
-		return str;
-	}
-	inline ios_base& left       (ios_base& str){
-		str.setf(ios_base::left, ios_base::adjustfield);
-		return str;
-	}
-	inline ios_base& right      (ios_base& str){
-		str.setf(ios_base::right, ios_base::adjustfield);
-		return str;
-	}
-
-	inline ios_base& dec        (ios_base& str){
-		str.setf(ios_base::dec, ios_base::basefield);
-		return str;
-	}
-	inline ios_base& hex        (ios_base& str){
-		str.setf(ios_base::hex, ios_base::basefield);
-		return str;
-	}
-	inline ios_base& oct        (ios_base& str){
-		str.setf(ios_base::oct, ios_base::basefield);
-		return str;
-	}
-
-	inline ios_base& fixed      (ios_base& str){
-		str.setf(ios_base::fixed, ios_base::floatfield);
-		return str;
-	}
-	inline ios_base& scientific (ios_base& str){
-		str.setf(ios_base::scientific, ios_base::floatfield);
-		return str;
-	}
-
-
-	//basic_ios class definition
-
-
-	template <class charT, class traits > class _UCXXEXPORT basic_ios
-		: public ios_base
-	{
-	public:
-	// Types:
-		typedef charT char_type;
-		typedef typename traits::int_type int_type;
-		typedef typename traits::pos_type pos_type;
-		typedef typename traits::off_type off_type;
-		typedef traits traits_type;
-
-		_UCXXEXPORT operator void*() const{
-			if(fail() ){
-				return 0;
-			}
-			return (void *)(1);	//Must return a non-NULL pointer (though it can be *any* pointer)
-		}
-
-		_UCXXEXPORT bool operator!() const{
-			return fail();
-		}
-		_UCXXEXPORT iostate rdstate() const{
-			return mstate;
-		}
-		_UCXXEXPORT void clear(iostate state = goodbit){
-			if(rdbuf()!=0){
-				mstate = state;
-			}else{
-				mstate = state|ios_base::badbit;
-			}
-		}
-		_UCXXEXPORT void setstate(iostate state) {
-			clear(rdstate()  | state);
-#ifdef __UCLIBCXX_EXCEPTION_SUPPORT__
-			if(rdstate() & throw_mask){
-				throw failure();
-			}
-#endif
-		}
-
-		_UCXXEXPORT bool good() const{
-			return (rdstate() == 0);
-		}
-		_UCXXEXPORT bool eof()  const{
-			if(rdstate() & eofbit){
-				return true;
-			}
-			return false;
-		}
-		_UCXXEXPORT bool fail() const{
-			if( mstate & (failbit | badbit) ){
-				return true;
-			}
-			return false;
-		}
-
-		_UCXXEXPORT bool bad()  const{
-			if(mstate & badbit){
-				return true;
-			}
-			return false;
-		}
-
-		_UCXXEXPORT iostate exceptions() const{
-			return throw_mask;
-		}
-		_UCXXEXPORT void exceptions(iostate except){
-			throw_mask = except;
-		}
-
-		explicit _UCXXEXPORT basic_ios(basic_streambuf<charT,traits>* sb) : fill_char(' '), mtied(0), mstreambuf(0){
-			init(sb);
-		}
-
-		basic_ios() : mtied(0), mstreambuf(0){ }
-
-		virtual _UCXXEXPORT ~basic_ios(){
-		}
-
-		_UCXXEXPORT basic_ostream<charT,traits>* tie() const{
-			return mtied;
-		}
-		_UCXXEXPORT basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr){
-			basic_ostream<charT,traits>* retval= mtied;
-			mtied = tiestr;
-			return retval;			
-		}
-		_UCXXEXPORT basic_streambuf<charT,traits>* rdbuf() const{
-			return mstreambuf;
-		}
-		_UCXXEXPORT basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb){
-			basic_streambuf<charT,traits>* retval = mstreambuf;
-			mstreambuf = sb;
-			return retval;
-		}
-		_UCXXEXPORT basic_ios& copyfmt(const basic_ios& rhs);
-		_UCXXEXPORT char_type fill() const{
-			return fill_char;
-		}
-		_UCXXEXPORT char_type fill(char_type ch){
-			char_type temp = fill_char;
-			fill_char = ch;
-			return temp;
-		}
-
-		_UCXXEXPORT locale imbue(const locale& loc){
-			return ios_base::imbue(loc);
-		}
-		_UCXXEXPORT char narrow(char_type c, char dfault) const;
-		_UCXXEXPORT char_type widen(char c) const;
-
-	protected:
-		char_type fill_char;
-		basic_ostream<charT,traits>* mtied;
-		basic_streambuf<charT,traits>* mstreambuf;
-		iostate throw_mask;
-		_UCXXEXPORT basic_ios(const basic_ios<charT,traits> &){ }
-		_UCXXEXPORT basic_ios<charT,traits> & operator=(const basic_ios<charT,traits> &){ return *this; }
-		_UCXXEXPORT void init(basic_streambuf<charT,traits>* sb){
-			ios_base::mformat = skipws|dec;
-			mstreambuf = sb;
-			mstate = goodbit;
-			throw_mask = goodbit;
-		}
-	};
-
-#ifdef __UCLIBCXX_EXPAND_IOS_CHAR__
-#ifndef __UCLIBCXX_COMPILE_IOS__
-	
-	template <> _UCXXEXPORT void basic_ios<char, char_traits<char> >::clear(iostate state);
-	template <> _UCXXEXPORT void basic_ios<char, char_traits<char> >::setstate(iostate state);
-
-#endif
-#endif
-
-
-	template <class charT, class traits>
-		inline char basic_ios<charT, traits>::narrow(char_type c, char dfault) const
-	{
-		return dfault;
-	}
-
-	template <>
-		inline char basic_ios<char, char_traits<char> >::narrow(char_type c, char) const
-	{
-		return c;
-	}
-
-#ifdef __UCLIBCXX_HAS_WCHAR__
-
-	template <>
-		inline char basic_ios<wchar_t, char_traits<wchar_t> >::narrow(char_type c, char dfault) const
-	{
-		char retval = wctob (c);
-		if(retval == EOF){
-			retval = dfault;
-		}
-		return retval;
-	}
-
-#endif	//__UCLIBCXX_HAS_WCHAR__
-
-	template <class charT, class traits> 
-		inline typename basic_ios<charT, traits>::char_type
-		basic_ios<charT, traits>::widen(char c) const
-	{
-		return c;
-	}
-
-	template <> 
-		inline basic_ios<char, char_traits<char> >::char_type
-		basic_ios<char, char_traits<char> >::widen(char c) const
-	{
-		return c;
-	}
-
-#ifdef __UCLIBCXX_HAS_WCHAR__
-
-	template <> 
-		inline basic_ios<wchar_t, char_traits<wchar_t> >::char_type
-		basic_ios<wchar_t, char_traits<wchar_t> >::widen(char c) const
-	{
-		return btowc(c);
-	}
-
-#endif //__UCLIBCXX_HAS_WCHAR__
-
-
-	template <class stateT> class _UCXXEXPORT fpos{
-	public:
-		_UCXXEXPORT fpos(stateT s){
-			st = s;
-		}
-		_UCXXEXPORT stateT state() const{
-			return st;
-		}
-		_UCXXEXPORT void state(stateT s){
-			st = s;
-		}
-		_UCXXEXPORT bool operator==(const fpos &rhs){
-			return st == rhs.st;
-		}
-		_UCXXEXPORT bool operator!=(const fpos &rhs){
-			return st == rhs.st;
-		}
-		_UCXXEXPORT fpos & operator+(const streamoff & o){
-			st += o;
-			return *this;
-		}
-		_UCXXEXPORT fpos & operator-(const streamoff & o){
-			st -= o;
-			return *this;
-		}
-		_UCXXEXPORT streamoff operator-(const fpos & rhs){
-			return st - rhs.st;
-		}
-
-		
-	private:
-		stateT st;
-	};
-
-
-}
-
-#pragma GCC visibility pop
-
-#endif
-
diff --git a/lib/include/stl/iosfwd b/lib/include/stl/iosfwd
deleted file mode 100644
index 9c1eb27..0000000
--- a/lib/include/stl/iosfwd
+++ /dev/null
@@ -1,88 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <basic_definitions>
-#include <char_traits.h>
-#include <stl_alloc.h>
-
-
-#ifndef __HEADER_STD_IOSFWD
-#define __HEADER_STD_IOSFWD 1
-
-#pragma GCC visibility push(default)
-
-namespace std {
-	class ios_base;
-	template<> class char_traits<char>;
-
-	template <class charT, class traits = char_traits<charT> > class basic_ios;
-
-	template <class charT, class traits = char_traits<charT> > class basic_streambuf;
-	template <class charT, class traits = char_traits<charT> > class basic_istream;
-	template <class charT, class traits = char_traits<charT> > class basic_ostream;
-	template <class charT, class traits = char_traits<charT> > class basic_iostream;
-
-	template <class charT, class traits = char_traits<charT>, 
-		class Allocator = allocator<charT> > class basic_stringbuf;
-
-	template <class charT, class traits = char_traits<charT>, 
-		class Allocator = allocator<charT> > class basic_istringstream;
-
-	template <class charT, class traits = char_traits<charT>,
-		class Allocator = allocator<charT> > class basic_ostringstream;
-
-	template <class charT, class traits = char_traits<charT>,
-		class Allocator = allocator<charT> > class basic_stringstream;
-
-	template <class charT, class traits = char_traits<charT> > class basic_filebuf;
-
-	template <class charT, class traits = char_traits<charT> > class basic_ifstream;
-
-	template <class charT, class traits = char_traits<charT> > class basic_ofstream;
-
-	template <class charT, class traits = char_traits<charT> > class basic_fstream;
-
-	template <class charT, class traits = char_traits<charT> > class basic_istreambuf_iterator;
-
-	template <class charT, class traits = char_traits<charT> > class basic_ostreambuf_iterator;
-
-	typedef basic_ios<char>       ios;
-
-	typedef basic_streambuf<char> streambuf;
-	typedef basic_istream<char>   istream;
-	typedef basic_ostream<char>   ostream;
-	typedef basic_iostream<char>  iostream;
-
-	typedef basic_stringbuf<char>     stringbuf;
-	typedef basic_istringstream<char> istringstream;
-	typedef basic_ostringstream<char> ostringstream;
-	typedef basic_stringstream<char>  stringstream;
-
-	typedef basic_filebuf<char>  filebuf;
-	typedef basic_ifstream<char> ifstream;
-	typedef basic_ofstream<char> ofstream;
-	typedef basic_fstream<char>  fstream;
-	
-	template <class state> class fpos;
-	typedef fpos<char_traits<char>::state_type> streampos;
-}
-
-#pragma GCC visibility pop
-
-#endif
diff --git a/lib/include/stl/iostream b/lib/include/stl/iostream
deleted file mode 100644
index e4765c4..0000000
--- a/lib/include/stl/iostream
+++ /dev/null
@@ -1,105 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <basic_definitions>
-
-#ifndef __HEADER_STD_IOSTREAM
-#define __HEADER_STD_IOSTREAM 1
-
-#include <iosfwd>
-#include <ios>
-#include <istream>
-#include <ostream>
-
-#ifndef STM32PLUS_BUILD
-#include <fstream>
-#include <string_iostream>
-#endif
-
-
-#pragma GCC visibility push(default)
-
-namespace std{
-#ifdef __UCLIBCXX_SUPPORT_CIN__
-	extern istream cin;
-#endif
-#ifdef __UCLIBCXX_SUPPORT_COUT__
-	extern ostream cout;
-#endif
-#ifdef __UCLIBCXX_SUPPORT_CERR__
-	extern ostream cerr;
-#endif
-#ifdef __UCLIBCXX_SUPPORT_CLOG__
-	extern ostream clog;
-#endif
-#ifdef __UCLIBCXX_SUPPORT_WCIN__
-	extern wistream wcin;
-#endif
-#ifdef __UCLIBCXX_SUPPORT_WCOUT__
-	extern wostream wcout;
-#endif
-#ifdef __UCLIBCXX_SUPPORT_WCERR__
-	extern wostream wcerr;
-#endif
-#ifdef __UCLIBCXX_SUPPORT_WCLOG__
-	extern wostream wclog;
-#endif
-
-
-	template <class charT, class traits> class _UCXXEXPORT basic_iostream :
-		public basic_istream<charT,traits>, public basic_ostream<charT,traits> 
-	{
-	public:
-		// constructor/destructor
-		explicit _UCXXEXPORT basic_iostream(basic_streambuf<charT,traits>* sb);
-		virtual _UCXXEXPORT ~basic_iostream();	//Below
-	};
-
-	template <class charT, class traits> _UCXXEXPORT 
-		basic_iostream<charT, traits>:: basic_iostream(basic_streambuf<charT,traits>* sb)
-		: basic_ios<charT, traits>(sb), basic_istream<charT,traits>(sb), basic_ostream<charT,traits>(sb)
-	{
-		return;
-	}
-
-
-	template <class charT, class traits> _UCXXEXPORT basic_iostream<charT, traits>::~basic_iostream(){
-		return;
-	}
-
-
-#ifdef __UCLIBCXX_EXPAND_OSTREAM_CHAR__
-#ifdef __UCLIBCXX_EXPAND_ISTREAM_CHAR__
-#ifndef __UCLIBCXX_COMPILE_IOSTREAM__
-
-	template <> _UCXXEXPORT basic_iostream<char, char_traits<char> >::
-		basic_iostream(basic_streambuf<char, char_traits<char> >* sb);
-	template <> _UCXXEXPORT basic_iostream<char, char_traits<char> >::~basic_iostream();
-
-#endif
-#endif
-#endif
-
-
-
-}
-
-#pragma GCC visibility pop
-
-#endif
diff --git a/lib/include/stl/istream b/lib/include/stl/istream
deleted file mode 100644
index 77ad0c1..0000000
--- a/lib/include/stl/istream
+++ /dev/null
@@ -1,601 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc C++ Library.  This library is free
-	software; you can redistribute it and/or modify it under the
-	terms of the GNU General Public License as published by the
-	Free Software Foundation; either version 2, or (at your option)
-	any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License along
-	with this library; see the file COPYING.  If not, write to the Free
-	Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
-	USA.
-*/
-
-#include <ios>
-#include <cctype>
-#include <streambuf>
-#include <istream_helpers>
-#include <ostream>
-
-#ifndef __STD_HEADER_ISTREAM
-#define __STD_HEADER_ISTREAM 1
-
-#pragma GCC visibility push(default)
-
-namespace std{
-
-	typedef basic_istream<char> istream;
-
-#ifdef __UCLIBCXX_HAS_WCHAR__
-	typedef basic_istream<wchar_t> wistream;
-#endif
-
-	template <class charT, class traits> basic_istream<charT,traits>& ws(basic_istream<charT,traits>& is);
-
-	template <class charT, class traits> class _UCXXEXPORT basic_istream :
-		virtual public basic_ios<charT,traits>
-	{
-	public:
-	
-		typedef charT                     char_type;
-		typedef typename traits::int_type int_type;
-		typedef typename traits::pos_type pos_type;
-		typedef typename traits::off_type off_type;
-		typedef basic_streambuf<charT,traits>  streambuf_type;
-		typedef traits                    traits_type;
-    	
-		explicit basic_istream(basic_streambuf<charT,traits>* sb)
-			: basic_ios<charT, traits>(sb), count_last_ufmt_input(0)
-		{
-			basic_ios<charT, traits>::init(sb);
-		}
-		virtual ~basic_istream() { }
-	
-		class sentry;
-	
-		basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>& (*pf)(basic_istream<charT,traits>&));
-		basic_istream<charT,traits>& operator>>(basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));
-		basic_istream<charT,traits>& operator>>(ios_base& (*pf)(ios_base&));
-		basic_istream<charT,traits>& operator>>(bool& n);
-		basic_istream<charT,traits>& operator>>(short& n);
-		basic_istream<charT,traits>& operator>>(unsigned short& n);
-		basic_istream<charT,traits>& operator>>(int& n);
-		basic_istream<charT,traits>& operator>>(unsigned int& n);
-		basic_istream<charT,traits>& operator>>(long& n);
-		basic_istream<charT,traits>& operator>>(unsigned long& n);
-		basic_istream<charT,traits>& operator>>(void*& p);
-		basic_istream<charT,traits>& operator>>(basic_streambuf<char_type,traits>* sb);
-
-#ifdef __UCLIBCXX_HAS_FLOATS__
-		basic_istream<charT,traits>& operator>>(float& f);
-		basic_istream<charT,traits>& operator>>(double& f);
-		basic_istream<charT,traits>& operator>>(long double& f);
-#endif
-	
-		_UCXXEXPORT streamsize gcount() const{
-			return count_last_ufmt_input;
-		}
-		
-		_UCXXEXPORT int_type get();		//below
-		_UCXXEXPORT basic_istream<charT,traits>& get(char_type& c); 	//Below
-		
-		_UCXXEXPORT basic_istream<charT,traits>& get(char_type* s, streamsize n){
-			return get(s, n, basic_ios<charT,traits>::widen('\n'));
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& get(char_type* s, streamsize n, char_type delim){
-			sentry(*this, true);
-			streamsize i = 0;
-			int_type c;
-			for(i=0;i<n-1;++i){
-				c = basic_ios<charT, traits>::mstreambuf->sgetc();
-				basic_ios<charT, traits>::mstreambuf->sbumpc();
-				if(c == traits::eof() ){
-					if(i==0){
-						basic_ios<charT,traits>::setstate(ios_base::failbit);
-					}else{
-						basic_ios<charT,traits>::setstate(ios_base::eofbit);
-					}
-					break;
-				}
-				if(c == delim){
-					if(i==0){
-						basic_ios<charT,traits>::setstate(ios_base::failbit);
-					}
-					basic_ios<charT, traits>::mstreambuf->sputbackc(c);
-					break;
-				}
-				s[i] = c;
-			}
-			s[i] = traits::eos();
-			count_last_ufmt_input = i;
-			return *this;
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb){
-			return get(sb, basic_ios<charT,traits>::widen('\n'));
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb, char_type delim){
-			sentry(*this, true);
-			streamsize i = 0;
-			int_type c;
-			while(1){		//We will exit internally based upon error conditions
-				c = basic_ios<charT, traits>::mstreambuf->sgetc();
-				if(c == traits::eof()){
-					if(i==0){
-						basic_ios<charT,traits>::setstate(ios_base::failbit);
-					}else{
-						basic_ios<charT,traits>::setstate(ios_base::eofbit);
-					}
-					count_last_ufmt_input = i;
-					return *this;
-				}
-				if(c == delim){
-					if(i==0){
-						basic_ios<charT,traits>::setstate(ios_base::failbit);
-					}
-					count_last_ufmt_input = i;
-					return *this;
-				}
-				if(sb.sputc(c) != c){	//Error doing output
-					count_last_ufmt_input = i;
-					return *this;
-				}
-				++i;
-				basic_ios<charT, traits>::mstreambuf->sbumpc();
-			}		
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& getline(char_type* s, streamsize n){
-			return getline(s, n, basic_ios<charT,traits>::widen('\n'));
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& getline(char_type* s, streamsize n, char_type delim){
-			sentry(*this, true);
-			streamsize i = 0;
-			int_type c;
-			for(i=0;i<n-1;++i){
-				c = basic_ios<charT, traits>::mstreambuf->sgetc();
-				if(c == traits::eof() ){
-					if( basic_ios<charT,traits>::eof() ){
-						basic_ios<charT,traits>::setstate(ios_base::failbit);
-					}else{
-						basic_ios<charT,traits>::setstate(ios_base::eofbit);
-					}
-					count_last_ufmt_input = i;
-					s[i] = traits::eos();
-					return *this;
-				}
-				if(basic_ios<charT, traits>::mstreambuf->sbumpc()==traits::eof() ){
-					basic_ios<charT,traits>::setstate(ios_base::eofbit);
-				}
-				if(c == delim){
-					count_last_ufmt_input = i+1;
-					s[i] = traits::eos();
-					return *this;
-				}
-				s[i] = c;
-			}
-			s[n-1] = traits::eos();
-			return *this;
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& ignore (streamsize n = 1, int_type delim = traits::eof()){
-			sentry(*this, true);
-			streamsize i;
-			int_type c;
-			for(i=0;i<n;++i){
-				c = basic_ios<charT, traits>::mstreambuf->sgetc();
-				if(c == traits::eof()){
-					basic_ios<charT,traits>::setstate(ios_base::eofbit);
-					return *this;
-				}
-				basic_ios<charT, traits>::mstreambuf->sbumpc();
-				if(c == delim){
-					return *this;
-				}
-			}
-			return *this;
-		}
-		
-		_UCXXEXPORT int_type peek(){
-			if(basic_ios<charT,traits>::good() == false){
-				return traits::eof();
-			}else{
-				int_type c = basic_ios<charT, traits>::mstreambuf->sgetc();
-				if(c == traits::eof()){
-					basic_ios<charT,traits>::setstate(ios_base::eofbit);
-				}
-				return basic_ios<charT, traits>::mstreambuf->sgetc();
-			}
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& read (char_type* s, streamsize n){
-			sentry(*this, true);
-			streamsize i;
-			int_type c;
-			for(i=0;i<n;++i){
-				c = basic_ios<charT, traits>::mstreambuf->sgetc();
-
-				if(c == traits::eof()){
-					basic_ios<charT,traits>::setstate(ios_base::failbit);
-					basic_ios<charT,traits>::setstate(ios_base::eofbit);
-					count_last_ufmt_input = i;
-					return *this;
-				}
-				basic_ios<charT, traits>::mstreambuf->sbumpc();
-				s[i] = c;
-			}
-			count_last_ufmt_input = n;
-			return *this;
-		}
-		
-		_UCXXEXPORT streamsize readsome(char_type* s, streamsize n){
-			sentry(*this, true);
-			if(!basic_ios<charT,traits>::good()){
-				count_last_ufmt_input = 0;
-				basic_ios<charT,traits>::setstate(ios_base::failbit);
-				return 0;
-			}
-			
-			if( basic_ios<charT, traits>::mstreambuf->in_avail()  ==  -1){
-				count_last_ufmt_input=0;
-				basic_ios<charT,traits>::setstate(ios_base::eofbit);
-				return 0;
-			}
-			
-			if(n > basic_ios<charT, traits>::mstreambuf->in_avail() ){
-				n = basic_ios<charT, traits>::mstreambuf->in_avail();
-			}
-			
-			streamsize i;
-			int_type c;
-			
-			for(i=0;i<n;++i){
-				c = basic_ios<charT, traits>::mstreambuf->sgetc();
-				basic_ios<charT, traits>::mstreambuf->sbumpc();
-				s[i] = c;
-			}
-			count_last_ufmt_input = n;
-			return n;
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& putback(char_type c){
-			sentry(*this, true);
-			if(!basic_ios<charT,traits>::good()){
-				basic_ios<charT,traits>::setstate(ios_base::failbit);
-				return *this;
-			}
-			if(basic_ios<charT, traits>::mstreambuf == 0){
-				basic_ios<charT,traits>::setstate(ios_base::badbit);
-				return *this;
-			}
-			if(basic_ios<charT, traits>::mstreambuf->sputbackc(c) == traits::eof()){
-				basic_ios<charT,traits>::setstate(ios_base::badbit);
-				return *this;
-			}
-			return *this;
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& unget(){
-			sentry(*this, true);
-			if(!basic_ios<charT,traits>::good()){
-				basic_ios<charT,traits>::setstate(ios_base::failbit);
-				return *this;
-			}
-			if(basic_ios<charT, traits>::mstreambuf == 0){
-				basic_ios<charT,traits>::setstate(ios_base::failbit);
-				return *this;
-			}
-			if(basic_ios<charT, traits>::mstreambuf->sungetc() == traits::eof()){
-				basic_ios<charT,traits>::setstate(ios_base::failbit);
-			}
-			return *this;
-		}
-		
-		_UCXXEXPORT int sync(){
-			sentry(*this, true);
-			if(basic_ios<charT, traits>::mstreambuf == 0){
-				return -1;
-			}
-			if(basic_ios<charT, traits>::mstreambuf->pubsync() == -1){
-				basic_ios<charT,traits>::setstate(ios_base::badbit);
-				return traits::eof();
-			}
-			return 0;
-		}
-	
-		_UCXXEXPORT pos_type tellg(){
-			if(basic_ios<charT,traits>::fail() !=false){
-				return pos_type(-1);
-			}
-			return basic_ios<charT, traits>::mstreambuf->pubseekoff(0, ios_base::cur, ios_base::in);
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& seekg(pos_type pos){
-			 if(basic_ios<charT,traits>::fail() !=true){
-			 	basic_ios<charT, traits>::mstreambuf->pubseekpos(pos);
-			 }
-			return *this;		
-		}
-		
-		_UCXXEXPORT basic_istream<charT,traits>& seekg(off_type off, ios_base::seekdir dir){
-			if(basic_ios<charT,traits>::fail() !=true){
-				basic_ios<charT, traits>::mstreambuf->pubseekoff(off, dir);
-			}
-			return *this;
-		}
-		
-	protected:
-		_UCXXEXPORT basic_istream(const basic_istream<charT,traits> &): basic_ios<charT, traits>() { }
-		_UCXXEXPORT basic_istream<charT,traits> & operator=(const basic_istream<charT,traits> &){ return *this; }
-		streamsize count_last_ufmt_input;
-
-	};
-	
-	template <class charT,class traits> class _UCXXEXPORT basic_istream<charT,traits>::sentry {
-		bool ok;
-	public:
-		explicit _UCXXEXPORT sentry(basic_istream<charT,traits>& os, bool noskipws = false){
-			if(os.good() !=0){		//Prepare for output
-			}
-
-			//Flush any tied buffer
-			if(os.tie() != 0){
-				os.tie()->flush();
-			}
-			if(!noskipws){
-				__skipws(os);
-			}
-
-			ok = true;
-		}
-		_UCXXEXPORT ~sentry() { }
-		_UCXXEXPORT operator bool() {
-			return ok;
-		}
-	};
-	
-	//Template implementations of basic_istream functions which may be partially specialized
-	//For code reduction
-
-	template <class charT, class traits>
-	_UCXXEXPORT typename basic_istream<charT,traits>::int_type basic_istream<charT,traits>::get(){
-		sentry(*this, true);
-		int_type retval = basic_ios<charT, traits>::mstreambuf->sgetc();
-		if(retval == traits::eof()){
-			count_last_ufmt_input = 0;
-			basic_ios<charT,traits>::setstate(ios_base::eofbit);
-		}else{
-			count_last_ufmt_input = 1;
-			basic_ios<charT, traits>::mstreambuf->sbumpc();
-		}
-		return retval;
-	}
-
-	template <class charT, class traits>
-	_UCXXEXPORT basic_istream<charT,traits>& basic_istream<charT,traits>::get(char_type& c){
-		sentry(*this, true);
-		int_type retval = basic_ios<charT, traits>::mstreambuf->sgetc();
-		if(retval == traits::eof()){
-			count_last_ufmt_input = 0;
-			basic_ios<charT,traits>::setstate(ios_base::eofbit);
-			basic_ios<charT,traits>::setstate(ios_base::failbit);
-		}else{
-			count_last_ufmt_input = 1;
-			c = traits::to_char_type(retval);
-			basic_ios<charT, traits>::mstreambuf->sbumpc();
-		}
-		return *this;
-	}
-		
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(bool& n)
-	{
-		sentry(*this);
-		__istream_readin<traits, charT, bool>::readin(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(short& n)
-	{
-		sentry(*this);
-		__istream_readin<traits, charT, short>::readin(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(unsigned short& n)
-	{
-		sentry(*this);
-		__istream_readin<traits, charT, unsigned short>::readin(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& basic_istream<charT,traits>::operator>>(int& n){
-		sentry(*this);
-		__istream_readin<traits, charT, int>::readin(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& basic_istream<charT,traits>::operator>>(unsigned int& n){
-		sentry(*this);
-		__istream_readin<traits, charT, unsigned int>::readin(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& basic_istream<charT,traits>::operator>>(long int& n){
-		sentry(*this);
-		__istream_readin<traits, charT, long int>::readin(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(unsigned long int& n)
-	{
-		sentry(*this);
-		__istream_readin<traits, charT, unsigned long int>::readin(*this, n);
-		return *this;
-	}
-
-#ifdef __UCLIBCXX_HAS_FLOATS__
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(float& n)
-	{
-		sentry(*this);
-		__istream_readin<traits, charT, float>::readin(*this, n);
-		return *this;
-	}
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(double& n)
-	{
-		sentry(*this);
-		__istream_readin<traits, charT, double>::readin(*this, n);
-		return *this;
-	}
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(long double& n)
-	{
-		sentry(*this);
-		__istream_readin<traits, charT, long double>::readin(*this, n);
-		return *this;
-	}
-#endif
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(void *& n)
-	{
-		sentry(*this);
-		__istream_readin<traits, charT, void*>::readin(*this, n);
-		return *this;
-	}
-
-	template<class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>&
-		operator>>(basic_istream<charT,traits>& is, charT& c)
-	{
-		typename basic_istream<charT,traits>::sentry s(is);
-		is.get(c);
-		return is;
-	}
-
-	template<class traits> _UCXXEXPORT basic_istream<char,traits>&
-		operator>>(basic_istream<char,traits>& is, unsigned char& c)
-	{
-		typename basic_istream<char,traits>::sentry s(is);
-		char b;
-		is.get(b);
-		c = b;
-		return is;
-	}
-	template<class traits> _UCXXEXPORT basic_istream<char,traits>&
-		operator>>(basic_istream<char,traits>& is, signed char& c)
-	{
-		typename basic_istream<char,traits>::sentry s(is);
-		is.get(c);
-		return is;
-	}
-
-	template<class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>&
-		operator>>(basic_istream<charT,traits>& is, charT* c)
-	{
-		typename basic_istream<charT,traits>::sentry s(is);
-		int n = is.width();
-		if(n == 0){
-			n = __STRING_MAX_UNITS;
-		}
-		is.get(c, n);
-		return is;
-
-	}
-	template<class traits> _UCXXEXPORT basic_istream<char,traits>&
-		operator>>(basic_istream<char,traits>& is, unsigned char* c)
-	{
-		typename basic_istream<char,traits>::sentry s(is);
-		int n = is.width();
-		if(n == 0){
-			n = __STRING_MAX_UNITS;
-		}
-		is.get(c, n);
-		return is;
-	}
-	template<class traits> _UCXXEXPORT basic_istream<char,traits>&
-		operator>>(basic_istream<char,traits>& is, signed char* c)
-	{
-		typename basic_istream<char,traits>::sentry s(is);
-		int n = is.width();
-		if(n == 0){
-			n = __STRING_MAX_UNITS;
-		}
-		is.get(c, n);
-		return is;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(basic_istream<charT,traits>& (*pf)(basic_istream<charT,traits>&))
-	{
-		sentry(*this);
-		pf(*this);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>& 
-		basic_istream<charT,traits>::operator>>(basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&))
-	{
-		sentry(*this);
-		pf(*this);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_istream<charT,traits>&
-		ws(basic_istream<charT,traits>& is)
-	{
-		__skipws(is);
-		return is;
-	}
-
-
-#ifdef __UCLIBCXX_EXPAND_ISTREAM_CHAR__
-#ifndef __UCLIBCXX_COMPILE_ISTREAM__
-
-
-	template <> _UCXXEXPORT istream & basic_istream<char, char_traits<char> >::get(char & c);
-	template <> _UCXXEXPORT istream::int_type basic_istream<char, char_traits<char> >::get();
-
-	template <> _UCXXEXPORT istream & istream::operator>>(bool &n);
-	template <> _UCXXEXPORT istream & istream::operator>>(short &n);
-	template <> _UCXXEXPORT istream & istream::operator>>(unsigned short &n);
-	template <> _UCXXEXPORT istream & istream::operator>>(int &n);
-	template <> _UCXXEXPORT istream & istream::operator>>(unsigned int &n);
-	template <> _UCXXEXPORT istream & istream::operator>>(long unsigned &n);
-	template <> _UCXXEXPORT istream & istream::operator>>(long int &n);
-	template <> _UCXXEXPORT istream & istream::operator>>(void *& p);
-
-#ifdef __UCLIBCXX_HAS_FLOATS__
-	template <> _UCXXEXPORT istream & istream::operator>>(float &f);
-	template <> _UCXXEXPORT istream & istream::operator>>(double &f);
-	template <> _UCXXEXPORT istream & istream::operator>>(long double &f);
-#endif
-
-	template <> _UCXXEXPORT istream & operator>>(istream & is, char & c);
-
-	template <> _UCXXEXPORT void __skipws(basic_istream<char,char_traits<char> >& is);
-
-#endif
-#endif
-	
-
-
-}
-
-#pragma GCC visibility pop
-
-#endif
-
diff --git a/lib/include/stl/istream_helpers b/lib/include/stl/istream_helpers
deleted file mode 100644
index a92dc0a..0000000
--- a/lib/include/stl/istream_helpers
+++ /dev/null
@@ -1,344 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <ios>
-#include <cctype>
-
-#include <string>
-
-#ifndef __STD_HEADER_ISTREAM_HELPERS
-#define __STD_HEADER_ISTREAM_HELPERS 1
-
-#pragma GCC visibility push(default)
-
-namespace std{
-
-
-	/* We are making the following template class for serveral reasons.  Firstly,
-	 * we want to keep the main istream code neat and tidy.  Secondly, we want it
-	 * to be easy to do partial specialization of the istream code so that it can
-	 * be expanded and put into the library.  This will allow us to make application
-	 * code smaller at the expense of increased library size.  This is a fair
-	 * trade-off when there are multiple applications being compiled.  Also, this
-	 * feature will be used optionally via configuration options.  It will also
-	 * allow us to keep the code bases in sync, dramatically simplifying the
-	 * maintenance required.  We specialized for char because wchar and others
-	 * require different scanf functions
-	 */
-
-	template <class C, class traits> _UCXXEXPORT 
-		basic_string<C, traits> _readToken(basic_istream<C, traits>& stream)
-	{
-		basic_string<C, traits> temp;
-		typename traits::int_type c;
-		while(true){
-			c = stream.rdbuf()->sgetc();
-			if(c != traits::eof() && isspace(c) == false){
-				stream.rdbuf()->sbumpc();
-				temp.append(1, traits::to_char_type(c));
-			}else{
-				break;
-			}
-		}
-		if (temp.size() == 0)
-			stream.setstate(ios_base::eofbit|ios_base::failbit);
-
-		return temp;
-	}
-
-	template <class C, class traits> _UCXXEXPORT 
-		basic_string<C, traits> _readTokenDecimal(basic_istream<C, traits>& stream)
-	{
-		basic_string<C, traits> temp;
-		typename traits::int_type c;
-		while(true){
-			c = stream.rdbuf()->sgetc();
-			if(c != traits::eof() && isspace(c) == false && (isdigit(c) || c == '.' || c == ',' )){
-				stream.rdbuf()->sbumpc();
-				temp.append(1, traits::to_char_type(c));
-			}else{
-				break;
-			}
-		}
-		if (temp.size() == 0)
-			stream.setstate(ios_base::eofbit|ios_base::failbit);
-
-		return temp;
-	}
-
-#ifdef __UCLIBCXX_EXPAND_ISTREAM_CHAR__
-
-	template <> _UCXXEXPORT string _readToken<char, char_traits<char> >(istream & stream);
-
-#endif
-
-
-	template <class traits, class charT, class dataType> class _UCXXEXPORT __istream_readin{
-	public:
-		static void readin(basic_istream<charT,traits>& stream, dataType & var);
-	};
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, bool>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, bool & var)
-		{
-			basic_string<char, traits > temp;
-			temp = _readToken( stream);
-			if(temp == "true" || temp == "True" || temp == "TRUE" || temp == "1"){
-				var = true;
-			}else{
-				var = false;
-			}
-		}
-	};
-
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, short>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, short & var)
-		{
-			basic_string<char, traits > temp;
-
-			if(stream.flags() & ios_base::dec){
-				temp = _readTokenDecimal( stream);
-				sscanf(temp.c_str(), "%hd", &var );
-			}else{
-				temp = _readToken( stream);
-				if( stream.flags() & ios_base::oct){
-					sscanf(temp.c_str(), "%ho", (unsigned short int *)(&var) );
-				}else if(stream.flags() & ios_base::hex){
-					if(stream.flags() & ios_base::uppercase){
-						sscanf(temp.c_str(), "%hX", (unsigned short int *)(&var) );
-					}else{
-						sscanf(temp.c_str(), "%hx", (unsigned short int *)(&var) );
-					}
-				}else{
-					sscanf(temp.c_str(), "%hi", &var);
-		
-				}
-			}
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, unsigned short>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, unsigned short & var)
-		{
-			basic_string<char, traits > temp;
-
-			if(stream.flags() & ios_base::dec){
-				temp = _readTokenDecimal( stream);
-				sscanf(temp.c_str(), "%hu", &var );
-			}else{
-				temp = _readToken( stream);
-				if( stream.flags() & ios_base::oct){
-					sscanf(temp.c_str(), "%ho", &var);
-				}else if(stream.flags() & ios_base::hex){
-					if(stream.flags() & ios_base::uppercase){
-						sscanf(temp.c_str(), "%hX", &var );
-					}else{
-						sscanf(temp.c_str(), "%hx", &var);
-					}
-				}else{
-					sscanf(temp.c_str(), "%hi", (signed short int*)(&var) );
-				}
-			}
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, int>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, int & var)
-		{
-			basic_string<char, traits > temp;
-
-			if(stream.flags() & ios_base::dec){
-				temp = _readTokenDecimal( stream);
-				sscanf(temp.c_str(), "%d", &var );
-			}else{
-				temp = _readToken( stream);
-				if( stream.flags() & ios_base::oct){
-					sscanf(temp.c_str(), "%o", (unsigned int *)(&var) );
-				}else if(stream.flags() & ios_base::hex){
-					if(stream.flags() & ios_base::uppercase){
-						sscanf(temp.c_str(), "%X", (unsigned int *)(&var) );
-					}else{
-						sscanf(temp.c_str(), "%x", (unsigned int *)(&var) );
-					}
-				}else{
-					sscanf(temp.c_str(), "%i", &var);
-				}
-			}
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, unsigned int>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, unsigned int & var)
-		{
-			basic_string<char, traits > temp;
-
-			if(stream.flags() & ios_base::dec){
-				temp = _readTokenDecimal( stream);
-				sscanf(temp.c_str(), "%u", &var );
-			}else{
-				temp = _readToken( stream);
-				if( stream.flags() & ios_base::oct){
-					sscanf(temp.c_str(), "%o", (unsigned int *)(&var) );
-				}else if(stream.flags() & ios_base::hex){
-					if(stream.flags() & ios_base::uppercase){
-						sscanf(temp.c_str(), "%X", (unsigned int *)(&var) );
-					}else{
-						sscanf(temp.c_str(), "%x", (unsigned int *)(&var) );
-					}
-				}else{
-					sscanf(temp.c_str(), "%i", (int *)(&var) );
-				}
-			}	
-
-		}
-	};
-
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, long int>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, long int & var)
-		{
-			basic_string<char, traits > temp;
-
-			if(stream.flags() & ios_base::dec){
-				temp = _readTokenDecimal( stream);
-				sscanf(temp.c_str(), "%ld", &var );
-			}else{
-				temp = _readToken( stream);
-				if( stream.flags() & ios_base::oct){
-					sscanf(temp.c_str(), "%lo", (unsigned long int *)(&var) );
-				}else if(stream.flags() & ios_base::hex){
-					if(stream.flags() & ios_base::uppercase){
-						sscanf(temp.c_str(), "%lX", (unsigned long int *)(&var) );
-					}else{
-						sscanf(temp.c_str(), "%lx", (unsigned long int *)(&var) );
-					}
-				}else{
-					sscanf(temp.c_str(), "%li", (long int *)(&var) );
-				}
-			}
-
-		}
-	};
-
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, unsigned long int>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, unsigned long int & var)
-		{
-			basic_string<char, traits > temp;
-
-			if(stream.flags() & ios_base::dec){
-				temp = _readTokenDecimal( stream);
-				sscanf(temp.c_str(), "%lu", &var );
-			}else{
-				temp = _readToken( stream);
-				if( stream.flags() & ios_base::oct){
-					sscanf(temp.c_str(), "%lo", &var );
-				}else if(stream.flags() & ios_base::hex){
-					if(stream.flags() & ios_base::uppercase){
-						sscanf(temp.c_str(), "%lX", &var );
-					}else{
-						sscanf(temp.c_str(), "%lx", &var);
-					}
-				}else{
-					sscanf(temp.c_str(), "%li", (long int *)(&var) );
-				}
-			}
-		}
-	};
-
-
-#ifdef __UCLIBCXX_HAS_FLOATS__
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, float>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, float & var)
-		{
-			basic_string<char, traits > temp;
-			temp = _readTokenDecimal( stream);
-
-			sscanf(temp.c_str(), "%g", &var);
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, double>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, double & var)
-		{
-			basic_string<char, traits > temp;
-			temp = _readTokenDecimal( stream);
-			sscanf(temp.c_str(), "%lg", &var);
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, long double>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, long double & var)
-		{
-			basic_string<char, traits > temp;
-			temp = _readTokenDecimal( stream);
-			sscanf(temp.c_str(), "%Lg", &var);
-		}
-	};
-
-#endif	// ifdef __UCLIBCXX_HAS_FLOATS__
-
-	template <class traits> class _UCXXEXPORT __istream_readin<traits, char, void*>{
-	public:
-		inline static void readin(basic_istream<char, traits >& stream, void* & var)
-		{
-			basic_string<char, traits > temp;
-			temp = _readToken( stream);
-			sscanf(temp.c_str(), "%p", &var);
-		}
-	};
-
-
-	template<class charT, class traits> void __skipws(basic_istream<charT,traits>& is){
-		const typename basic_istream<charT,traits>::int_type eof = traits::eof();
-		typename basic_istream<charT,traits>::int_type c;
-		//While the next character normally read doesn't equal eof
-		//and that character is a space, advance to the next read position
-		//Thus itterating through all whitespace until we get to the meaty stuff
-		while (
-			!traits::eq_int_type((c = is.rdbuf()->sgetc()),	eof)
-			&& isspace(c)
-                      )
-		{
-			is.rdbuf()->sbumpc();
-		}
-		if(traits::eq_int_type(c, eof)){
-			is.setstate(ios_base::eofbit);
-		}
-	}
-}
-
-#pragma GCC visibility pop
-
-#endif
-
-
-
diff --git a/lib/include/stl/iterator b/lib/include/stl/iterator
deleted file mode 100644
index fe2b8e8..0000000
--- a/lib/include/stl/iterator
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_ITERATOR
-#define __SGI_STL_ITERATOR
-
-#include <stl_config.h>
-#include <stl_relops.h>
-#include <stddef.h>       
-
-#ifdef __STL_USE_NEW_IOSTREAMS 
-#include <iosfwd>
-#else /* __STL_USE_NEW_IOSTREAMS */
-#include <iostream.h>
-#endif /* __STL_USE_NEW_IOSTREAMS */
-
-#include <stl_iterator_base.h>
-#include <stl_iterator.h>
-
-#endif /* __SGI_STL_ITERATOR */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/limits b/lib/include/stl/limits
deleted file mode 100644
index f1a9a09..0000000
--- a/lib/include/stl/limits
+++ /dev/null
@@ -1,537 +0,0 @@
-/*
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is not portable code.  Parts of numeric_limits<> are
- * inherently machine-dependent.  At present this file is suitable
- * for the MIPS and ia32 architectures.
- */
-
-#ifndef __SGI_CPP_LIMITS
-#define __SGI_CPP_LIMITS
-
-#include <limits.h>
-#include <float.h>
-#include <stl_config.h>
-
-__STL_BEGIN_NAMESPACE
-
-enum float_round_style {
-  round_indeterminate       = -1,
-  round_toward_zero         =  0,
-  round_to_nearest          =  1,
-  round_toward_infinity     =  2,
-  round_toward_neg_infinity =  3
-};
-
-enum float_denorm_style {
-  denorm_indeterminate = -1,
-  denorm_absent        =  0,
-  denorm_present       =  1
-};
-
-// The C++ standard (section 18.2.1) requires that some of the members of
-// numeric_limits be static const data members that are given constant-
-// initializers within the class declaration.  On compilers where the
-// __STL_STATIC_CONST_INIT_BUG macro is defined, it is impossible to write
-// a standard-conforming numeric_limits class.
-//
-// There are two possible workarounds: either initialize the data
-// members outside the class, or change them from data members to
-// enums.  Neither workaround is satisfactory: the former makes it
-// impossible to use the data members in constant-expressions, and the
-// latter means they have the wrong type and that it is impossible to
-// take their addresses.  We choose the former workaround.
-
-#ifdef __STL_STATIC_CONST_INIT_BUG
-# define __STL_DECLARE_LIMITS_MEMBER(__mem_type, __mem_name, __mem_value) \
-  enum { __mem_name = __mem_value }
-#else /* __STL_STATIC_CONST_INIT_BUG */
-# define __STL_DECLARE_LIMITS_MEMBER(__mem_type, __mem_name, __mem_value) \
-  static const __mem_type __mem_name = __mem_value
-#endif /* __STL_STATIC_CONST_INIT_BUG */
-
-// Base class for all specializations of numeric_limits.
-
-template <class __number>
-class _Numeric_limits_base {
-public:
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_specialized, false);
-
-  static __number min() __STL_NOTHROW { return __number(); }
-  static __number max() __STL_NOTHROW { return __number(); }
-
-  __STL_DECLARE_LIMITS_MEMBER(int, digits,   0);
-  __STL_DECLARE_LIMITS_MEMBER(int, digits10, 0);
-
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_signed,  false);
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_integer, false);
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_exact,   false);
-
-  __STL_DECLARE_LIMITS_MEMBER(int, radix, 0);
-
-  static __number epsilon() __STL_NOTHROW     { return __number(); }
-  static __number round_error() __STL_NOTHROW { return __number(); }
-
-  __STL_DECLARE_LIMITS_MEMBER(int, min_exponent,   0);
-  __STL_DECLARE_LIMITS_MEMBER(int, min_exponent10, 0);
-  __STL_DECLARE_LIMITS_MEMBER(int, max_exponent,   0);
-  __STL_DECLARE_LIMITS_MEMBER(int, max_exponent10, 0);
-
-  __STL_DECLARE_LIMITS_MEMBER(bool, has_infinity,      false);
-  __STL_DECLARE_LIMITS_MEMBER(bool, has_quiet_NaN,     false);
-  __STL_DECLARE_LIMITS_MEMBER(bool, has_signaling_NaN, false);
-  __STL_DECLARE_LIMITS_MEMBER(float_denorm_style,
-                              has_denorm,
-                              denorm_absent);
-  __STL_DECLARE_LIMITS_MEMBER(bool, has_denorm_loss,   false);
-
-  static __number infinity() __STL_NOTHROW      { return __number(); }
-  static __number quiet_NaN() __STL_NOTHROW     { return __number(); }
-  static __number signaling_NaN() __STL_NOTHROW { return __number(); }
-  static __number denorm_min() __STL_NOTHROW    { return __number(); }
-
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_iec559,  false);
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_bounded, false);
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_modulo,  false);
-
-  __STL_DECLARE_LIMITS_MEMBER(bool, traps,            false);
-  __STL_DECLARE_LIMITS_MEMBER(bool, tinyness_before,  false);
-  __STL_DECLARE_LIMITS_MEMBER(float_round_style,
-                              round_style,
-                              round_toward_zero);
-};
-
-#ifdef __STL_STATIC_CONST_INIT_BUG
-# define __STL_DEFINE_NUMERIC_BASE_MEMBER(__type, __mem)
-#else /* __STL_STATIC_CONST_INIT_BUG */
-# define __STL_DEFINE_NUMERIC_BASE_MEMBER(__type, __mem) \
-  template <class __number>                              \
-  const __type _Numeric_limits_base<__number>:: __mem
-#endif /* __STL_STATIC_CONST_INIT_BUG */
-
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, is_specialized);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(int, digits);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(int, digits10);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, is_signed);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, is_integer);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, is_exact);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(int, radix);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(int, min_exponent);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(int, max_exponent);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(int, min_exponent10);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(int, max_exponent10);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, has_infinity);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, has_quiet_NaN);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, has_signaling_NaN);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(float_denorm_style, has_denorm);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, has_denorm_loss);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, is_iec559);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, is_bounded);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, is_modulo);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, traps);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(bool, tinyness_before);
-__STL_DEFINE_NUMERIC_BASE_MEMBER(float_round_style, round_style);
-
-
-// Base class for integers.
-
-template <class _Int,
-          _Int __imin, _Int __imax,
-          int __idigits = -1, bool __ismod = true>
-class _Integer_limits : public _Numeric_limits_base<_Int> 
-{
-public:
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_specialized, true);
-
-  static _Int min() __STL_NOTHROW { return __imin; }
-  static _Int max() __STL_NOTHROW { return __imax; }
-
-  __STL_DECLARE_LIMITS_MEMBER(int,
-                              digits,
-                              (__idigits < 0) ? (int)(sizeof(_Int) * CHAR_BIT)
-                                                   - (__imin == 0 ? 0 : 1) 
-                                              : __idigits);
-  __STL_DECLARE_LIMITS_MEMBER(int, digits10, (digits * 301) / 1000); 
-                                // log 2 = 0.301029995664...
-
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_signed,  __imin != 0);
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_integer, true);
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_exact,   true);
-  __STL_DECLARE_LIMITS_MEMBER(int,  radix,      2);
-
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_bounded, true);
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_modulo, __ismod);
-};
-
-#ifdef __STL_STATIC_CONST_INIT_BUG
-# define __STL_DEFINE_INTEGER_LIMITS_MEMBER(__type, __mem)
-#else /* __STL_STATIC_CONST_INIT_BUG */
-# define __STL_DEFINE_INTEGER_LIMITS_MEMBER(__type, __mem)              \
-  template <class _Int, _Int __imin, _Int __imax, int __idig, bool __ismod>  \
-  const __type _Integer_limits<_Int, __imin, __imax, __idig, __ismod>::__mem
-#endif /* __STL_STATIC_CONST_INIT_BUG */
-
-__STL_DEFINE_INTEGER_LIMITS_MEMBER(bool, is_specialized);
-__STL_DEFINE_INTEGER_LIMITS_MEMBER(int, digits);
-__STL_DEFINE_INTEGER_LIMITS_MEMBER(int, digits10);
-__STL_DEFINE_INTEGER_LIMITS_MEMBER(bool, is_signed);
-__STL_DEFINE_INTEGER_LIMITS_MEMBER(bool, is_integer);
-__STL_DEFINE_INTEGER_LIMITS_MEMBER(bool, is_exact);
-__STL_DEFINE_INTEGER_LIMITS_MEMBER(int, radix);
-__STL_DEFINE_INTEGER_LIMITS_MEMBER(bool, is_bounded);
-__STL_DEFINE_INTEGER_LIMITS_MEMBER(bool, is_modulo);
-
-
-// Base class for floating-point numbers.
-template <class __number,
-         int __Digits, int __Digits10,
-         int __MinExp, int __MaxExp,
-         int __MinExp10, int __MaxExp10,
-         bool __IsIEC559,
-         float_round_style __RoundStyle>
-class _Floating_limits : public _Numeric_limits_base<__number>
-{
-public:
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_specialized, true);
-
-  __STL_DECLARE_LIMITS_MEMBER(int, digits,   __Digits);
-  __STL_DECLARE_LIMITS_MEMBER(int, digits10, __Digits10);
-
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_signed, true);
-
-  __STL_DECLARE_LIMITS_MEMBER(int, radix, 2);
-
-  __STL_DECLARE_LIMITS_MEMBER(int, min_exponent,   __MinExp);
-  __STL_DECLARE_LIMITS_MEMBER(int, max_exponent,   __MaxExp);
-  __STL_DECLARE_LIMITS_MEMBER(int, min_exponent10, __MinExp10);
-  __STL_DECLARE_LIMITS_MEMBER(int, max_exponent10, __MaxExp10);
-
-  __STL_DECLARE_LIMITS_MEMBER(bool, has_infinity,      true);
-  __STL_DECLARE_LIMITS_MEMBER(bool, has_quiet_NaN,     true);
-  __STL_DECLARE_LIMITS_MEMBER(bool, has_signaling_NaN, true);
-  __STL_DECLARE_LIMITS_MEMBER(float_denorm_style,
-                              has_denorm,
-                              denorm_indeterminate);
-  __STL_DECLARE_LIMITS_MEMBER(bool, has_denorm_loss,   false);
-
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_iec559,       __IsIEC559);
-  __STL_DECLARE_LIMITS_MEMBER(bool, is_bounded,      true);
-  __STL_DECLARE_LIMITS_MEMBER(bool, traps,           true);
-  __STL_DECLARE_LIMITS_MEMBER(bool, tinyness_before, false);
-
-  __STL_DECLARE_LIMITS_MEMBER(float_round_style, round_style, __RoundStyle);
-};
-
-#ifdef __STL_STATIC_CONST_INIT_BUG
-# define __STL_DEFINE_FLOAT_LIMITS_MEMBER(__type, __mem)
-#else /* __STL_STATIC_CONST_INIT_BUG */
-# define __STL_DEFINE_FLOAT_LIMITS_MEMBER(__type, __mem)                   \
-  template <class __Num, int __Dig, int __Dig10,                           \
-            int __MnX, int __MxX, int __MnX10, int __MxX10,                \
-            bool __IsIEEE, float_round_style __Sty>                        \
-  const __type _Floating_limits<__Num, __Dig, __Dig10,                     \
-                                __MnX, __MxX, __MnX10, __MxX10,            \
-                                __IsIEEE, __Sty>:: __mem
-#endif /* __STL_STATIC_CONST_INIT_BUG */
-
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, is_specialized);  
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(int, digits);  
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(int, digits10);  
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, is_signed);  
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(int, radix);  
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(int, min_exponent);  
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(int, max_exponent);  
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(int, min_exponent10);  
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(int, max_exponent10);  
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, has_infinity);
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, has_quiet_NaN);
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, has_signaling_NaN);
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(float_denorm_style, has_denorm);
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, has_denorm_loss);
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, is_iec559);
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, is_bounded);
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, traps);
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(bool, tinyness_before);
-__STL_DEFINE_FLOAT_LIMITS_MEMBER(float_round_style, round_style);
-
-
-#undef __STL_DECLARE_NUMERIC_LIMITS_MEMBER
-#undef __STL_DEFINE_NUMERIC_BASE_MEMBER
-#undef __STL_DEFINE_INTEGER_LIMITS_MEMBER
-#undef __STL_DEFINE_FLOAT_LIMITS_MEMBER
-
-// Class numeric_limits
-
-// The unspecialized class.
-
-template<class _Tp> 
-class numeric_limits : public _Numeric_limits_base<_Tp> {};
-
-// Specializations for all built-in integral types.
-
-#ifndef __STL_NO_BOOL
-
-__STL_TEMPLATE_NULL
-class numeric_limits<bool>
-  : public _Integer_limits<bool, false, true, 1, false>
-{};
-
-#endif /* __STL_NO_BOOL */
-
-__STL_TEMPLATE_NULL
-class numeric_limits<char>
-  : public _Integer_limits<char, CHAR_MIN, CHAR_MAX>
-{};
-
-__STL_TEMPLATE_NULL
-class numeric_limits<signed char>
-  : public _Integer_limits<signed char, SCHAR_MIN, SCHAR_MAX>
-{};
-
-__STL_TEMPLATE_NULL
-class numeric_limits<unsigned char>
-  : public _Integer_limits<unsigned char, 0, UCHAR_MAX>
-{};
-
-#ifdef __STL_HAS_WCHAR_T
-
-__STL_TEMPLATE_NULL
-class numeric_limits<wchar_t>
-  : public _Integer_limits<wchar_t, INT_MIN, INT_MAX>
-{};
-
-#endif
-
-__STL_TEMPLATE_NULL
-class numeric_limits<short>
-  : public _Integer_limits<short, SHRT_MIN, SHRT_MAX>
-{};
-
-__STL_TEMPLATE_NULL
-class numeric_limits<unsigned short>
-  : public _Integer_limits<unsigned short, 0, USHRT_MAX>
-{};
-
-__STL_TEMPLATE_NULL
-class numeric_limits<int>
-  : public _Integer_limits<int, INT_MIN, INT_MAX>
-{};
-
-__STL_TEMPLATE_NULL
-class numeric_limits<unsigned int>
-  : public _Integer_limits<unsigned int, 0, UINT_MAX>
-{};
-
-__STL_TEMPLATE_NULL
-class numeric_limits<long>
-  : public _Integer_limits<long, LONG_MIN, LONG_MAX>
-{};
-
-__STL_TEMPLATE_NULL
-class numeric_limits<unsigned long>
-  : public _Integer_limits<unsigned long, 0, ULONG_MAX>
-{};
-
-#ifdef __STL_LONG_LONG
-
-// Some compilers have long long, but don't define the
-// LONGLONG_MIN and LONGLONG_MAX macros in limits.h.  This
-// assumes that long long is 64 bits.
-#if !defined(LONGLONG_MIN) && !defined(LONGLONG_MAX) \
-                           && !defined(ULONGLONG_MAX)
-
-#define ULONGLONG_MAX 0xffffffffffffffffLLU
-#define LONGLONG_MAX 0x7fffffffffffffffLL
-#define LONGLONG_MIN (-LONGLONG_MAX - 1LL)
-
-#endif
-
-__STL_TEMPLATE_NULL
-class numeric_limits<long long>
-  : public _Integer_limits<long long, LONGLONG_MIN, LONGLONG_MAX>
-{};
-
-__STL_TEMPLATE_NULL
-class numeric_limits<unsigned long long>
-  : public _Integer_limits<unsigned long long, 0, ULONGLONG_MAX>
-{};
-
-#endif /* __STL_LONG_LONG */
-
-// Specializations for all built-in floating-point type.
-
-__STL_TEMPLATE_NULL class numeric_limits<float>
-  : public _Floating_limits<float, 
-                            FLT_MANT_DIG,   // Binary digits of precision
-                            FLT_DIG,        // Decimal digits of precision
-                            FLT_MIN_EXP,    // Minimum exponent
-                            FLT_MAX_EXP,    // Maximum exponent
-                            FLT_MIN_10_EXP, // Minimum base 10 exponent
-                            FLT_MAX_10_EXP, // Maximum base 10 exponent
-                            true,           // conforms to iec559
-                            round_to_nearest>
-{
-public:
-  static float min() __STL_NOTHROW { return FLT_MIN; }
-  static float denorm_min() __STL_NOTHROW { return FLT_MIN; }
-  static float max() __STL_NOTHROW { return FLT_MAX; }
-  static float epsilon() __STL_NOTHROW { return FLT_EPSILON; }
-  static float round_error() __STL_NOTHROW { return 0.5f; } // Units: ulps.
-  static float infinity() __STL_NOTHROW;
-  static float quiet_NaN() __STL_NOTHROW;
-  static float signaling_NaN() __STL_NOTHROW;
-};
-
-__STL_TEMPLATE_NULL class numeric_limits<double>
-  : public _Floating_limits<double, 
-                            DBL_MANT_DIG,   // Binary digits of precision
-                            DBL_DIG,        // Decimal digits of precision
-                            DBL_MIN_EXP,    // Minimum exponent
-                            DBL_MAX_EXP,    // Maximum exponent
-                            DBL_MIN_10_EXP, // Minimum base 10 exponent
-                            DBL_MAX_10_EXP, // Maximum base 10 exponent
-                            true,           // conforms to iec559
-                            round_to_nearest>
-{
-public:
-  static double min() __STL_NOTHROW { return DBL_MIN; }
-  static double denorm_min() __STL_NOTHROW { return DBL_MIN; }
-  static double max() __STL_NOTHROW { return DBL_MAX; }
-  static double epsilon() __STL_NOTHROW { return DBL_EPSILON; }
-  static double round_error() __STL_NOTHROW { return 0.5; } // Units: ulps.
-  static double infinity() __STL_NOTHROW;
-  static double quiet_NaN() __STL_NOTHROW;
-  static double signaling_NaN() __STL_NOTHROW;
-};
-
-__STL_TEMPLATE_NULL class numeric_limits<long double>
-  : public _Floating_limits<long double, 
-                            LDBL_MANT_DIG,  // Binary digits of precision
-                            LDBL_DIG,       // Decimal digits of precision
-                            LDBL_MIN_EXP,   // Minimum exponent
-                            LDBL_MAX_EXP,   // Maximum exponent
-                            LDBL_MIN_10_EXP,// Minimum base 10 exponent
-                            LDBL_MAX_10_EXP,// Maximum base 10 exponent
-                            false,          // Doesn't conform to iec559
-                            round_to_nearest>
-{
-public:
-  static long double min() __STL_NOTHROW { return LDBL_MIN; }
-  static long double denorm_min() __STL_NOTHROW { return LDBL_MIN; }
-  static long double max() __STL_NOTHROW { return LDBL_MAX; }
-  static long double epsilon() __STL_NOTHROW { return LDBL_EPSILON; }
-  static long double round_error() __STL_NOTHROW { return 4; } // Units: ulps.
-  static long double infinity() __STL_NOTHROW;
-  static long double quiet_NaN() __STL_NOTHROW;
-  static long double signaling_NaN() __STL_NOTHROW;
-};
-
-// We write special values (Inf and NaN) as bit patterns and 
-// cast the the appropriate floating-point types. 
-
-#if defined(_MIPSEB)
-// Big-endian MIPS.  float is 32 bits, double 64, long double 128.
-
-#define _Define_float(__f, __h, __l)                                     \
-   inline float numeric_limits<float>::__f() __STL_NOTHROW {             \
-     static const unsigned short __x[2] = { __h, __l };                  \
-     return *reinterpret_cast<const float*>(__x); }
-#define _Define_double(__f, __h, __l)                                    \
-   inline double numeric_limits<double>::__f() __STL_NOTHROW {           \
-     static const unsigned short __x[4] = { __h, __l };                  \
-     return *reinterpret_cast<const double*>(__x); }
-#define _Define_ldouble(__f, __h, __l)                                   \
-   inline long double numeric_limits<long double>::__f() __STL_NOTHROW { \
-     static const unsigned short __x[8] = { __h, __l };                  \
-     return *reinterpret_cast<const long double*>(__x); }
-
-_Define_float(infinity, 0x7f80, 0)
-_Define_float(quiet_NaN, 0x7f81, 0)
-_Define_float(signaling_NaN, 0x7fc1, 0)
-
-_Define_double(infinity, 0x7ff0, 0)
-_Define_double(quiet_NaN, 0x7ff1, 0)
-_Define_double(signaling_NaN, 0x7ff9, 0)
-
-_Define_ldouble(infinity, 0x7ff0, 0)
-_Define_ldouble(quiet_NaN, 0x7ff1, 0)
-_Define_ldouble(signaling_NaN, 0x7ff9, 0)
-
-#elif defined(__i386) || defined(_M_IX86)
-// Little-endian ia32.  float is 32 bits, double 64, long double 80.
-
-#define _Define_float(__f, __h, __l)                                     \
-   inline float numeric_limits<float>::__f() __STL_NOTHROW {             \
-     static const unsigned short __x[2] = { __l, __h };                  \
-     return *reinterpret_cast<const float*>(__x); }
-#define _Define_double(__f, __h, __l)                                    \
-   inline double numeric_limits<double>::__f() __STL_NOTHROW {           \
-     static const unsigned short __x[4] = { 0, 0, __l, __h };            \
-     return *reinterpret_cast<const double*>(__x); }
-#define _Define_ldouble(__f, __h, __l)                                   \
-   inline long double numeric_limits<long double>::__f() __STL_NOTHROW { \
-     static const unsigned short __x[5] = { 0, 0, 0, __l, __h };         \
-     return *reinterpret_cast<const long double*>(__x); }
-
-_Define_float(infinity, 0x7f80, 0)
-_Define_float(quiet_NaN, 0x7fa0, 0)
-_Define_float(signaling_NaN, 0x7fc0, 0)
-
-_Define_double(infinity, 0x7ff0, 0)
-_Define_double(quiet_NaN, 0x7ff4, 0)
-_Define_double(signaling_NaN, 0x7ff8, 0)
-
-_Define_ldouble(infinity, 0x7fff, 0x8000)
-_Define_ldouble(quiet_NaN, 0x7fff, 0xa000)
-_Define_ldouble(signaling_NaN, 0x7fff, 0xc000)
-
-#else 
-
-/* This is an architecture we don't know how to handle.  Return some 
-   obviously wrong values. */
-
-#define _Define_float(__f)                                               \
-   inline float numeric_limits<float>::__f() __STL_NOTHROW {             \
-     return 0; }
-#define _Define_double(__f)                                              \
-   inline double numeric_limits<double>::__f() __STL_NOTHROW {           \
-     return 0; }
-#define _Define_ldouble(__f)                                             \
-   inline long double numeric_limits<long double>::__f() __STL_NOTHROW { \
-     return 0; }
-
-_Define_float(infinity)
-_Define_float(quiet_NaN)
-_Define_float(signaling_NaN)
-
-_Define_double(infinity)
-_Define_double(quiet_NaN)
-_Define_double(signaling_NaN)
-
-_Define_ldouble(infinity)
-_Define_ldouble(quiet_NaN)
-_Define_ldouble(signaling_NaN)   
-
-#endif
-
-#undef _Define_float
-#undef _Define_double
-#undef _Define_ldouble
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_CPP_LIMITS */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/list b/lib/include/stl/list
deleted file mode 100644
index 5294f39..0000000
--- a/lib/include/stl/list
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_LIST
-#define __SGI_STL_LIST
-
-#include <stl_algobase.h>
-#include <stl_alloc.h>
-#include <stl_construct.h>
-#include <stl_uninitialized.h>
-#include <stl_list.h>
-
-#endif /* __SGI_STL_LIST */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/locale b/lib/include/stl/locale
deleted file mode 100644
index 05ea3ec..0000000
--- a/lib/include/stl/locale
+++ /dev/null
@@ -1,88 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <basic_definitions>
-#include <cstddef>
-
-#ifndef STM32PLUS_BUILD
-#include <string>
-#endif
-
-#ifndef __HEADER_STD_LOCALE
-#define __HEADER_STD_LOCALE 1
-
-#pragma GCC visibility push(default)
-
-namespace std{
-	class _UCXXEXPORT locale {
-	public:
-	// types:
-		class facet;
-		class id;
-		typedef unsigned char category;
-
-		static const category
-		none     = 0,
-		collate  = 0x01, ctype    = 0x02,
-		monetary = 0x04, numeric  = 0x08,
-		time = 0x10, messages = 0x20,
-		all = collate | ctype | monetary | numeric | time  | messages;
-
-		// construct/copy/destroy:
-		locale() throw(){
-			return;
-                }
-		locale(const locale& other) throw(){
-			(void)other;
-			return;
-		}
-		locale(const char *) throw(){
-			return;
-		}
-		~locale() throw(){
-			return;
-		}
-
-		const locale& operator=(const locale&) throw(){
-			return *this;
-		}
-#ifndef STM32PLUS_BUILD
-		std::string name() const { return "C"; }
-#endif
-	};
-
-	class _UCXXEXPORT locale::facet {
-		friend class locale;
-		explicit facet(size_t = 0){
-			return;
-		}
-		virtual ~facet(){
-			return;
-		}
-	};
-
-	class _UCXXEXPORT locale::id {
-		id(){ }
-	};
-
-}
-
-#pragma GCC visibility pop
-
-#endif
diff --git a/lib/include/stl/map b/lib/include/stl/map
deleted file mode 100644
index 4cfb765..0000000
--- a/lib/include/stl/map
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_MAP
-#define __SGI_STL_MAP
-
-#ifndef __SGI_STL_INTERNAL_TREE_H
-#include <stl_tree.h>
-#endif
-#include <stl_map.h>
-#include <stl_multimap.h>
-
-#endif /* __SGI_STL_MAP */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/memory b/lib/include/stl/memory
deleted file mode 100644
index a1b096c..0000000
--- a/lib/include/stl/memory
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (c) 1997-1999
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef __SGI_STL_MEMORY
-#define __SGI_STL_MEMORY
-
-#include <stl_algobase.h>
-#include <stl_alloc.h>
-#include <stl_construct.h>
-#include <stl_tempbuf.h>
-#include <stl_uninitialized.h>
-#include <stl_raw_storage_iter.h>
-
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__SGI_STL_USE_AUTO_PTR_CONVERSIONS) && \
-    defined(__STL_MEMBER_TEMPLATES)
-
-template<class _Tp1> struct auto_ptr_ref {
-  _Tp1* _M_ptr;
-  auto_ptr_ref(_Tp1* __p) : _M_ptr(__p) {}
-};
-
-#endif
-
-template <class _Tp> class auto_ptr {
-private:
-  _Tp* _M_ptr;
-
-public:
-  typedef _Tp element_type;
-
-  explicit auto_ptr(_Tp* __p = 0) __STL_NOTHROW : _M_ptr(__p) {}
-  auto_ptr(auto_ptr& __a) __STL_NOTHROW : _M_ptr(__a.release()) {}
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _Tp1> auto_ptr(auto_ptr<_Tp1>& __a) __STL_NOTHROW
-    : _M_ptr(__a.release()) {}
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  auto_ptr& operator=(auto_ptr& __a) __STL_NOTHROW {
-    if (&__a != this) {
-      delete _M_ptr;
-      _M_ptr = __a.release();
-    }
-    return *this;
-  }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _Tp1>
-  auto_ptr& operator=(auto_ptr<_Tp1>& __a) __STL_NOTHROW {
-    if (__a.get() != this->get()) {
-      delete _M_ptr;
-      _M_ptr = __a.release();
-    }
-    return *this;
-  }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  // Note: The C++ standard says there is supposed to be an empty throw
-  // specification here, but omitting it is standard conforming.  Its 
-  // presence can be detected only if _Tp::~_Tp() throws, but (17.4.3.6/2)
-  // this is prohibited.
-  ~auto_ptr() { delete _M_ptr; }
-
-  _Tp& operator*() const __STL_NOTHROW {
-    return *_M_ptr;
-  }
-  _Tp* operator->() const __STL_NOTHROW {
-    return _M_ptr;
-  }
-  _Tp* get() const __STL_NOTHROW {
-    return _M_ptr;
-  }
-  _Tp* release() __STL_NOTHROW {
-    _Tp* __tmp = _M_ptr;
-    _M_ptr = 0;
-    return __tmp;
-  }
-  void reset(_Tp* __p = 0) __STL_NOTHROW {
-    if (__p != _M_ptr) {
-      delete _M_ptr;
-      _M_ptr = __p;
-    }
-  }
-
-  // According to the C++ standard, these conversions are required.  Most
-  // present-day compilers, however, do not enforce that requirement---and, 
-  // in fact, most present-day compilers do not support the language 
-  // features that these conversions rely on.
-  
-#if defined(__SGI_STL_USE_AUTO_PTR_CONVERSIONS) && \
-    defined(__STL_MEMBER_TEMPLATES)
-
-public:
-  auto_ptr(auto_ptr_ref<_Tp> __ref) __STL_NOTHROW
-    : _M_ptr(__ref._M_ptr) {}
-
-  auto_ptr& operator=(auto_ptr_ref<_Tp> __ref) __STL_NOTHROW {
-    if (__ref._M_ptr != this->get()) {
-      delete _M_ptr;
-      _M_ptr = __ref._M_ptr;
-    }
-    return *this;
-  }
-
-  template <class _Tp1> operator auto_ptr_ref<_Tp1>() __STL_NOTHROW 
-    { return auto_ptr_ref<_Tp1>(this->release()); }
-  template <class _Tp1> operator auto_ptr<_Tp1>() __STL_NOTHROW
-    { return auto_ptr<_Tp1>(this->release()); }
-
-#endif /* auto ptr conversions && member templates */
-};
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_MEMORY */
-
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/new b/lib/include/stl/new
deleted file mode 100644
index b6600a9..0000000
--- a/lib/include/stl/new
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * new
- *
- *  Created on: 1 Jan 2011
- *      Author: Andy Brown
- */
-
-#ifndef __1F3E89E5_F35D_4f8d_A849_9A3416814905
-#define __1F3E89E5_F35D_4f8d_A849_9A3416814905
-
-#include <cstddef>
-
-void *operator new(std::size_t size_);
-void* operator new(std::size_t size_,void *ptr_);
-void operator delete(void *ptr_);
-
-
-#endif
diff --git a/lib/include/stl/numeric b/lib/include/stl/numeric
deleted file mode 100644
index 23d4d10..0000000
--- a/lib/include/stl/numeric
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_NUMERIC
-#define __SGI_STL_NUMERIC
-
-#include <stl_config.h>
-#include <stl_relops.h>
-#include <stddef.h>
-
-#ifndef STM32PLUS_BUILD
-#ifdef __STL_USE_NEW_IOSTREAMS 
-#include <iosfwd>
-#else /* __STL_USE_NEW_IOSTREAMS */
-#include <iostream.h>
-#endif /* __STL_USE_NEW_IOSTREAMS */
-#endif
-
-#include <stl_iterator_base.h>
-#include <stl_iterator.h>
-#include <stl_function.h>
-#include <stl_numeric.h>
-
-#endif /* __SGI_STL_NUMERIC */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/ostream b/lib/include/stl/ostream
deleted file mode 100644
index 5f3d6ce..0000000
--- a/lib/include/stl/ostream
+++ /dev/null
@@ -1,497 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <basic_definitions>
-
-#ifndef STD_HEADER_OSTREAM
-#define STD_HEADER_OSTREAM 1
-
-#include <iosfwd>
-#include <streambuf>
-#ifndef STM32PLUS_BUILD
-#include <cstdio>
-#endif
-#include <ostream_helpers>
-
-#pragma GCC visibility push(default)
-
-namespace std {
-	template <class charT, class traits > class basic_ostream;
-	typedef basic_ostream<char> ostream;
-
-#ifdef __UCLIBCXX_HAS_WCHAR__
-	typedef basic_ostream<wchar_t> wostream;
-#endif
-
-	template <class charT, class traits> basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);
-	template <class charT, class traits> basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);
-	template <class charT, class traits> basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);
-
-	template <class charT, class traits > class _UCXXEXPORT basic_ostream
-		: virtual public basic_ios<charT,traits>
-	{
-	public:
-
-		typedef charT char_type;
-		typedef typename traits::int_type int_type;
-		typedef typename traits::pos_type pos_type;
-		typedef typename traits::off_type off_type;
-		typedef traits traits_type;
-
-
-		_UCXXEXPORT basic_ostream(basic_streambuf<charT,traits>* sb)
-			: basic_ios<charT, traits>(sb)
-		{
-			basic_ios<charT,traits>::init(sb);
-		}
-		virtual _UCXXEXPORT ~basic_ostream();
-
-		class sentry;
-
-		_UCXXEXPORT basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>& (*pf)(basic_ostream<charT,traits>&)){
-			return pf(*this);
-		}
-		_UCXXEXPORT basic_ostream<charT,traits>& operator<<(basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&)){
-			pf(*this);
-			return *this;
-		}
-		_UCXXEXPORT basic_ostream<charT,traits>& operator<<(ios_base& (*pf)(ios_base&)){
-			pf(*this);
-			return *this;
-		}
-		basic_ostream<charT,traits>& operator<<(bool n);
-		basic_ostream<charT,traits>& operator<<(short n);
-		basic_ostream<charT,traits>& operator<<(unsigned short n);
-		basic_ostream<charT,traits>& operator<<(int n);
-		basic_ostream<charT,traits>& operator<<(unsigned int n);
-		basic_ostream<charT,traits>& operator<<(long n);
-		basic_ostream<charT,traits>& operator<<(unsigned long n);
-		basic_ostream<charT,traits>& operator<<(float f);
-		basic_ostream<charT,traits>& operator<<(double f);
-		basic_ostream<charT,traits>& operator<<(long double f);
-		basic_ostream<charT,traits>& operator<<(void* p);
-		basic_ostream<charT,traits>& operator<<(basic_streambuf<char_type,traits>* sb);
-
-		_UCXXEXPORT basic_ostream<charT,traits>& put(char_type c){
-			if(basic_ostream<charT,traits>::traits_type::eq_int_type(
-				basic_ios<charT, traits>::mstreambuf->sputc(c),
-				basic_ostream<charT,traits>::traits_type::eof()))
-			{
-				basic_ios<charT,traits>::setstate(ios_base::eofbit);
-			}
-			return *this;
-		}
-		_UCXXEXPORT basic_ostream<charT,traits>& write(const char_type* s, streamsize n){
-			if(basic_ostream<charT,traits>::traits_type::eq_int_type(
-				basic_ios<charT, traits>::mstreambuf->sputn(s, n), 
-				basic_ostream<charT,traits>::traits_type::eof())
-			){
-				basic_ios<charT,traits>::setstate(ios_base::eofbit);
-			}
-			return *this;
-		}
-		_UCXXEXPORT basic_ostream<charT,traits>& flush(){
-			if(basic_ios<charT, traits>::mstreambuf->pubsync() == -1){
-				basic_ios<charT,traits>::setstate(ios_base::badbit);
-			}
-			return *this;
-		}
-		_UCXXEXPORT pos_type tellp(){
-			if(basic_ios<charT,traits>::fail() != false){
-				return pos_type(-1);
-			}
-			return basic_ios<charT,traits>::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
-		}
-		_UCXXEXPORT basic_ostream<charT,traits>& seekp(pos_type pos){
-			if( basic_ios<charT,traits>::fail() != true ){
-				basic_ios<charT,traits>::rdbuf()->pubseekpos(pos);
-			}
-			return *this;
-		}
-		_UCXXEXPORT basic_ostream<charT,traits>& seekp(off_type off, ios_base::seekdir dir){
-			if( basic_ios<charT,traits>::fail() != true){
-				basic_ios<charT,traits>::rdbuf()->pubseekoff(off, dir);
-			}
-			return *this;
-		}
-
-	protected:
-		basic_ostream(const basic_ostream<charT,traits> &){ }
-		basic_ostream<charT,traits> & operator=(const basic_ostream<charT,traits> &){ return *this; }
-	};
-
-	//Implementations of template functions.  To allow for partial specialization
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>::~basic_ostream(){ }
-	
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& basic_ostream<charT, traits>::operator<<(bool n){
-		sentry s(*this);
-		if( basic_ios<charT,traits>::flags() & ios_base::boolalpha){
-			if(n){
-				write("true", 4);
-			}else{
-				write("false", 5);
-			}
-		}else{
-			if(n){
-				write("1", 1);
-			}else{
-				write("0", 1);
-			}
-		}
-		if(basic_ios<charT,traits>::flags() & ios_base::unitbuf){
-			flush();
-		}
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& 
-		basic_ostream<charT, traits>::operator<<(unsigned short n){
-		sentry s(*this);
-		__ostream_printout<traits, charT, unsigned long int>::printout(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& basic_ostream<charT, traits>::operator<<(short n){
-		sentry s(*this);
-		__ostream_printout<traits, charT, long int>::printout(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& basic_ostream<charT, traits>::operator<<(int n){
-		sentry s(*this);
-		__ostream_printout<traits, charT, long int>::printout(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& basic_ostream<charT, traits>::operator<<(unsigned int n){
-		sentry s(*this);
-		__ostream_printout<traits, charT, unsigned long int>::printout(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& basic_ostream<charT, traits>::operator<<(long n){
-		sentry s(*this);
-		__ostream_printout<traits, charT, long >::printout(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& 
-		basic_ostream<charT, traits>::operator<<(unsigned long n)
-	{
-		sentry s(*this);
-		__ostream_printout<traits, charT, unsigned long >::printout(*this, n);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& basic_ostream<charT, traits>::operator<<(float f){
-		sentry s(*this);
-		__ostream_printout<traits, charT, double >::printout(*this, f);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& basic_ostream<charT, traits>::operator<<(double f){
-		sentry s(*this);
-		__ostream_printout<traits, charT, double >::printout(*this, f);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& basic_ostream<charT, traits>::operator<<(long double f){
-		sentry s(*this);
-		__ostream_printout<traits, charT, long double >::printout(*this, f);
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& basic_ostream<charT, traits>::operator<<(void* p){
-		sentry s(*this);
-		char buffer[20];
-		write(buffer, snprintf(buffer, 20, "%p", p) );
-		if(basic_ios<charT,traits>::flags() & ios_base::unitbuf){
-			flush();
-		}
-		return *this;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& 
-		basic_ostream<charT, traits>::operator<<(basic_streambuf<charT,traits>* sb)
-	{
-		sentry s(*this);
-		if(sb == 0){
-			basic_ios<charT,traits>::setstate(ios_base::badbit);
-			return *this;
-		}
-
-		typename traits::int_type c;
-
-		while(basic_ios<charT,traits>::good() && (c = sb->sbumpc()) != traits::eof() ){
-			put(c);
-		}
-
-		if(basic_ios<charT,traits>::flags() & ios_base::unitbuf){
-			flush();
-		}
-		return *this;
-	}
-
-	/*Template Specializations*/
-
-#ifdef __UCLIBCXX_EXPAND_OSTREAM_CHAR__
-#ifndef __UCLIBCXX_COMPILE_OSTREAM__
-
-#ifdef __UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-
-	template <> _UCXXEXPORT ostream::~basic_ostream();
-
-#endif // __UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-
-	template <> _UCXXEXPORT ostream & ostream::flush();
-
-	template <> _UCXXEXPORT ostream & ostream::operator<<(bool n);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(short int n);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(unsigned short int n);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(int n);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(unsigned int n);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(long n);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(unsigned long n);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(float f);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(double f);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(long double f);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(void* p);
-	template <> _UCXXEXPORT ostream & ostream::operator<<(basic_streambuf<char, char_traits<char> >* sb);
-#endif
-#endif
-
-	template <class charT,class traits>
-		class _UCXXEXPORT basic_ostream<charT,traits>::sentry
-	{
-		bool ok;
-	public:
-		explicit _UCXXEXPORT sentry(basic_ostream<charT,traits>& os): ok(true){
-			if(os.good() !=0){		//Prepare for output
-			}
-
-			//Flush any tied buffer
-			if(os.tie() !=0 ){
-				os.tie()->flush();
-			}
-		}
-		_UCXXEXPORT ~sentry() { }
-		_UCXXEXPORT operator bool() {
-			return ok;
-		}
-	};
-
-
-#ifdef __UCLIBCXX_EXPAND_OSTREAM_CHAR__
-#ifndef __UCLIBCXX_COMPILE_OSTREAM__
-#ifdef __UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-
-	template <> _UCXXEXPORT ostream::sentry::sentry(ostream & os);
-	template <> _UCXXEXPORT ostream::sentry::~sentry();
-
-#endif //__UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-#endif
-#endif
-
-
-	//Non - class functions
-
-
-	template<class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>&
-		operator<<(basic_ostream<charT,traits>& out, charT c)
-	{
-		typename basic_ostream<charT,traits>::sentry s(out);
-		out.put(c);
-		return out;
-	}
-	
-	template<class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>&
-		operator<<(basic_ostream<charT,traits>& out, char c)
-	{
-		typename basic_ostream<charT,traits>::sentry s(out);
-		out.put(c);
-		return out;
-	}
-    
-	template<class traits> _UCXXEXPORT basic_ostream<char,traits>&
-		operator<<(basic_ostream<char,traits>& out, char c)
-	{
-		typename basic_ostream<char,traits>::sentry s(out);
-		out.put(c);
-		return out;
-	}
-    
-    // signed and unsigned
-	template<class traits> _UCXXEXPORT basic_ostream<char,traits>&
-		operator<<(basic_ostream<char,traits>& out, signed char c)
-	{
-		typename basic_ostream<char,traits>::sentry s(out);
-		out.put(c);
-		return out;
-	}
-	
-	template<class traits> _UCXXEXPORT basic_ostream<char,traits>&
-		operator<<(basic_ostream<char,traits>& out, unsigned char c)
-	{
-		typename basic_ostream<char,traits>::sentry s(out);
-		out.put(c);
-		return out;
-	}
-	
-	template<class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>&
-		operator<<(basic_ostream<charT,traits>& out, const charT* c)
-	{
-		typename basic_ostream<charT,traits>::sentry s(out);
-		out.write(c, traits::length(c) );
-		return out;
-	}
-	
-	template<class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>&
-		operator<<(basic_ostream<charT,traits>& out, const char* c)
-	{
-		typename basic_ostream<charT,traits>::sentry s(out);
-		out.write(c, char_traits<char>::length(c) );
-		return out;
-	}
-
-    // partial specializations
-	template<class traits> _UCXXEXPORT basic_ostream<char,traits>&
-		operator<<(basic_ostream<char,traits>& out, const char* c)
-	{
-		typename basic_ostream<char,traits>::sentry s(out);
-		out.write(c, traits::length(c));
-		return out;
-	}
-
-#ifdef __UCLIBCXX_HAS_WCHAR__
-	template<class traits> _UCXXEXPORT basic_ostream<wchar_t,traits>&
-		operator<<(basic_ostream<wchar_t,traits>& out, const char* c)
-	{
-		typename basic_ostream<wchar_t, traits>::sentry s(out);
-		size_t numChars = char_traits<char>::length(c);
-		wchar_t * temp = new wchar_t[numChars];
-
-		for(size_t i=0; i < numChars; ++i){
-			temp[i] = out.widen(c[i]);
-		}
-
-		out.write(temp, numChars);
-		return out;
-	}
-#endif
-    
-    //  signed and unsigned
-	template<class traits> _UCXXEXPORT basic_ostream<char,traits>&
-		operator<<(basic_ostream<char,traits>& out, const signed char* c)
-	{
-		typename basic_ostream<char,traits>::sentry s(out);
-		out.write(reinterpret_cast<const char *>(c), traits::length( reinterpret_cast<const char *>(c)));
-		return out;
-	}
-	
-	template<class traits> _UCXXEXPORT basic_ostream<char,traits>&
-		operator<<(basic_ostream<char,traits>& out, const unsigned char* c)
-	{
-		typename basic_ostream<char,traits>::sentry s(out);
-		out.write(reinterpret_cast<const char *>(c), traits::length( reinterpret_cast<const char *>(c)));
-		return out;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>&
-		endl(basic_ostream<charT,traits>& os)
-	{
-		typename basic_ostream<charT,traits>::sentry s(os);
-		os.put('\n');
-		os.flush();
-		return os;
-	}
-
-#ifdef STM32PLUS_BUILD
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>&
-		crlf(basic_ostream<charT,traits>& os)
-	{
-		typename basic_ostream<charT,traits>::sentry s(os);
-		os.put('\r');
-		os.put('\n');
-		os.flush();
-		return os;
-	}
-#endif
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>&
-		ends(basic_ostream<charT,traits>& os)
-	{
-		typename basic_ostream<charT,traits>::sentry s(os);
-		os.put(traits::eos());
-		return os;
-	}
-
-	template <class charT, class traits> _UCXXEXPORT basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os){
-		typename basic_ostream<charT,traits>::sentry s(os);
-		os.flush();
-		return os;
-	}
-
-
-#ifdef __UCLIBCXX_EXPAND_OSTREAM_CHAR__
-#ifndef __UCLIBCXX_COMPILE_OSTREAM__
-	template <> _UCXXEXPORT ostream & endl(ostream & os);
-	template <> _UCXXEXPORT ostream & flush(ostream & os);
-	template <> _UCXXEXPORT ostream & operator<<(ostream & out, char c);
-	template <> _UCXXEXPORT ostream & operator<<(ostream & out, const char* c);
-	template <> _UCXXEXPORT ostream & operator<<(ostream & out, unsigned char c);
-	template <> _UCXXEXPORT ostream & operator<<(ostream & out, unsigned const char* c);
-
-#endif
-#endif
-
-
-#ifndef __STRICT_ANSI__
-
-//Support for output of long long data types
-
-template<class Ch, class Tr> _UCXXEXPORT basic_ostream<Ch, Tr>& 
-	operator<<(basic_ostream<Ch, Tr>& os, signed long long int i)
-{
-	typename basic_ostream<Ch, Tr>::sentry s(os);
-	__ostream_printout<Tr, Ch, signed long long int>::printout(os, i);
-	return os;
-}
-
-
-template<class Ch, class Tr> _UCXXEXPORT basic_ostream<Ch, Tr>& 
-	operator<<(basic_ostream<Ch, Tr>& os, unsigned long long int i)
-{
-	typename basic_ostream<Ch, Tr>::sentry s(os);
-	__ostream_printout<Tr, Ch, unsigned long long int>::printout(os, i);
-	return os;
-}
-
-
-#endif	//__STRICT_ANSI__
-
-
-
-
-}
-
-#pragma GCC visibility pop
-
-#endif
-
diff --git a/lib/include/stl/ostream_helpers b/lib/include/stl/ostream_helpers
deleted file mode 100644
index 04fdce1..0000000
--- a/lib/include/stl/ostream_helpers
+++ /dev/null
@@ -1,498 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <basic_definitions>
-#include <cstddef>
-#include <ios>
-#include <cctype>
-#include <string>
-#include <stdio.h>
-
-#ifndef __STD_HEADER_OSTREAM_HELPERS
-#define __STD_HEADER_OSTREAM_HELPERS 1
-
-#pragma GCC visibility push(default)
-
-namespace std{
-
-	/* We are making the following template class for serveral reasons.  Firstly,
-	 * we want to keep the main ostream code neat and tidy.  Secondly, we want it
-	 * to be easy to do partial specialization of the ostream code so that it can
-	 * be expanded and put into the library.  This will allow us to make application
-	 * code smaller at the expense of increased library size.  This is a fair
-	 * trade-off when there are multiple applications being compiled.  Also, this
-	 * feature will be used optionally via configuration options.  It will also
-	 * allow us to keep the code bases in sync, dramatically simplifying the
-	 * maintenance required.  We specialized for char because wchar and others
-	 * require different scanf functions
-	 */
-
-
-
-	template <class traits, class charT, class dataType> class _UCXXEXPORT __ostream_printout{
-	public:
-		static void printout(basic_ostream<charT,traits>& stream, const dataType n);
-	};
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, char, signed long int>{
-	public:
-		static void printout(basic_ostream<char, traits >& stream, const signed long int n)
-		{
-			char buffer[20];
-			const char * c_ld = "%ld";
-			const char * c_lo = "%lo";
-			const char * c_lX = "%lX";
-			const char * c_lx = "%lx";
-			const char * c_hashlo = "%#lo";
-			const char * c_hashlX = "%#lX";
-			const char * c_hashlx = "%#lx";
-
-			const char * formatString=0;
-
-			if( stream.flags() & ios_base::dec){
-				formatString = c_ld;
-			}else if( stream.flags() & ios_base::oct){
-				if( stream.flags() & ios_base::showbase){
-					formatString = c_hashlo;
-				}else{
-					formatString = c_lo;
-				}
-			}else if (stream.flags() & ios_base::hex){
-				if(stream.flags() & ios_base::showbase){
-					if(stream.flags() & ios_base::uppercase){
-						formatString = c_hashlX;
-					}else{
-						formatString = c_hashlx;
-					}
-				}else{
-					if(stream.flags() & ios_base::uppercase){
-						formatString = c_lX;
-					}else{
-						formatString = c_lx;
-					}
-				}
-			}
-
-			stream.write(buffer, snprintf(buffer, 20, formatString, n) );
-
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, char, unsigned long int>{
-	public:
-		static void printout(basic_ostream<char, traits >& stream, const unsigned long int n)
-		{
-			char buffer[20];
-			const char * c_lo = "%lo";
-			const char * c_lu = "%lu";
-			const char * c_lX = "%lX";
-			const char * c_lx = "%lx";
-			const char * c_hashlo = "%#lo";
-			const char * c_hashlX = "%#lX";
-			const char * c_hashlx = "%#lx";
-			const char * formatString=0;
-
-			if( stream.flags() & ios_base::dec){
-				formatString = c_lu;
-			}else if( stream.flags() & ios_base::oct){
-				if( stream.flags() & ios_base::showbase){
-					formatString = c_hashlo;
-				}else{
-					formatString = c_lo;
-				}
-			}else if (stream.flags() & ios_base::hex){
-				if(stream.flags() & ios_base::showbase){
-					if(stream.flags() & ios_base::uppercase){
-						formatString = c_hashlX;
-					}else{
-						formatString = c_hashlx;
-					}
-				}else{
-					if(stream.flags() & ios_base::uppercase){
-						formatString = c_lX;
-					}else{
-						formatString = c_lx;
-					}
-				}
-			}
-
-			stream.write(buffer, snprintf(buffer, 20, formatString, n));
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-#ifndef __STRICT_ANSI__
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, char, signed long long int>{
-	public:
-		static void printout(basic_ostream<char, traits >& stream, const signed long long int n)
-		{
-			char buffer[28];
-			const char * lld = "%lld";
-			const char * llo = "%llo";
-			const char * llX = "%llX";
-			const char * llx = "%llx";
-			const char * hashllo = "%#llo";
-			const char * hashllX = "%#llX";
-			const char * hashllx = "%#llx";
-			const char * formatString=0;
-
-			if( stream.flags() & ios_base::dec){
-				formatString = lld;
-			}else if( stream.flags() & ios_base::oct){
-				if( stream.flags() & ios_base::showbase){
-					formatString = hashllo;
-				}else{
-					formatString = llo;
-				}
-			}else if (stream.flags() & ios_base::hex){
-				if(stream.flags() & ios_base::showbase){
-					if(stream.flags() & ios_base::uppercase){
-						formatString = hashllX;
-					}else{
-						formatString = hashllx;
-					}
-				}else{
-					if(stream.flags() & ios_base::uppercase){
-						formatString = llX;
-					}else{
-						formatString = llx;
-					}
-				}
-			}
-
-			stream.write(buffer, snprintf(buffer, 27, formatString, n) );
-
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, char, unsigned long long int>{
-	public:
-		static void printout(basic_ostream<char, traits >& stream, const unsigned long long int n)
-		{
-			char buffer[28];
-			const char * llo = "%llo";
-			const char * llu = "%llu";
-			const char * llX = "%llX";
-			const char * llx = "%llx";
-			const char * hashllo = "%#llo";
-			const char * hashllX = "%#llX";
-			const char * hashllx = "%#llx";
-			const char * formatString=0;
-
-			if( stream.flags() & ios_base::dec){
-				formatString = llu;
-			}else if( stream.flags() & ios_base::oct){
-				if( stream.flags() & ios_base::showbase){
-					formatString = hashllo;
-				}else{
-					formatString = llo;
-				}
-			}else if (stream.flags() & ios_base::hex){
-				if(stream.flags() & ios_base::showbase){
-					if(stream.flags() & ios_base::uppercase){
-						formatString = hashllX;
-					}else{
-						formatString = hashllx;
-					}
-				}else{
-					if(stream.flags() & ios_base::uppercase){
-						formatString = llX;
-					}else{
-						formatString = llx;
-					}
-				}
-			}
-
-			stream.write(buffer, snprintf(buffer, 27, formatString, n) );
-
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-
-#endif	//__STRICT_ANSI__
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, char, double>{
-	public:
-		static void printout(basic_ostream<char, traits >& stream, double f)
-		{
-			char buffer[32];
-			int length;
-
-#ifdef STM32PLUS_BUILD
-
-		length=stm32plus::StringUtil::modp_dtoa(f,stream.precision(),buffer);
-
-#else
-			if(stream.flags() & ios_base::scientific){
-				if(stream.flags() & ios_base::uppercase){
-					length = snprintf(buffer, 32, "%*.*E", static_cast<int>(stream.width()),static_cast<int>(stream.precision()), f);
-				}else{
-					length = snprintf(buffer, 32, "%*.*e", static_cast<int>(stream.width()),static_cast<int>(stream.precision()), f);
-				}
-			} else if(stream.flags() & ios_base::fixed){
-				length = snprintf(buffer, 32, "%*.*f",static_cast<int>(stream.width()),static_cast<int>(stream.precision()), f);
-			} else {
-				length = snprintf(buffer, 32, "%*.*g",static_cast<int>(stream.width()),static_cast<int>(stream.precision()), f);
-			}
-#endif
-			stream.write(buffer, length);
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, char, long double>{
-	public:
-		static void printout(basic_ostream<char, traits >& stream, const long double f)
-		{
-			char buffer[32];
-			int length;
-			if(stream.flags() & ios_base::scientific){
-				if(stream.flags() & ios_base::uppercase){
-					length = snprintf(buffer, 32, "%*.*LE", static_cast<int>(stream.width()), static_cast<int>(stream.precision()), f);
-				}else{
-					length = snprintf(buffer, 32, "%*.*Le", static_cast<int>(stream.width()), static_cast<int>(stream.precision()), f);
-				}
-			} else if(stream.flags() & ios_base::fixed){
-				length = snprintf(buffer, 32, "%*.*Lf", static_cast<int>(stream.width()), static_cast<int>(stream.precision()), f);
-			} else {
-				length = snprintf(buffer, 32, "%*.*Lg", static_cast<int>(stream.width()), static_cast<int>(stream.precision()), f);
-			}
-			stream.write(buffer, length);
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-
-		}
-	};
-
-#ifdef __UCLIBCXX_HAS_WCHAR__
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, wchar_t, signed long int>{
-	public:
-		static void printout(basic_ostream<wchar_t, traits >& stream, const signed long int n)
-		{
-			wchar_t buffer[20];
-			if( stream.flags() & ios_base::dec){
-				stream.write(buffer, swprintf(buffer, 20, L"%ld", n));
-			}else if( stream.flags() & ios_base::oct){
-				if( stream.flags() & ios_base::showbase){
-					stream.write(buffer, swprintf(buffer, 20, L"%#lo", n));
-				}else{
-					stream.write(buffer, swprintf(buffer, 20, L"%lo", n) );
-				}
-			}else if (stream.flags() & ios_base::hex){
-				if(stream.flags() & ios_base::showbase){
-					if(stream.flags() & ios_base::uppercase){
-						stream.write(buffer, swprintf(buffer, 20, L"%#lX", n) );
-					}else{
-						stream.write(buffer, swprintf(buffer, 20, L"%#lx", n) );
-					}
-				}else{
-					if(stream.flags() & ios_base::uppercase){
-						stream.write(buffer, swprintf(buffer, 20, L"%lX", n) );
-					}else{
-						stream.write(buffer, swprintf(buffer, 20, L"%lx", n) );
-					}
-				}
-			}
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, wchar_t, unsigned long int>{
-	public:
-		static void printout(basic_ostream<wchar_t, traits >& stream, const unsigned long int n)
-		{
-			wchar_t buffer[20];
-			if( stream.flags() & ios_base::dec){
-				stream.write(buffer, swprintf(buffer, 20, L"%lu", n));
-			}else if( stream.flags() & ios_base::oct){
-				if( stream.flags() & ios_base::showbase){
-					stream.write(buffer, swprintf(buffer, 20, L"%#lo", n));
-				}else{
-					stream.write(buffer, swprintf(buffer, 20, L"%lo", n) );
-				}
-			}else if (stream.flags() & ios_base::hex){
-				if(stream.flags() & ios_base::showbase){
-					if(stream.flags() & ios_base::uppercase){
-						stream.write(buffer, swprintf(buffer, 20, L"%#lX", n) );
-					}else{
-						stream.write(buffer, swprintf(buffer, 20, L"%#lx", n) );
-					}
-				}else{
-					if(stream.flags() & ios_base::uppercase){
-						stream.write(buffer, swprintf(buffer, 20, L"%lX", n) );
-					}else{
-						stream.write(buffer, swprintf(buffer, 20, L"%lx", n) );
-					}
-				}
-			}
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-#ifndef __STRICT_ANSI__
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, wchar_t, signed long long int>{
-	public:
-		static void printout(basic_ostream<wchar_t, traits >& stream, const signed long long int n)
-		{
-			wchar_t buffer[28];
-			if( stream.flags() & ios_base::dec){
-				stream.write(buffer, swprintf(buffer, 27, L"%lld", n));
-			}else if( stream.flags() & ios_base::oct){
-				if( stream.flags() & ios_base::showbase){
-					stream.write(buffer, swprintf(buffer, 27, L"%#llo", n));
-				}else{
-					stream.write(buffer, swprintf(buffer, 27, L"%llo", n) );
-				}
-			}else if (stream.flags() & ios_base::hex){
-				if(stream.flags() & ios_base::showbase){
-					if(stream.flags() & ios_base::uppercase){
-						stream.write(buffer, swprintf(buffer, 27, L"%#llX", n) );
-					}else{
-						stream.write(buffer, swprintf(buffer, 27, L"%#llx", n) );
-					}
-				}else{
-					if(stream.flags() & ios_base::uppercase){
-						stream.write(buffer, swprintf(buffer, 27, L"%llX", n) );
-					}else{
-						stream.write(buffer, swprintf(buffer, 27, L"%llx", n) );
-					}
-				}
-			}
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, wchar_t, unsigned long long int>{
-	public:
-		static void printout(basic_ostream<wchar_t, traits >& stream, const unsigned long long int n)
-		{
-			wchar_t buffer[28];
-			if( stream.flags() & ios_base::dec){
-				stream.write(buffer, swprintf(buffer, 27, L"%llu", n));
-			}else if( stream.flags() & ios_base::oct){
-				if( stream.flags() & ios_base::showbase){
-					stream.write(buffer, swprintf(buffer, 27, L"%#llo", n));
-				}else{
-					stream.write(buffer, swprintf(buffer, 27, L"%llo", n) );
-				}
-			}else if (stream.flags() & ios_base::hex){
-				if(stream.flags() & ios_base::showbase){
-					if(stream.flags() & ios_base::uppercase){
-						stream.write(buffer, swprintf(buffer, 27, L"%#llX", n) );
-					}else{
-						stream.write(buffer, swprintf(buffer, 27, L"%#llx", n) );
-					}
-				}else{
-					if(stream.flags() & ios_base::uppercase){
-						stream.write(buffer, swprintf(buffer, 27, L"%llX", n) );
-					}else{
-						stream.write(buffer, swprintf(buffer, 27, L"%llx", n) );
-					}
-				}
-			}
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-
-#endif	//__STRICT_ANSI__
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, wchar_t, double>{
-	public:
-		static void printout(basic_ostream<wchar_t, traits >& stream, const double f)
-		{
-			wchar_t buffer[32];
-			wchar_t format_string[32];
-			if(stream.flags() & ios_base::scientific){
-				if(stream.flags() & ios_base::uppercase){
-					swprintf(format_string, 32, L"%%%u.%uE", static_cast<int>(stream.width()), static_cast<unsigned int>(stream.precision()));
-				}else{
-					swprintf(format_string, 32, L"%%%u.%ue", static_cast<int>(stream.width()), static_cast<unsigned int>(stream.precision()));
-				}
-			} else if(stream.flags() & ios_base::fixed){
-				swprintf(format_string, 32, L"%%%u.%uf", static_cast<int>(stream.width()), static_cast<unsigned int>(stream.precision()));
-			} else {
-				swprintf(format_string, 32, L"%%%u.%ug", static_cast<int>(stream.width()), static_cast<unsigned int>(stream.precision()));
-			}
-			stream.write(buffer, swprintf(buffer, 32, format_string, f) );
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-	template <class traits> class _UCXXEXPORT __ostream_printout<traits, wchar_t, long double>{
-	public:
-		static void printout(basic_ostream<wchar_t, traits >& stream, const long double f)
-		{
-			wchar_t buffer[32];
-			wchar_t format_string[32];
-			if(stream.flags() & ios_base::scientific){
-				if(stream.flags() & ios_base::uppercase){
-					swprintf(format_string, 32, L"%%%u.%uLE", static_cast<unsigned int>(stream.width()), static_cast<unsigned int>(stream.precision()));
-				}else{
-					swprintf(format_string, 32, L"%%%u.%uLe", static_cast<unsigned int>(stream.width()), static_cast<unsigned int>(stream.precision()));
-				}
-			} else if(stream.flags() & ios_base::fixed){
-				swprintf(format_string, 32, L"%%%u.%uLf", static_cast<unsigned int>(stream.width()), static_cast<unsigned int>(stream.precision()));
-			} else {
-				swprintf(format_string, 32, L"%%%u.%uLg", static_cast<unsigned int>(stream.width()), static_cast<unsigned int>(stream.precision()));
-			}
-			stream.write(buffer, swprintf(buffer, 32, format_string, f) );
-			if(stream.flags() & ios_base::unitbuf){
-				stream.flush();
-			}
-		}
-	};
-
-#endif //__UCLIBCXX_HAS_WCHAR__
-
-}
-
-#pragma GCC visibility pop
-
-#endif
-
-
-
diff --git a/lib/include/stl/queue b/lib/include/stl/queue
deleted file mode 100644
index f9417fb..0000000
--- a/lib/include/stl/queue
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_QUEUE
-#define __SGI_STL_QUEUE
-
-#include <stl_algobase.h>
-#include <stl_alloc.h>
-#include <stl_construct.h>
-#include <stl_uninitialized.h>
-#include <stl_vector.h>
-#include <stl_bvector.h>
-#include <stl_heap.h>
-#include <stl_deque.h>
-#include <stl_function.h>
-#include <stl_queue.h>
-
-#endif /* __SGI_STL_QUEUE */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/sequence_concepts.h b/lib/include/stl/sequence_concepts.h
deleted file mode 100644
index bf8f373..0000000
--- a/lib/include/stl/sequence_concepts.h
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * Copyright (c) 1999
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef STL_SEQUENCE_CONCEPTS_H
-#define STL_SEQUENCE_CONCEPTS_H
-
-#include <container_concepts.h>
-
-#ifdef __STL_USE_CONCEPT_CHECKS
-
-// This file covers the following concepts:
-//       _Sequence
-//       _FrontInsertionSequence
-//       _BackInsertionSequence
-
-struct _ERROR_IN_STL_SEQ {
-
-  template <class _XX>
-  static void
-  __fill_constructor_requirement_violation(_XX& __s) {
-    typename _XX::value_type __t = typename _XX::value_type();
-    typename _XX::difference_type __n = typename _XX::difference_type();
-    _XX __x(__n, __t);
-    __sink_unused_warning(__x);
-  }
-  template <class _XX>
-  static void
-  __fill_default_constructor_requirement_violation(_XX& __s) {
-    _STL_ERROR::__default_constructor_requirement_violation(*__s.begin());
-    typename _XX::difference_type __n = typename _XX::difference_type();
-    _XX __x(__n);
-    __sink_unused_warning(__x);
-  }  
-  template <class _XX>
-  static void
-  __range_constructor_requirement_violation(_XX& __s) {
-    _XX __x(__s.begin(), __s.end());
-    __sink_unused_warning(__x);
-  }
-  template <class _XX>
-  static void
-  __insert_function_requirement_violation(_XX& __s) {
-    typename _XX::value_type __t = typename _XX::value_type();
-    typename _XX::iterator __p = typename _XX::iterator();
-    __p = __s.insert(__p, __t);
-  }
-  template <class _XX>
-  static void
-  __fill_insert_function_requirement_violation(_XX& __s) {
-    typename _XX::value_type __t = typename _XX::value_type();
-    typename _XX::iterator __p = typename _XX::iterator();
-    typename _XX::difference_type __n = typename _XX::difference_type();
-    __s.insert(__p, __n, __t);
-  }
-  template <class _XX>
-  static void
-  __range_insert_function_requirement_violation(_XX& __s) {
-    typename _XX::iterator __p = typename _XX::iterator();
-    typename _XX::iterator __i = typename _XX::iterator();
-    typename _XX::iterator __j = typename _XX::iterator();
-    __s.insert(__p, __i, __j);
-  }
-  template <class _XX>
-  static void
-  __insert_element_function_requirement_violation(_XX& __s) {
-    typename _XX::value_type __t = typename _XX::value_type();
-    std::pair<typename _XX::iterator, bool> __r;
-    __r = __s.insert(__t);
-    __sink_unused_warning(__r);
-  }
-  template <class _XX>
-  static void
-  __unconditional_insert_element_function_requirement_violation(_XX& __s) {
-    typename _XX::value_type __t = typename _XX::value_type();
-    typename _XX::iterator __p;
-    __p = __s.insert(__t);
-    __sink_unused_warning(__p);
-  }
-  template <class _XX>
-  static void
-  __erase_function_requirement_violation(_XX& __s) {
-    typename _XX::iterator __p = typename _XX::iterator();
-    __p = __s.erase(__p);
-  }
-  template <class _XX>
-  static void
-  __range_erase_function_requirement_violation(_XX& __s) {
-    typename _XX::iterator __p = typename _XX::iterator();
-    typename _XX::iterator __q = typename _XX::iterator();
-    __p = __s.erase(__p, __q);
-  }
-  template <class _XX>
-  static void
-  __const_front_function_requirement_violation(const _XX& __s) {
-    typename _XX::const_reference __t = __s.front();
-    __sink_unused_warning(__t);
-  }
-  template <class _XX>
-  static void
-  __front_function_requirement_violation(_XX& __s) {
-    typename _XX::reference __t = __s.front();
-    __const_front_function_requirement_violation(__s);
-    __sink_unused_warning(__t);
-  }
-  template <class _XX>
-  static void
-  __const_back_function_requirement_violation(const _XX& __s) {
-    typename _XX::const_reference __t = __s.back();
-    __sink_unused_warning(__t);
-  }
-  template <class _XX>
-  static void
-  __back_function_requirement_violation(_XX& __s) {
-    typename _XX::reference __t = __s.back();
-    __const_back_function_requirement_violation(__s);
-    __sink_unused_warning(__t);
-  }
-  template <class _XX>
-  static void
-  __push_front_function_requirement_violation(_XX& __s) {
-    typename _XX::value_type __t = typename _XX::value_type();
-    __s.push_front(__t);
-  }
-  template <class _XX>
-  static void
-  __pop_front_function_requirement_violation(_XX& __s) {
-    __s.pop_front();
-  }
-  template <class _XX>
-  static void
-  __push_back_function_requirement_violation(_XX& __s) {
-    typename _XX::value_type __t = typename _XX::value_type();
-    __s.push_back(__t);
-  }
-  template <class _XX>
-  static void
-  __pop_back_function_requirement_violation(_XX& __s) {
-    __s.pop_back();
-  }
-
-};
-
-/* Sequence Containers */
-
-template <class _Sequence>
-struct _Sequence_concept_specification {
-static void
-_Sequence_requirement_violation(_Sequence __s) {
-  // Refinement of ForwardContainer
-  _ForwardContainer_concept_specification<_Sequence>::_ForwardContainer_requirement_violation(__s);
-  // Refinement of DefaultConstructible
-  _DefaultConstructible_concept_specification<_Sequence>::_DefaultConstructible_requirement_violation(__s);
-  // Valid Expressions
-  _ERROR_IN_STL_SEQ::__fill_constructor_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__fill_default_constructor_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__range_constructor_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__insert_function_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__fill_insert_function_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__range_insert_function_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__erase_function_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__range_erase_function_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__front_function_requirement_violation(__s);
-}
-};
-
-template <class _FrontInsertionSequence>
-struct _FrontInsertionSequence_concept_specification {
-static void
-_FrontInsertionSequence_requirement_violation(_FrontInsertionSequence __s) {
-  // Refinement of Sequence
-  _Sequence_concept_specification<_FrontInsertionSequence>::_Sequence_requirement_violation(__s);
-  // Valid Expressions
-  _ERROR_IN_STL_SEQ::__push_front_function_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__pop_front_function_requirement_violation(__s);
-}
-};
-
-template <class _BackInsertionSequence>
-struct _BackInsertionSequence_concept_specification {
-static void
-_BackInsertionSequence_requirement_violation(_BackInsertionSequence __s) {
-  // Refinement of Sequence
-  _Sequence_concept_specification<_BackInsertionSequence>::_Sequence_requirement_violation(__s);
-  // Valid Expressions
-  _ERROR_IN_STL_SEQ::__back_function_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__push_back_function_requirement_violation(__s);
-  _ERROR_IN_STL_SEQ::__pop_back_function_requirement_violation(__s);
-}
-};
-
-#endif /* if __STL_USE_CONCEPT_CHECKS */
-
-
-#endif /* STL_SEQUENCE_CONCEPTS_H */
diff --git a/lib/include/stl/serstream b/lib/include/stl/serstream
deleted file mode 100644
index 31f6cd1..0000000
--- a/lib/include/stl/serstream
+++ /dev/null
@@ -1,293 +0,0 @@
-/*
- * serstream
- * Implementation of input/output streams for the Arduino serial classes
- *
- *  Created on: 2 Jan 2011
- *      Author: Andy Brown
- *
- *  http://andybrown.me.uk/ws/terms-and-conditions
- */
-
-#ifndef __810370EC_AD69_4ef7_91F5_B1AA16F14712
-#define __810370EC_AD69_4ef7_91F5_B1AA16F14712
-
-#include <basic_definitions>
-
-#include <stl_config.h>
-#include <iosfwd>
-#include <ios>
-#include <istream>
-#include <ostream>
-#include <iostream>
-
-
-namespace std
-{
-/*
- * basic_serialbuf implements an unbuffered basic_streambuf as a backing buffer
- * for the IO classes
- */
- 
-	template <class charT, class traits, class Tserial>
-		class basic_serialbuf : public basic_streambuf<charT,traits>
-	{
-	public:
-
-	/*
-	 * Types used here
-	 */
-
-		typedef charT char_type;
-		typedef typename traits::int_type int_type;
-
-	/*
-	 * constructor - wraps an existing Tserial class instance
-	 */
-
-		explicit basic_serialbuf(Tserial& serial_,ios_base::openmode which_ = ios_base::in | ios_base::out)
-			: _serial(serial_)
-		{
-			basic_streambuf<charT,traits>::openedFor = which_;
-		}
-
-	/*
-	 * Required to maintain the chain
-	 */
-
-		virtual ~basic_serialbuf() { }
-
-	/*
-	 * Get a reference to the wrapped object
-	 */
-
-		Tserial& serial() { return _serial; }
-
-	protected:
-		
-	/*
-	 * Get how many bytes available
-	 */
-
-		virtual int showmanyc(){
-			return _serial.available();
-		}
-		
-	/*
-	 * Read up to n chars
-	 */
-
-		virtual streamsize xsgetn(char_type* c, streamsize n) {
-		
-			streamsize i = 0;
-			char_type data;
-			
-			while((data=_serial.read())!=-1 && i < n ) {
-				c[i] = data;
-				++i;
-			}
-			return i;
-		}
-
-	/*
-	 * Write up to n chars
-	 */
-
-		virtual streamsize xsputn(const char_type* s, streamsize n){
-			
-			for(streamsize i=0;i<n;i++)
-				_serial.print(s[i]);
-
-			return n;
-		}
-
-	/*
-	 * write a single char
-	 */
-
-		virtual int_type overflow (int_type c = traits::eof()) {
-			if(!traits::eq_int_type(c,traits::eof()))
-				_serial.print((char_type)c);
-
-			return traits::not_eof(c);
-		}
-
-		
-	/*
-	 * peek at a char where possible
-	 */
-
-		virtual int_type underflow(){
-			if(_serial.available())
-				return _serial.peek();
-			else 
-				return traits::eof();
-		}
-
-	/*
-	 * Read a char where possible
-	 */
-
-		virtual int_type uflow(){
-			if(_serial.available())
-				return _serial.read();
-			else 
-				return traits::eof();
-		}
-
-	/*
-	 * Our wrapped arduino class
-	 */
-
-		Tserial _serial;
-	};
-
-
-/*
- * Input stream
- */
-
-	template <class charT, class traits, class Tserial> class basic_iserialstream
-		: public basic_istream<charT,traits>
-	{
-	public:
-
-	/*
-	 * Types used here
-	 */
-
-		typedef charT char_type;
-
-	/*
-	 * Constructor - default the serial object to #1
-	 * Mega users can explicity initialise with one of
-	 * the others
-	 */
-
-		explicit basic_iserialstream(Tserial& serial_)
-			: basic_ios<charT, traits>(&sb), basic_istream<charT,traits>(&sb), sb(serial_,ios_base::in)
-		{
-		}
-
-	/*
-	 * Required to maintain the chain
-	 */
-
-		virtual ~basic_iserialstream() {  }
-		
-	/*
-	 * Initialise the baud rate
-	 */
-
-		void begin(long speed_) {
-			sb.serial().begin(speed_);
-		}
-		
-	/*
-	 * The wrapped object
-	 */
-
-	private:
-		basic_serialbuf<charT,traits,Tserial> sb;
-	};
-
-
-/*
- * Output stream
- */
-
-	template <class charT, class traits, class Tserial> class basic_oserialstream
-		: public basic_ostream<charT,traits>
-	{
-	public:
-
-	/*
-	 * Types used here
-	 */
-
-		typedef charT char_type;
-
-		/*
-		 * Constructor - default the serial object to #1
-		 * Mega users can explicity initialise with one of
-		 * the others
-		 */
-
-		explicit basic_oserialstream(Tserial& serial_)
-			: basic_ios<charT, traits>(&sb), basic_ostream<charT,traits>(&sb), sb(serial_,ios_base::out)
-		{
-		}
-		
-		/*
-		 * Required to maintain the chain
-		 */
-
-		virtual ~basic_oserialstream() {  }
-
-		/*
-		 * Initialise the baud rate
-		 */
-
-		void begin(long speed_) {
-			sb.serial().begin(speed_);
-		}
-		
-	/*
-	 * The wrapped object
-	 */
-
-	private:
-		basic_serialbuf<charT,traits,Tserial> sb;
-	};
-
-
-/*
- * Input/output stream
- */
-
-	template <class charT, class traits, class Tserial> class basic_ioserialstream
-		 : public basic_iostream<charT,traits>
-	{
-	public:
-
-	/*
-	 * Types used here
-	 */
-
-		typedef charT char_type;
-
-		/*
-		 * Constructor - default the serial object to #1
-		 * Mega users can explicity initialise with one of
-		 * the others
-		 */
-
-		explicit basic_ioserialstream(Tserial& serial_)
-			: basic_ios<charT, traits>(&sb), basic_iostream<charT,traits>(&sb), sb(serial_,ios_base::in | ios_base::out)
-		{
-		}
-
-		/*
-		 * Required to maintain the chain
-		 */
-
-		virtual ~basic_ioserialstream(){  }
-
-		/*
-		 * Initialise the baud rate
-		 */
-
-		void begin(long speed_) {
-			sb.serial().begin(speed_);
-		}
-		
-	/*
-	 * The wrapped object
-	 */
-
-	private:
-		basic_serialbuf<charT, traits, Tserial> sb;
-	};
-}
-
-
-#endif
diff --git a/lib/include/stl/set b/lib/include/stl/set
deleted file mode 100644
index c836c45..0000000
--- a/lib/include/stl/set
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_SET
-#define __SGI_STL_SET
-
-#ifndef __SGI_STL_INTERNAL_TREE_H
-#include <stl_tree.h>
-#endif
-#include <stl_set.h>
-#include <stl_multiset.h>
-
-#endif /* __SGI_STL_SET */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/slist b/lib/include/stl/slist
deleted file mode 100644
index c3ec742..0000000
--- a/lib/include/stl/slist
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef __SGI_STL_SLIST
-#define __SGI_STL_SLIST
-
-#include <stl_algobase.h>
-#include <stl_alloc.h>
-#include <stl_construct.h>
-#include <stl_uninitialized.h>
-#include <stl_slist.h>
-
-#endif /* __SGI_STL_SLIST */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/sstream b/lib/include/stl/sstream
deleted file mode 100644
index 2969853..0000000
--- a/lib/include/stl/sstream
+++ /dev/null
@@ -1,384 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <basic_definitions>
-
-#ifndef HEADER_STD_SSTREAM
-#define HEADER_STD_SSTREAM 1
-
-#include <iosfwd>
-#include <ios>
-#include <istream>
-#include <ostream>
-#include <iostream>
-#include <string>
-
-#pragma GCC visibility push(default)
-
-namespace std{
-
-	template <class charT, class traits, class Allocator>
-		class _UCXXEXPORT basic_stringbuf : public basic_streambuf<charT,traits>
-	{
-	public:
-		typedef charT char_type;
-		typedef typename traits::int_type int_type;
-		typedef typename traits::pos_type pos_type;
-		typedef typename traits::off_type off_type;
-		typedef typename Allocator::size_type size_type;
-
-		explicit _UCXXEXPORT basic_stringbuf(ios_base::openmode which = ios_base::in | ios_base::out)
-			: data(), ielement(0), oelement(0)
-		{
-			basic_streambuf<charT,traits>::openedFor = which;
-		}
-
-		explicit _UCXXEXPORT basic_stringbuf(const basic_string<charT,traits,Allocator>& str,
-			ios_base::openmode which = ios_base::in | ios_base::out)
-			: data(str), ielement(0), oelement(0)
-		{
-			if(which & ios_base::ate){
-				oelement = data.length();
-			}
-			basic_streambuf<charT,traits>::openedFor = which;
-		}
-
-		virtual _UCXXEXPORT ~basic_stringbuf() { }
-
-		_UCXXEXPORT basic_string<charT,traits,Allocator> str() const{
-			return data;
-		}
-
-		_UCXXEXPORT void str(const basic_string<charT,traits,Allocator>& s){
-			data = s;
-			ielement = 0;
-			if(basic_streambuf<charT,traits>::openedFor & ios_base::ate){
-				oelement = data.length();
-			}else{
-				oelement = 0;
-			}
-		}
-
-	protected:
-		virtual _UCXXEXPORT int sync(){
-			return 0;
-		}
-		virtual _UCXXEXPORT int_type underflow(){
-			if(ielement >= data.length()){
-				return traits::eof();
-			}
-			return traits::to_int_type(data[ielement]);
-		}
-
-		virtual _UCXXEXPORT int_type uflow(){
-			int_type retval = underflow();
-			if(retval != traits::eof()){
-				++ielement;
-			}
-			return retval;	
-		}
-
-		virtual _UCXXEXPORT int_type   pbackfail(int_type c = traits::eof()){
-			//Error possibilities
-			if(ielement == 0){
-				return traits::eof();
-			}
-			if(ielement > data.length()){
-				ielement = data.length();
-				return traits::eof();
-			}
-			//eof passed in
-			if(traits::eq_int_type(c,traits::eof())==true){
-				--ielement;
-				return traits::not_eof(c);
-			}
-			if(traits::eq(traits::to_char_type(c),data[ielement-1]) == true){
-				--ielement;
-				return c;
-			}
-			if(basic_streambuf<charT,traits>::openedFor & ios_base::out){
-				--ielement;
-				data[ielement] = c;
-				return c;
-			}
-			return traits::eof();
-		}
-
-		virtual _UCXXEXPORT int showmanyc(){
-			return data.length() - ielement;
-		}
-		virtual _UCXXEXPORT streamsize xsgetn(char_type* c, streamsize n){
-			streamsize i = 0;
-			while(ielement < data.length() && i < n ){
-				c[i] = data[ielement];
-				++i;
-				++ielement;
-			}
-			return i;
-		}
-
-		virtual _UCXXEXPORT int_type overflow (int_type c = traits::eof()){
-			//Nothing to do
-			if(traits::eq_int_type(c,traits::eof())){
-				return traits::not_eof(c);
-			}
-
-			//Actually add character, if possible
-			if(basic_streambuf<charT,traits>::openedFor & ios_base::out){
-				if(oelement >= data.length()){
-					data.push_back(c);
-				}else{
-					data[oelement] = c;
-				}
-				++oelement;
-				return c;
-			}
-			//Not possible
-			return traits::eof();
-		}
-
-		virtual _UCXXEXPORT basic_streambuf<charT,traits>* setbuf(charT*, streamsize){
-			//This function does nothing
-			return this;
-		}
-
-		virtual _UCXXEXPORT streamsize xsputn(const char_type* s, streamsize n){
-			data.replace(oelement, n, s, n);
-			oelement += n;
-			return n;
-		}
-
-		virtual _UCXXEXPORT pos_type seekoff(off_type off, ios_base::seekdir way,
-			ios_base::openmode which = ios_base::in | ios_base::out)
-		{
-			//Test for invalid option
-			if( (which & ios_base::in) && (which & ios_base::out) && (way == ios_base::cur)){
-				return -1;
-			}
-
-			//Calculate new location
-			size_type newpos = 0;
-
-			if(way == ios_base::beg){
-				newpos = off;
-			}else if(way == ios_base::cur){
-				if(which & ios_base::out){
-					newpos = data.length() + off;
-				}
-				if(which & ios_base::in){
-					newpos = ielement + off;
-				}
-				
-			}else{
-				newpos = data.length() + off;
-			}
-
-			//Test for error conditions
-			if(newpos > data.length()){
-				return -1;
-			}
-
-			//Shuffle pointers
-
-			if(which & ios_base::in){
-				ielement = newpos;
-			}
-			if(which & ios_base::out){
-				data.resize(newpos);
-				if(ielement > data.length()){
-					ielement = data.length();
-				}
-			}
-
-			return newpos;
-		}
-			
-		virtual _UCXXEXPORT pos_type seekpos(pos_type sp, 
-			ios_base::openmode which = ios_base::in | ios_base::out)
-		{
-			return seekoff(sp, ios_base::beg, which);
-		}
-
-		basic_string<charT,traits,Allocator> data;
-		size_type ielement;
-		size_type oelement;
-	};
-
-
-	template <class charT, class traits, class Allocator> class _UCXXEXPORT basic_istringstream
-		: public basic_istream<charT,traits>
-	{
-	public:
-		typedef charT char_type;
-		typedef typename traits::int_type int_type;
-		typedef typename traits::pos_type pos_type;
-		typedef typename traits::off_type off_type;
-
-
-		explicit _UCXXEXPORT basic_istringstream(ios_base::openmode m = ios_base::in) 
-			: basic_ios<charT, traits>(&sb), basic_istream<charT,traits>(&sb), sb(m)
-		{
-		}
-		explicit _UCXXEXPORT basic_istringstream( const basic_string<charT,traits,Allocator>& str, 
-			ios_base::openmode which = ios_base::in) 
-			: basic_ios<charT, traits>(&sb), basic_istream<charT,traits>(&sb), sb(str, which)
-		{
-		}
-		virtual _UCXXEXPORT ~basic_istringstream() {  }
-		_UCXXEXPORT basic_stringbuf<charT,traits,Allocator>* rdbuf() const{
-			return &sb;
-		}
-		_UCXXEXPORT basic_string<charT,traits,Allocator> str() const{
-			return sb.str();
-		}
-		_UCXXEXPORT void str(const basic_string<charT,traits,Allocator>& s){
-			sb.str(s);
-			basic_istream<charT,traits>::clear();
-		}
-	private:
-		basic_stringbuf<charT,traits,Allocator> sb;
-	};
-
-
-	template <class charT, class traits, class Allocator> class _UCXXEXPORT basic_ostringstream
-		: public basic_ostream<charT,traits>
-	{
-	public:
-
-		typedef charT char_type;
-		typedef typename traits::int_type int_type;
-		typedef typename traits::pos_type pos_type;
-		typedef typename traits::off_type off_type;
-
-		explicit _UCXXEXPORT basic_ostringstream(ios_base::openmode m = ios_base::out)
-			: basic_ios<charT, traits>(&sb), basic_ostream<charT,traits>(&sb), sb(m)
-		{
-		}
-		explicit _UCXXEXPORT basic_ostringstream(const basic_string<charT,traits,Allocator>& str, 
-			ios_base::openmode which = ios_base::out)
-			: basic_ios<charT, traits>(&sb), basic_ostream<charT,traits>(&sb), sb(str, which)
-		{
-		}
-		virtual _UCXXEXPORT ~basic_ostringstream() {  }
-
-		_UCXXEXPORT basic_stringbuf<charT,traits,Allocator>* rdbuf() const{
-			return &sb;
-		}
-		_UCXXEXPORT basic_string<charT,traits,Allocator> str() const{
-			return sb.str();
-		}
-		_UCXXEXPORT void str(const basic_string<charT,traits,Allocator>& s){
-			sb.str(s);
-			basic_ostream<charT,traits>::clear();
-		}
-	private:
-		basic_stringbuf<charT,traits,Allocator> sb;
-	};
-
-
-	template <class charT, class traits, class Allocator> class _UCXXEXPORT basic_stringstream
-		 : public basic_iostream<charT,traits>
-	{
-	public:
-
-		typedef charT char_type;
-		typedef typename traits::int_type int_type;
-		typedef typename traits::pos_type pos_type;
-		typedef typename traits::off_type off_type;
-
-		explicit _UCXXEXPORT basic_stringstream(ios_base::openmode which = ios_base::out|ios_base::in)
-			: basic_ios<charT, traits>(&sb), basic_iostream<charT,traits>(&sb), sb(which)
-		{
-		}
-
-		explicit _UCXXEXPORT basic_stringstream(const basic_string<charT,traits,Allocator>& str,
-			ios_base::openmode which = ios_base::out|ios_base::in)
-			: basic_ios<charT, traits>(&sb), basic_iostream<charT,traits>(&sb), sb(str, which)
-		{
-		}
-		virtual _UCXXEXPORT ~basic_stringstream(){  }
-
-		_UCXXEXPORT basic_stringbuf<charT,traits,Allocator>* rdbuf(){
-			return &sb;
-		}
-		_UCXXEXPORT basic_string<charT,traits,Allocator> str() const{
-			return sb.str();
-		}
-		_UCXXEXPORT void str(const basic_string<charT,traits,Allocator>& s){
-			sb.str(s);
-			basic_iostream<charT,traits>::clear();
-		}
-	private:
-		basic_stringbuf<charT, traits> sb;
-	};
-
-#ifdef __UCLIBCXX_EXPAND_SSTREAM_CHAR__
-#ifndef __UCLIBCXX_COMPILE_SSTREAM__
-
-#ifdef __UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-
-	template <> _UCXXEXPORT basic_stringbuf<char, char_traits<char>, allocator<char> >::
-		basic_stringbuf(ios_base::openmode which);
-	template <> _UCXXEXPORT basic_stringbuf<char, char_traits<char>, allocator<char> >::~basic_stringbuf();
-
-#endif // __UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-
-	template <> _UCXXEXPORT basic_string<char, char_traits<char>, allocator<char> >
-		basic_stringbuf<char, char_traits<char>, allocator<char> >::str() const;
-
-	template <> _UCXXEXPORT basic_stringbuf<char, char_traits<char>, allocator<char> >::int_type
-		basic_stringbuf<char, char_traits<char>, allocator<char> >::
-			pbackfail(basic_stringbuf<char, char_traits<char>, allocator<char> >::int_type c);
-
-	template <> _UCXXEXPORT basic_stringbuf<char, char_traits<char>, allocator<char> >::pos_type
-		basic_stringbuf<char, char_traits<char>, allocator<char> >::
-			seekoff (basic_stringbuf<char, char_traits<char>, allocator<char> >::off_type off,
-				ios_base::seekdir way,
-				ios_base::openmode which
-			);
-
-	template <> _UCXXEXPORT basic_stringbuf<char, char_traits<char>, allocator<char> >::int_type
-		basic_stringbuf<char, char_traits<char>, allocator<char> >::
-			overflow (basic_stringbuf<char, char_traits<char>, allocator<char> >::int_type c);
-
-	template <> _UCXXEXPORT basic_stringbuf<char, char_traits<char>, allocator<char> >::int_type
-		basic_stringbuf<char, char_traits<char>, allocator<char> >::underflow ();
-
-	template <> _UCXXEXPORT streamsize basic_stringbuf<char, char_traits<char>, allocator<char> >::
-		xsputn(const char* s, streamsize n);
-
-#ifdef __UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-
-	template <> _UCXXEXPORT basic_stringstream<char, char_traits<char>, allocator<char> >::
-		basic_stringstream(ios_base::openmode which);
-	template <> _UCXXEXPORT basic_stringstream<char, char_traits<char>, allocator<char> >::~basic_stringstream();
-	template <> _UCXXEXPORT basic_istringstream<char, char_traits<char>, allocator<char> >::~basic_istringstream();
-	template <> _UCXXEXPORT basic_ostringstream<char, char_traits<char>, allocator<char> >::~basic_ostringstream();
-
-#endif //__UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-
-#endif
-#endif
-
-#pragma GCC visibility pop
-
-}
-
-
-#endif
diff --git a/lib/include/stl/stack b/lib/include/stl/stack
deleted file mode 100644
index 36461d9..0000000
--- a/lib/include/stl/stack
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_STACK
-#define __SGI_STL_STACK
-
-#include <stl_algobase.h>
-#include <stl_alloc.h>
-#include <stl_construct.h>
-#include <stl_uninitialized.h>
-#include <stl_deque.h>
-#include <stl_stack.h>
-
-#endif /* __SGI_STL_STACK */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_algo.h b/lib/include/stl/stl_algo.h
deleted file mode 100644
index 25c54ee..0000000
--- a/lib/include/stl/stl_algo.h
+++ /dev/null
@@ -1,3297 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_ALGO_H
-#define __SGI_STL_INTERNAL_ALGO_H
-
-#include <stl_heap.h>
-
-// See concept_checks.h for the concept-checking macros 
-// __STL_REQUIRES, __STL_CONVERTIBLE, etc.
-
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1209
-#endif
-
-// __median (an extension, not present in the C++ standard).
-
-template <class _Tp>
-inline const _Tp& __median(const _Tp& __a, const _Tp& __b, const _Tp& __c) {
-  __STL_REQUIRES(_Tp, _LessThanComparable);
-  if (__a < __b)
-    if (__b < __c)
-      return __b;
-    else if (__a < __c)
-      return __c;
-    else
-      return __a;
-  else if (__a < __c)
-    return __a;
-  else if (__b < __c)
-    return __c;
-  else
-    return __b;
-}
-
-template <class _Tp, class _Compare>
-inline const _Tp&
-__median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp) {
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);
-  if (__comp(__a, __b))
-    if (__comp(__b, __c))
-      return __b;
-    else if (__comp(__a, __c))
-      return __c;
-    else
-      return __a;
-  else if (__comp(__a, __c))
-    return __a;
-  else if (__comp(__b, __c))
-    return __c;
-  else
-    return __b;
-}
-
-// for_each.  Apply a function to every element of a range.
-template <class _InputIter, class _Function>
-_Function for_each(_InputIter __first, _InputIter __last, _Function __f) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  for ( ; __first != __last; ++__first)
-    __f(*__first);
-  return __f;
-}
-
-// find and find_if.
-
-template <class _InputIter, class _Tp>
-inline _InputIter find(_InputIter __first, _InputIter __last,
-                       const _Tp& __val,
-                       input_iterator_tag)
-{
-  while (__first != __last && !(*__first == __val))
-    ++__first;
-  return __first;
-}
-
-template <class _InputIter, class _Predicate>
-inline _InputIter find_if(_InputIter __first, _InputIter __last,
-                          _Predicate __pred,
-                          input_iterator_tag)
-{
-  while (__first != __last && !__pred(*__first))
-    ++__first;
-  return __first;
-}
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _RandomAccessIter, class _Tp>
-_RandomAccessIter find(_RandomAccessIter __first, _RandomAccessIter __last,
-                       const _Tp& __val,
-                       random_access_iterator_tag)
-{
-  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count
-    = (__last - __first) >> 2;
-
-  for ( ; __trip_count > 0 ; --__trip_count) {
-    if (*__first == __val) return __first;
-    ++__first;
-
-    if (*__first == __val) return __first;
-    ++__first;
-
-    if (*__first == __val) return __first;
-    ++__first;
-
-    if (*__first == __val) return __first;
-    ++__first;
-  }
-
-  switch(__last - __first) {
-  case 3:
-    if (*__first == __val) return __first;
-    ++__first;
-  case 2:
-    if (*__first == __val) return __first;
-    ++__first;
-  case 1:
-    if (*__first == __val) return __first;
-    ++__first;
-  case 0:
-  default:
-    return __last;
-  }
-}
-
-template <class _RandomAccessIter, class _Predicate>
-_RandomAccessIter find_if(_RandomAccessIter __first, _RandomAccessIter __last,
-                          _Predicate __pred,
-                          random_access_iterator_tag)
-{
-  typename iterator_traits<_RandomAccessIter>::difference_type __trip_count
-    = (__last - __first) >> 2;
-
-  for ( ; __trip_count > 0 ; --__trip_count) {
-    if (__pred(*__first)) return __first;
-    ++__first;
-
-    if (__pred(*__first)) return __first;
-    ++__first;
-
-    if (__pred(*__first)) return __first;
-    ++__first;
-
-    if (__pred(*__first)) return __first;
-    ++__first;
-  }
-
-  switch(__last - __first) {
-  case 3:
-    if (__pred(*__first)) return __first;
-    ++__first;
-  case 2:
-    if (__pred(*__first)) return __first;
-    ++__first;
-  case 1:
-    if (__pred(*__first)) return __first;
-    ++__first;
-  case 0:
-  default:
-    return __last;
-  }
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _InputIter, class _Tp>
-inline _InputIter find(_InputIter __first, _InputIter __last,
-                       const _Tp& __val)
-{
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool, 
-            typename iterator_traits<_InputIter>::value_type, _Tp);
-  return find(__first, __last, __val, __ITERATOR_CATEGORY(__first));
-}
-
-template <class _InputIter, class _Predicate>
-inline _InputIter find_if(_InputIter __first, _InputIter __last,
-                          _Predicate __pred) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,
-          typename iterator_traits<_InputIter>::value_type);
-  return find_if(__first, __last, __pred, __ITERATOR_CATEGORY(__first));
-}
-
-// adjacent_find.
-
-template <class _ForwardIter>
-_ForwardIter adjacent_find(_ForwardIter __first, _ForwardIter __last) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,
-                 _EqualityComparable);
-  if (__first == __last)
-    return __last;
-  _ForwardIter __next = __first;
-  while(++__next != __last) {
-    if (*__first == *__next)
-      return __first;
-    __first = __next;
-  }
-  return __last;
-}
-
-template <class _ForwardIter, class _BinaryPredicate>
-_ForwardIter adjacent_find(_ForwardIter __first, _ForwardIter __last,
-                           _BinaryPredicate __binary_pred) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool,
-          typename iterator_traits<_ForwardIter>::value_type,
-          typename iterator_traits<_ForwardIter>::value_type);
-  if (__first == __last)
-    return __last;
-  _ForwardIter __next = __first;
-  while(++__next != __last) {
-    if (__binary_pred(*__first, *__next))
-      return __first;
-    __first = __next;
-  }
-  return __last;
-}
-
-// count and count_if.  There are two version of each, one whose return type
-// type is void and one (present only if we have partial specialization)
-// whose return type is iterator_traits<_InputIter>::difference_type.  The
-// C++ standard only has the latter version, but the former, which was present
-// in the HP STL, is retained for backward compatibility.
-
-template <class _InputIter, class _Tp, class _Size>
-void count(_InputIter __first, _InputIter __last, const _Tp& __value,
-           _Size& __n) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(typename iterator_traits<_InputIter>::value_type,
-                 _EqualityComparable);
-  __STL_REQUIRES(_Tp, _EqualityComparable);
-  for ( ; __first != __last; ++__first)
-    if (*__first == __value)
-      ++__n;
-}
-
-template <class _InputIter, class _Predicate, class _Size>
-void count_if(_InputIter __first, _InputIter __last, _Predicate __pred,
-              _Size& __n) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool, 
-                  typename iterator_traits<_InputIter>::value_type);
-  for ( ; __first != __last; ++__first)
-    if (__pred(*__first))
-      ++__n;
-}
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _InputIter, class _Tp>
-typename iterator_traits<_InputIter>::difference_type
-count(_InputIter __first, _InputIter __last, const _Tp& __value) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(typename iterator_traits<_InputIter>::value_type,
-                 _EqualityComparable);
-  __STL_REQUIRES(_Tp, _EqualityComparable);
-  typename iterator_traits<_InputIter>::difference_type __n = 0;
-  for ( ; __first != __last; ++__first)
-    if (*__first == __value)
-      ++__n;
-  return __n;
-}
-
-template <class _InputIter, class _Predicate>
-typename iterator_traits<_InputIter>::difference_type
-count_if(_InputIter __first, _InputIter __last, _Predicate __pred) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool, 
-                  typename iterator_traits<_InputIter>::value_type);
-  typename iterator_traits<_InputIter>::difference_type __n = 0;
-  for ( ; __first != __last; ++__first)
-    if (__pred(*__first))
-      ++__n;
-  return __n;
-}
-
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-// search.
-
-template <class _ForwardIter1, class _ForwardIter2>
-_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
-                     _ForwardIter2 __first2, _ForwardIter2 __last2) 
-{
-  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);
-  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);
-  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,
-   typename iterator_traits<_ForwardIter1>::value_type,
-   typename iterator_traits<_ForwardIter2>::value_type);
-
-  // Test for empty ranges
-  if (__first1 == __last1 || __first2 == __last2)
-    return __first1;
-
-  // Test for a pattern of length 1.
-  _ForwardIter2 __tmp(__first2);
-  ++__tmp;
-  if (__tmp == __last2)
-    return find(__first1, __last1, *__first2);
-
-  // General case.
-
-  _ForwardIter2 __p1, __p;
-
-  __p1 = __first2; ++__p1;
-
-  _ForwardIter1 __current = __first1;
-
-  while (__first1 != __last1) {
-    __first1 = find(__first1, __last1, *__first2);
-    if (__first1 == __last1)
-      return __last1;
-
-    __p = __p1;
-    __current = __first1; 
-    if (++__current == __last1)
-      return __last1;
-
-    while (*__current == *__p) {
-      if (++__p == __last2)
-        return __first1;
-      if (++__current == __last1)
-        return __last1;
-    }
-
-    ++__first1;
-  }
-  return __first1;
-}
-
-template <class _ForwardIter1, class _ForwardIter2, class _BinaryPred>
-_ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,
-                     _ForwardIter2 __first2, _ForwardIter2 __last2,
-                     _BinaryPred  __predicate) 
-{
-  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);
-  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);
-  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, bool,
-   typename iterator_traits<_ForwardIter1>::value_type,
-   typename iterator_traits<_ForwardIter2>::value_type);
-
-  // Test for empty ranges
-  if (__first1 == __last1 || __first2 == __last2)
-    return __first1;
-
-  // Test for a pattern of length 1.
-  _ForwardIter2 __tmp(__first2);
-  ++__tmp;
-  if (__tmp == __last2) {
-    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
-      ++__first1;
-    return __first1;    
-  }
-
-  // General case.
-
-  _ForwardIter2 __p1, __p;
-
-  __p1 = __first2; ++__p1;
-
-  _ForwardIter1 __current = __first1;
-
-  while (__first1 != __last1) {
-    while (__first1 != __last1) {
-      if (__predicate(*__first1, *__first2))
-        break;
-      ++__first1;
-    }
-    while (__first1 != __last1 && !__predicate(*__first1, *__first2))
-      ++__first1;
-    if (__first1 == __last1)
-      return __last1;
-
-    __p = __p1;
-    __current = __first1; 
-    if (++__current == __last1) return __last1;
-
-    while (__predicate(*__current, *__p)) {
-      if (++__p == __last2)
-        return __first1;
-      if (++__current == __last1)
-        return __last1;
-    }
-
-    ++__first1;
-  }
-  return __first1;
-}
-
-// search_n.  Search for __count consecutive copies of __val.
-
-template <class _ForwardIter, class _Integer, class _Tp>
-_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
-                      _Integer __count, const _Tp& __val) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,
-                 _EqualityComparable);
-  __STL_REQUIRES(_Tp, _EqualityComparable);
-
-  if (__count <= 0)
-    return __first;
-  else {
-    __first = find(__first, __last, __val);
-    while (__first != __last) {
-      _Integer __n = __count - 1;
-      _ForwardIter __i = __first;
-      ++__i;
-      while (__i != __last && __n != 0 && *__i == __val) {
-        ++__i;
-        --__n;
-      }
-      if (__n == 0)
-        return __first;
-      else
-        __first = find(__i, __last, __val);
-    }
-    return __last;
-  }
-}
-
-template <class _ForwardIter, class _Integer, class _Tp, class _BinaryPred>
-_ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,
-                      _Integer __count, const _Tp& __val,
-                      _BinaryPred __binary_pred) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_BINARY_FUNCTION_CHECK(_BinaryPred, bool, 
-             typename iterator_traits<_ForwardIter>::value_type, _Tp);
-  if (__count <= 0)
-    return __first;
-  else {
-    while (__first != __last) {
-      if (__binary_pred(*__first, __val))
-        break;
-      ++__first;
-    }
-    while (__first != __last) {
-      _Integer __n = __count - 1;
-      _ForwardIter __i = __first;
-      ++__i;
-      while (__i != __last && __n != 0 && __binary_pred(*__i, __val)) {
-        ++__i;
-        --__n;
-      }
-      if (__n == 0)
-        return __first;
-      else {
-        while (__i != __last) {
-          if (__binary_pred(*__i, __val))
-            break;
-          ++__i;
-        }
-        __first = __i;
-      }
-    }
-    return __last;
-  }
-} 
-
-// swap_ranges
-
-template <class _ForwardIter1, class _ForwardIter2>
-_ForwardIter2 swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1,
-                          _ForwardIter2 __first2) {
-  __STL_REQUIRES(_ForwardIter1, _Mutable_ForwardIterator);
-  __STL_REQUIRES(_ForwardIter2, _Mutable_ForwardIterator);
-  __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter1>::value_type,
-                    typename iterator_traits<_ForwardIter2>::value_type);
-  __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter2>::value_type,
-                    typename iterator_traits<_ForwardIter1>::value_type);
-  for ( ; __first1 != __last1; ++__first1, ++__first2)
-    iter_swap(__first1, __first2);
-  return __first2;
-}
-
-// transform
-
-template <class _InputIter, class _OutputIter, class _UnaryOperation>
-_OutputIter transform(_InputIter __first, _InputIter __last,
-                      _OutputIter __result, _UnaryOperation __opr) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-
-  for ( ; __first != __last; ++__first, ++__result)
-    *__result = __opr(*__first);
-  return __result;
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter,
-          class _BinaryOperation>
-_OutputIter transform(_InputIter1 __first1, _InputIter1 __last1,
-                      _InputIter2 __first2, _OutputIter __result,
-                      _BinaryOperation __binary_op) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)
-    *__result = __binary_op(*__first1, *__first2);
-  return __result;
-}
-
-// replace, replace_if, replace_copy, replace_copy_if
-
-template <class _ForwardIter, class _Tp>
-void replace(_ForwardIter __first, _ForwardIter __last,
-             const _Tp& __old_value, const _Tp& __new_value) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,
-         typename iterator_traits<_ForwardIter>::value_type, _Tp);
-  __STL_CONVERTIBLE(_Tp, typename iterator_traits<_ForwardIter>::value_type);
-  for ( ; __first != __last; ++__first)
-    if (*__first == __old_value)
-      *__first = __new_value;
-}
-
-template <class _ForwardIter, class _Predicate, class _Tp>
-void replace_if(_ForwardIter __first, _ForwardIter __last,
-                _Predicate __pred, const _Tp& __new_value) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  __STL_CONVERTIBLE(_Tp, typename iterator_traits<_ForwardIter>::value_type);
-  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,
-             typename iterator_traits<_ForwardIter>::value_type);
-  for ( ; __first != __last; ++__first)
-    if (__pred(*__first))
-      *__first = __new_value;
-}
-
-template <class _InputIter, class _OutputIter, class _Tp>
-_OutputIter replace_copy(_InputIter __first, _InputIter __last,
-                         _OutputIter __result,
-                         const _Tp& __old_value, const _Tp& __new_value) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,
-         typename iterator_traits<_InputIter>::value_type, _Tp);
-  for ( ; __first != __last; ++__first, ++__result)
-    *__result = *__first == __old_value ? __new_value : *__first;
-  return __result;
-}
-
-template <class _InputIter, class _OutputIter, class _Predicate, class _Tp>
-_OutputIter replace_copy_if(_InputIter __first, _InputIter __last,
-                            _OutputIter __result,
-                            _Predicate __pred, const _Tp& __new_value) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,
-                typename iterator_traits<_InputIter>::value_type);
-  for ( ; __first != __last; ++__first, ++__result)
-    *__result = __pred(*__first) ? __new_value : *__first;
-  return __result;
-}
-
-// generate and generate_n
-
-template <class _ForwardIter, class _Generator>
-void generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_GENERATOR_CHECK(_Generator, 
-          typename iterator_traits<_ForwardIter>::value_type);
-  for ( ; __first != __last; ++__first)
-    *__first = __gen();
-}
-
-template <class _OutputIter, class _Size, class _Generator>
-_OutputIter generate_n(_OutputIter __first, _Size __n, _Generator __gen) {
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  for ( ; __n > 0; --__n, ++__first)
-    *__first = __gen();
-  return __first;
-}
-
-// remove, remove_if, remove_copy, remove_copy_if
-
-template <class _InputIter, class _OutputIter, class _Tp>
-_OutputIter remove_copy(_InputIter __first, _InputIter __last,
-                        _OutputIter __result, const _Tp& __value) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,
-       typename iterator_traits<_InputIter>::value_type, _Tp);
-  for ( ; __first != __last; ++__first)
-    if (!(*__first == __value)) {
-      *__result = *__first;
-      ++__result;
-    }
-  return __result;
-}
-
-template <class _InputIter, class _OutputIter, class _Predicate>
-_OutputIter remove_copy_if(_InputIter __first, _InputIter __last,
-                           _OutputIter __result, _Predicate __pred) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,
-             typename iterator_traits<_InputIter>::value_type);
-  for ( ; __first != __last; ++__first)
-    if (!__pred(*__first)) {
-      *__result = *__first;
-      ++__result;
-    }
-  return __result;
-}
-
-template <class _ForwardIter, class _Tp>
-_ForwardIter remove(_ForwardIter __first, _ForwardIter __last,
-                    const _Tp& __value) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,
-       typename iterator_traits<_ForwardIter>::value_type, _Tp);
-  __STL_CONVERTIBLE(_Tp, typename iterator_traits<_ForwardIter>::value_type);
-  __first = find(__first, __last, __value);
-  _ForwardIter __i = __first;
-  return __first == __last ? __first 
-                           : remove_copy(++__i, __last, __first, __value);
-}
-
-template <class _ForwardIter, class _Predicate>
-_ForwardIter remove_if(_ForwardIter __first, _ForwardIter __last,
-                       _Predicate __pred) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,
-               typename iterator_traits<_ForwardIter>::value_type);
-  __first = find_if(__first, __last, __pred);
-  _ForwardIter __i = __first;
-  return __first == __last ? __first 
-                           : remove_copy_if(++__i, __last, __first, __pred);
-}
-
-// unique and unique_copy
-
-template <class _InputIter, class _OutputIter, class _Tp>
-_OutputIter __unique_copy(_InputIter __first, _InputIter __last,
-                          _OutputIter __result, _Tp*) {
-  _Tp __value = *__first;
-  *__result = __value;
-  while (++__first != __last)
-    if (!(__value == *__first)) {
-      __value = *__first;
-      *++__result = __value;
-    }
-  return ++__result;
-}
-
-template <class _InputIter, class _OutputIter>
-inline _OutputIter __unique_copy(_InputIter __first, _InputIter __last,
-                                 _OutputIter __result, 
-                                 output_iterator_tag) {
-  return __unique_copy(__first, __last, __result, __VALUE_TYPE(__first));
-}
-
-template <class _InputIter, class _ForwardIter>
-_ForwardIter __unique_copy(_InputIter __first, _InputIter __last,
-                           _ForwardIter __result, forward_iterator_tag) {
-  *__result = *__first;
-  while (++__first != __last)
-    if (!(*__result == *__first))
-      *++__result = *__first;
-  return ++__result;
-}
-
-template <class _InputIter, class _OutputIter>
-inline _OutputIter unique_copy(_InputIter __first, _InputIter __last,
-                               _OutputIter __result) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES(typename iterator_traits<_InputIter>::value_type,
-                 _EqualityComparable);
-  if (__first == __last) return __result;
-  return __unique_copy(__first, __last, __result,
-                       __ITERATOR_CATEGORY(__result));
-}
-
-template <class _InputIter, class _OutputIter, class _BinaryPredicate,
-          class _Tp>
-_OutputIter __unique_copy(_InputIter __first, _InputIter __last,
-                          _OutputIter __result,
-                          _BinaryPredicate __binary_pred, _Tp*) {
-  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool, _Tp, _Tp);
-  _Tp __value = *__first;
-  *__result = __value;
-  while (++__first != __last)
-    if (!__binary_pred(__value, *__first)) {
-      __value = *__first;
-      *++__result = __value;
-    }
-  return ++__result;
-}
-
-template <class _InputIter, class _OutputIter, class _BinaryPredicate>
-inline _OutputIter __unique_copy(_InputIter __first, _InputIter __last,
-                                 _OutputIter __result,
-                                 _BinaryPredicate __binary_pred,
-                                 output_iterator_tag) {
-  return __unique_copy(__first, __last, __result, __binary_pred,
-                       __VALUE_TYPE(__first));
-}
-
-template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
-_ForwardIter __unique_copy(_InputIter __first, _InputIter __last,
-                           _ForwardIter __result, 
-                           _BinaryPredicate __binary_pred,
-                           forward_iterator_tag) {
-  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool,
-     typename iterator_traits<_ForwardIter>::value_type,
-     typename iterator_traits<_InputIter>::value_type);
-  *__result = *__first;
-  while (++__first != __last)
-    if (!__binary_pred(*__result, *__first)) *++__result = *__first;
-  return ++__result;
-}
-
-template <class _InputIter, class _OutputIter, class _BinaryPredicate>
-inline _OutputIter unique_copy(_InputIter __first, _InputIter __last,
-                               _OutputIter __result,
-                               _BinaryPredicate __binary_pred) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  if (__first == __last) return __result;
-  return __unique_copy(__first, __last, __result, __binary_pred,
-                       __ITERATOR_CATEGORY(__result));
-}
-
-template <class _ForwardIter>
-_ForwardIter unique(_ForwardIter __first, _ForwardIter __last) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,
-                 _EqualityComparable);
-  __first = adjacent_find(__first, __last);
-  return unique_copy(__first, __last, __first);
-}
-
-template <class _ForwardIter, class _BinaryPredicate>
-_ForwardIter unique(_ForwardIter __first, _ForwardIter __last,
-                    _BinaryPredicate __binary_pred) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool, 
-      typename iterator_traits<_ForwardIter>::value_type,
-      typename iterator_traits<_ForwardIter>::value_type);
-  __first = adjacent_find(__first, __last, __binary_pred);
-  return unique_copy(__first, __last, __first, __binary_pred);
-}
-
-// reverse and reverse_copy, and their auxiliary functions
-
-template <class _BidirectionalIter>
-void __reverse(_BidirectionalIter __first, _BidirectionalIter __last, 
-               bidirectional_iterator_tag) {
-  while (true)
-    if (__first == __last || __first == --__last)
-      return;
-    else
-      iter_swap(__first++, __last);
-}
-
-template <class _RandomAccessIter>
-void __reverse(_RandomAccessIter __first, _RandomAccessIter __last,
-               random_access_iterator_tag) {
-  while (__first < __last)
-    iter_swap(__first++, --__last);
-}
-
-template <class _BidirectionalIter>
-inline void reverse(_BidirectionalIter __first, _BidirectionalIter __last) {
-  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);
-  __reverse(__first, __last, __ITERATOR_CATEGORY(__first));
-}
-
-template <class _BidirectionalIter, class _OutputIter>
-_OutputIter reverse_copy(_BidirectionalIter __first,
-                         _BidirectionalIter __last,
-                         _OutputIter __result) {
-  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  while (__first != __last) {
-    --__last;
-    *__result = *__last;
-    ++__result;
-  }
-  return __result;
-}
-
-// rotate and rotate_copy, and their auxiliary functions
-
-template <class _EuclideanRingElement>
-_EuclideanRingElement __gcd(_EuclideanRingElement __m,
-                            _EuclideanRingElement __n)
-{
-  while (__n != 0) {
-    _EuclideanRingElement __t = __m % __n;
-    __m = __n;
-    __n = __t;
-  }
-  return __m;
-}
-
-template <class _ForwardIter, class _Distance>
-_ForwardIter __rotate(_ForwardIter __first,
-                      _ForwardIter __middle,
-                      _ForwardIter __last,
-                      _Distance*,
-                      forward_iterator_tag) {
-  if (__first == __middle)
-    return __last;
-  if (__last  == __middle)
-    return __first;
-
-  _ForwardIter __first2 = __middle;
-  do {
-    swap(*__first++, *__first2++);
-    if (__first == __middle)
-      __middle = __first2;
-  } while (__first2 != __last);
-
-  _ForwardIter __new_middle = __first;
-
-  __first2 = __middle;
-
-  while (__first2 != __last) {
-    swap (*__first++, *__first2++);
-    if (__first == __middle)
-      __middle = __first2;
-    else if (__first2 == __last)
-      __first2 = __middle;
-  }
-
-  return __new_middle;
-}
-
-
-template <class _BidirectionalIter, class _Distance>
-_BidirectionalIter __rotate(_BidirectionalIter __first,
-                            _BidirectionalIter __middle,
-                            _BidirectionalIter __last,
-                            _Distance*,
-                            bidirectional_iterator_tag) {
-  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);
-  if (__first == __middle)
-    return __last;
-  if (__last  == __middle)
-    return __first;
-
-  __reverse(__first,  __middle, bidirectional_iterator_tag());
-  __reverse(__middle, __last,   bidirectional_iterator_tag());
-
-  while (__first != __middle && __middle != __last)
-    swap (*__first++, *--__last);
-
-  if (__first == __middle) {
-    __reverse(__middle, __last,   bidirectional_iterator_tag());
-    return __last;
-  }
-  else {
-    __reverse(__first,  __middle, bidirectional_iterator_tag());
-    return __first;
-  }
-}
-
-template <class _RandomAccessIter, class _Distance, class _Tp>
-_RandomAccessIter __rotate(_RandomAccessIter __first,
-                           _RandomAccessIter __middle,
-                           _RandomAccessIter __last,
-                           _Distance *, _Tp *) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  _Distance __n = __last   - __first;
-  _Distance __k = __middle - __first;
-  _Distance __l = __n - __k;
-  _RandomAccessIter __result = __first + (__last - __middle);
-
-  if (__k == 0)
-    return __last;
-
-  else if (__k == __l) {
-    swap_ranges(__first, __middle, __middle);
-    return __result;
-  }
-
-  _Distance __d = __gcd(__n, __k);
-
-  for (_Distance __i = 0; __i < __d; __i++) {
-    _Tp __tmp = *__first;
-    _RandomAccessIter __p = __first;
-
-    if (__k < __l) {
-      for (_Distance __j = 0; __j < __l/__d; __j++) {
-        if (__p > __first + __l) {
-          *__p = *(__p - __l);
-          __p -= __l;
-        }
-
-        *__p = *(__p + __k);
-        __p += __k;
-      }
-    }
-
-    else {
-      for (_Distance __j = 0; __j < __k/__d - 1; __j ++) {
-        if (__p < __last - __k) {
-          *__p = *(__p + __k);
-          __p += __k;
-        }
-
-        *__p = * (__p - __l);
-        __p -= __l;
-      }
-    }
-
-    *__p = __tmp;
-    ++__first;
-  }
-
-  return __result;
-}
-
-template <class _ForwardIter>
-inline _ForwardIter rotate(_ForwardIter __first, _ForwardIter __middle,
-                           _ForwardIter __last) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  return __rotate(__first, __middle, __last,
-                  __DISTANCE_TYPE(__first),
-                  __ITERATOR_CATEGORY(__first));
-}
-
-template <class _ForwardIter, class _OutputIter>
-_OutputIter rotate_copy(_ForwardIter __first, _ForwardIter __middle,
-                        _ForwardIter __last, _OutputIter __result) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  return copy(__first, __middle, copy(__middle, __last, __result));
-}
-
-// Return a random number in the range [0, __n).  This function encapsulates
-// whether we're using rand (part of the standard C library) or lrand48
-// (not standard, but a much better choice whenever it's available).
-
-template <class _Distance>
-inline _Distance __random_number(_Distance __n) {
-#ifdef __STL_NO_DRAND48
-  return rand() % __n;
-#else
-  return lrand48() % __n;
-#endif
-}
-
-// random_shuffle
-
-template <class _RandomAccessIter>
-inline void random_shuffle(_RandomAccessIter __first,
-                           _RandomAccessIter __last) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  if (__first == __last) return;
-  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
-    iter_swap(__i, __first + __random_number((__i - __first) + 1));
-}
-
-template <class _RandomAccessIter, class _RandomNumberGenerator>
-void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,
-                    _RandomNumberGenerator& __rand) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  if (__first == __last) return;
-  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
-    iter_swap(__i, __first + __rand((__i - __first) + 1));
-}
-
-// random_sample and random_sample_n (extensions, not part of the standard).
-
-template <class _ForwardIter, class _OutputIter, class _Distance>
-_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
-                            _OutputIter __out, const _Distance __n)
-{
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  _Distance __remaining = 0;
-  distance(__first, __last, __remaining);
-  _Distance __m = min(__n, __remaining);
-
-  while (__m > 0) {
-    if (__random_number(__remaining) < __m) {
-      *__out = *__first;
-      ++__out;
-      --__m;
-    }
-
-    --__remaining;
-    ++__first;
-  }
-  return __out;
-}
-
-template <class _ForwardIter, class _OutputIter, class _Distance,
-          class _RandomNumberGenerator>
-_OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,
-                            _OutputIter __out, const _Distance __n,
-                            _RandomNumberGenerator& __rand)
-{
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);
-  _Distance __remaining = 0;
-  distance(__first, __last, __remaining);
-  _Distance __m = min(__n, __remaining);
-
-  while (__m > 0) {
-    if (__rand(__remaining) < __m) {
-      *__out = *__first;
-      ++__out;
-      --__m;
-    }
-
-    --__remaining;
-    ++__first;
-  }
-  return __out;
-}
-
-template <class _InputIter, class _RandomAccessIter, class _Distance>
-_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
-                                  _RandomAccessIter __out,
-                                  const _Distance __n)
-{
-  _Distance __m = 0;
-  _Distance __t = __n;
-  for ( ; __first != __last && __m < __n; ++__m, ++__first) 
-    __out[__m] = *__first;
-
-  while (__first != __last) {
-    ++__t;
-    _Distance __M = __random_number(__t);
-    if (__M < __n)
-      __out[__M] = *__first;
-    ++__first;
-  }
-
-  return __out + __m;
-}
-
-template <class _InputIter, class _RandomAccessIter,
-          class _RandomNumberGenerator, class _Distance>
-_RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,
-                                  _RandomAccessIter __out,
-                                  _RandomNumberGenerator& __rand,
-                                  const _Distance __n)
-{
-  __STL_UNARY_FUNCTION_CHECK(_RandomNumberGenerator, _Distance, _Distance);
-  _Distance __m = 0;
-  _Distance __t = __n;
-  for ( ; __first != __last && __m < __n; ++__m, ++__first)
-    __out[__m] = *__first;
-
-  while (__first != __last) {
-    ++__t;
-    _Distance __M = __rand(__t);
-    if (__M < __n)
-      __out[__M] = *__first;
-    ++__first;
-  }
-
-  return __out + __m;
-}
-
-template <class _InputIter, class _RandomAccessIter>
-inline _RandomAccessIter
-random_sample(_InputIter __first, _InputIter __last,
-              _RandomAccessIter __out_first, _RandomAccessIter __out_last) 
-{
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  return __random_sample(__first, __last,
-                         __out_first, __out_last - __out_first);
-}
-
-
-template <class _InputIter, class _RandomAccessIter, 
-          class _RandomNumberGenerator>
-inline _RandomAccessIter
-random_sample(_InputIter __first, _InputIter __last,
-              _RandomAccessIter __out_first, _RandomAccessIter __out_last,
-              _RandomNumberGenerator& __rand) 
-{
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  return __random_sample(__first, __last,
-                         __out_first, __rand,
-                         __out_last - __out_first);
-}
-
-// partition, stable_partition, and their auxiliary functions
-
-template <class _ForwardIter, class _Predicate>
-_ForwardIter __partition(_ForwardIter __first,
-             _ForwardIter __last,
-       _Predicate   __pred,
-       forward_iterator_tag) {
-  if (__first == __last) return __first;
-
-  while (__pred(*__first))
-    if (++__first == __last) return __first;
-
-  _ForwardIter __next = __first;
-
-  while (++__next != __last)
-    if (__pred(*__next)) {
-      swap(*__first, *__next);
-      ++__first;
-    }
-
-  return __first;
-}
-
-template <class _BidirectionalIter, class _Predicate>
-_BidirectionalIter __partition(_BidirectionalIter __first,
-                               _BidirectionalIter __last,
-             _Predicate __pred,
-             bidirectional_iterator_tag) {
-  while (true) {
-    while (true)
-      if (__first == __last)
-        return __first;
-      else if (__pred(*__first))
-        ++__first;
-      else
-        break;
-    --__last;
-    while (true)
-      if (__first == __last)
-        return __first;
-      else if (!__pred(*__last))
-        --__last;
-      else
-        break;
-    iter_swap(__first, __last);
-    ++__first;
-  }
-}
-
-template <class _ForwardIter, class _Predicate>
-inline _ForwardIter partition(_ForwardIter __first,
-              _ForwardIter __last,
-            _Predicate   __pred) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool, 
-        typename iterator_traits<_ForwardIter>::value_type);
-  return __partition(__first, __last, __pred, __ITERATOR_CATEGORY(__first));
-}
-
-
-template <class _ForwardIter, class _Predicate, class _Distance>
-_ForwardIter __inplace_stable_partition(_ForwardIter __first,
-                                        _ForwardIter __last,
-                                        _Predicate __pred, _Distance __len) {
-  if (__len == 1)
-    return __pred(*__first) ? __last : __first;
-  _ForwardIter __middle = __first;
-  advance(__middle, __len / 2);
-  return rotate(__inplace_stable_partition(__first, __middle, __pred, 
-                                           __len / 2),
-                __middle,
-                __inplace_stable_partition(__middle, __last, __pred,
-                                           __len - __len / 2));
-}
-
-template <class _ForwardIter, class _Pointer, class _Predicate, 
-          class _Distance>
-_ForwardIter __stable_partition_adaptive(_ForwardIter __first,
-                                         _ForwardIter __last,
-                                         _Predicate __pred, _Distance __len,
-                                         _Pointer __buffer,
-                                         _Distance __buffer_size) 
-{
-  if (__len <= __buffer_size) {
-    _ForwardIter __result1 = __first;
-    _Pointer __result2 = __buffer;
-    for ( ; __first != __last ; ++__first)
-      if (__pred(*__first)) {
-        *__result1 = *__first;
-        ++__result1;
-      }
-      else {
-        *__result2 = *__first;
-        ++__result2;
-      }
-    copy(__buffer, __result2, __result1);
-    return __result1;
-  }
-  else {
-    _ForwardIter __middle = __first;
-    advance(__middle, __len / 2);
-    return rotate(__stable_partition_adaptive(
-                          __first, __middle, __pred,
-                          __len / 2, __buffer, __buffer_size),
-                    __middle,
-                    __stable_partition_adaptive(
-                          __middle, __last, __pred,
-                          __len - __len / 2, __buffer, __buffer_size));
-  }
-}
-
-template <class _ForwardIter, class _Predicate, class _Tp, class _Distance>
-inline _ForwardIter
-__stable_partition_aux(_ForwardIter __first, _ForwardIter __last, 
-                       _Predicate __pred, _Tp*, _Distance*)
-{
-  _Temporary_buffer<_ForwardIter, _Tp> __buf(__first, __last);
-  if (__buf.size() > 0)
-    return __stable_partition_adaptive(__first, __last, __pred,
-                                       _Distance(__buf.requested_size()),
-                                       __buf.begin(), __buf.size());
-  else
-    return __inplace_stable_partition(__first, __last, __pred, 
-                                      _Distance(__buf.requested_size()));
-}
-
-template <class _ForwardIter, class _Predicate>
-inline _ForwardIter stable_partition(_ForwardIter __first,
-                                     _ForwardIter __last, 
-                                     _Predicate __pred) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  __STL_UNARY_FUNCTION_CHECK(_Predicate, bool,
-      typename iterator_traits<_ForwardIter>::value_type);
-  if (__first == __last)
-    return __first;
-  else
-    return __stable_partition_aux(__first, __last, __pred,
-                                  __VALUE_TYPE(__first),
-                                  __DISTANCE_TYPE(__first));
-}
-
-template <class _RandomAccessIter, class _Tp>
-_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, 
-                                        _RandomAccessIter __last, 
-                                        _Tp __pivot) 
-{
-  while (true) {
-    while (*__first < __pivot)
-      ++__first;
-    --__last;
-    while (__pivot < *__last)
-      --__last;
-    if (!(__first < __last))
-      return __first;
-    iter_swap(__first, __last);
-    ++__first;
-  }
-}    
-
-template <class _RandomAccessIter, class _Tp, class _Compare>
-_RandomAccessIter __unguarded_partition(_RandomAccessIter __first, 
-                                        _RandomAccessIter __last, 
-                                        _Tp __pivot, _Compare __comp) 
-{
-  while (true) {
-    while (__comp(*__first, __pivot))
-      ++__first;
-    --__last;
-    while (__comp(__pivot, *__last))
-      --__last;
-    if (!(__first < __last))
-      return __first;
-    iter_swap(__first, __last);
-    ++__first;
-  }
-}
-
-const int __stl_threshold = 16;
-
-// sort() and its auxiliary functions. 
-
-template <class _RandomAccessIter, class _Tp>
-void __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val) {
-  _RandomAccessIter __next = __last;
-  --__next;
-  while (__val < *__next) {
-    *__last = *__next;
-    __last = __next;
-    --__next;
-  }
-  *__last = __val;
-}
-
-template <class _RandomAccessIter, class _Tp, class _Compare>
-void __unguarded_linear_insert(_RandomAccessIter __last, _Tp __val, 
-                               _Compare __comp) {
-  _RandomAccessIter __next = __last;
-  --__next;  
-  while (__comp(__val, *__next)) {
-    *__last = *__next;
-    __last = __next;
-    --__next;
-  }
-  *__last = __val;
-}
-
-template <class _RandomAccessIter, class _Tp>
-inline void __linear_insert(_RandomAccessIter __first, 
-                            _RandomAccessIter __last, _Tp*) {
-  _Tp __val = *__last;
-  if (__val < *__first) {
-    copy_backward(__first, __last, __last + 1);
-    *__first = __val;
-  }
-  else
-    __unguarded_linear_insert(__last, __val);
-}
-
-template <class _RandomAccessIter, class _Tp, class _Compare>
-inline void __linear_insert(_RandomAccessIter __first, 
-                            _RandomAccessIter __last, _Tp*, _Compare __comp) {
-  _Tp __val = *__last;
-  if (__comp(__val, *__first)) {
-    copy_backward(__first, __last, __last + 1);
-    *__first = __val;
-  }
-  else
-    __unguarded_linear_insert(__last, __val, __comp);
-}
-
-template <class _RandomAccessIter>
-void __insertion_sort(_RandomAccessIter __first, _RandomAccessIter __last) {
-  if (__first == __last) return; 
-  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
-    __linear_insert(__first, __i, __VALUE_TYPE(__first));
-}
-
-template <class _RandomAccessIter, class _Compare>
-void __insertion_sort(_RandomAccessIter __first,
-                      _RandomAccessIter __last, _Compare __comp) {
-  if (__first == __last) return;
-  for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
-    __linear_insert(__first, __i, __VALUE_TYPE(__first), __comp);
-}
-
-template <class _RandomAccessIter, class _Tp>
-void __unguarded_insertion_sort_aux(_RandomAccessIter __first, 
-                                    _RandomAccessIter __last, _Tp*) {
-  for (_RandomAccessIter __i = __first; __i != __last; ++__i)
-    __unguarded_linear_insert(__i, _Tp(*__i));
-}
-
-template <class _RandomAccessIter>
-inline void __unguarded_insertion_sort(_RandomAccessIter __first, 
-                                _RandomAccessIter __last) {
-  __unguarded_insertion_sort_aux(__first, __last, __VALUE_TYPE(__first));
-}
-
-template <class _RandomAccessIter, class _Tp, class _Compare>
-void __unguarded_insertion_sort_aux(_RandomAccessIter __first, 
-                                    _RandomAccessIter __last,
-                                    _Tp*, _Compare __comp) {
-  for (_RandomAccessIter __i = __first; __i != __last; ++__i)
-    __unguarded_linear_insert(__i, _Tp(*__i), __comp);
-}
-
-template <class _RandomAccessIter, class _Compare>
-inline void __unguarded_insertion_sort(_RandomAccessIter __first, 
-                                       _RandomAccessIter __last,
-                                       _Compare __comp) {
-  __unguarded_insertion_sort_aux(__first, __last, __VALUE_TYPE(__first),
-                                 __comp);
-}
-
-template <class _RandomAccessIter>
-void __final_insertion_sort(_RandomAccessIter __first, 
-                            _RandomAccessIter __last) {
-  if (__last - __first > __stl_threshold) {
-    __insertion_sort(__first, __first + __stl_threshold);
-    __unguarded_insertion_sort(__first + __stl_threshold, __last);
-  }
-  else
-    __insertion_sort(__first, __last);
-}
-
-template <class _RandomAccessIter, class _Compare>
-void __final_insertion_sort(_RandomAccessIter __first, 
-                            _RandomAccessIter __last, _Compare __comp) {
-  if (__last - __first > __stl_threshold) {
-    __insertion_sort(__first, __first + __stl_threshold, __comp);
-    __unguarded_insertion_sort(__first + __stl_threshold, __last, __comp);
-  }
-  else
-    __insertion_sort(__first, __last, __comp);
-}
-
-template <class _Size>
-inline _Size __lg(_Size __n) {
-  _Size __k;
-  for (__k = 0; __n != 1; __n >>= 1) ++__k;
-  return __k;
-}
-
-template <class _RandomAccessIter, class _Tp, class _Size>
-void __introsort_loop(_RandomAccessIter __first,
-                      _RandomAccessIter __last, _Tp*,
-                      _Size __depth_limit)
-{
-  while (__last - __first > __stl_threshold) {
-    if (__depth_limit == 0) {
-      partial_sort(__first, __last, __last);
-      return;
-    }
-    --__depth_limit;
-    _RandomAccessIter __cut =
-      __unguarded_partition(__first, __last,
-                            _Tp(__median(*__first,
-                                         *(__first + (__last - __first)/2),
-                                         *(__last - 1))));
-    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit);
-    __last = __cut;
-  }
-}
-
-template <class _RandomAccessIter, class _Tp, class _Size, class _Compare>
-void __introsort_loop(_RandomAccessIter __first,
-                      _RandomAccessIter __last, _Tp*,
-                      _Size __depth_limit, _Compare __comp)
-{
-  while (__last - __first > __stl_threshold) {
-    if (__depth_limit == 0) {
-      partial_sort(__first, __last, __last, __comp);
-      return;
-    }
-    --__depth_limit;
-    _RandomAccessIter __cut =
-      __unguarded_partition(__first, __last,
-                            _Tp(__median(*__first,
-                                         *(__first + (__last - __first)/2),
-                                         *(__last - 1), __comp)),
-       __comp);
-    __introsort_loop(__cut, __last, (_Tp*) 0, __depth_limit, __comp);
-    __last = __cut;
-  }
-}
-
-template <class _RandomAccessIter>
-inline void sort(_RandomAccessIter __first, _RandomAccessIter __last) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,
-                 _LessThanComparable);
-  if (__first != __last) {
-    __introsort_loop(__first, __last,
-                     __VALUE_TYPE(__first),
-                     __lg(__last - __first) * 2);
-    __final_insertion_sort(__first, __last);
-  }
-}
-
-template <class _RandomAccessIter, class _Compare>
-inline void sort(_RandomAccessIter __first, _RandomAccessIter __last,
-                 _Compare __comp) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-       typename iterator_traits<_RandomAccessIter>::value_type,
-       typename iterator_traits<_RandomAccessIter>::value_type);
-  if (__first != __last) {
-    __introsort_loop(__first, __last,
-                     __VALUE_TYPE(__first),
-                     __lg(__last - __first) * 2,
-                     __comp);
-    __final_insertion_sort(__first, __last, __comp);
-  }
-}
-
-// stable_sort() and its auxiliary functions.
-
-template <class _RandomAccessIter>
-void __inplace_stable_sort(_RandomAccessIter __first,
-                           _RandomAccessIter __last) {
-  if (__last - __first < 15) {
-    __insertion_sort(__first, __last);
-    return;
-  }
-  _RandomAccessIter __middle = __first + (__last - __first) / 2;
-  __inplace_stable_sort(__first, __middle);
-  __inplace_stable_sort(__middle, __last);
-  __merge_without_buffer(__first, __middle, __last,
-                         __middle - __first,
-                         __last - __middle);
-}
-
-template <class _RandomAccessIter, class _Compare>
-void __inplace_stable_sort(_RandomAccessIter __first,
-                           _RandomAccessIter __last, _Compare __comp) {
-  if (__last - __first < 15) {
-    __insertion_sort(__first, __last, __comp);
-    return;
-  }
-  _RandomAccessIter __middle = __first + (__last - __first) / 2;
-  __inplace_stable_sort(__first, __middle, __comp);
-  __inplace_stable_sort(__middle, __last, __comp);
-  __merge_without_buffer(__first, __middle, __last,
-                         __middle - __first,
-                         __last - __middle,
-                         __comp);
-}
-
-template <class _RandomAccessIter1, class _RandomAccessIter2,
-          class _Distance>
-void __merge_sort_loop(_RandomAccessIter1 __first,
-                       _RandomAccessIter1 __last, 
-                       _RandomAccessIter2 __result, _Distance __step_size) {
-  _Distance __two_step = 2 * __step_size;
-
-  while (__last - __first >= __two_step) {
-    __result = merge(__first, __first + __step_size,
-                     __first + __step_size, __first + __two_step,
-                     __result);
-    __first += __two_step;
-  }
-
-  __step_size = min(_Distance(__last - __first), __step_size);
-  merge(__first, __first + __step_size, __first + __step_size, __last,
-        __result);
-}
-
-template <class _RandomAccessIter1, class _RandomAccessIter2,
-          class _Distance, class _Compare>
-void __merge_sort_loop(_RandomAccessIter1 __first,
-                       _RandomAccessIter1 __last, 
-                       _RandomAccessIter2 __result, _Distance __step_size,
-                       _Compare __comp) {
-  _Distance __two_step = 2 * __step_size;
-
-  while (__last - __first >= __two_step) {
-    __result = merge(__first, __first + __step_size,
-                     __first + __step_size, __first + __two_step,
-                     __result,
-                     __comp);
-    __first += __two_step;
-  }
-  __step_size = min(_Distance(__last - __first), __step_size);
-
-  merge(__first, __first + __step_size,
-        __first + __step_size, __last,
-        __result,
-        __comp);
-}
-
-const int __stl_chunk_size = 7;
-        
-template <class _RandomAccessIter, class _Distance>
-void __chunk_insertion_sort(_RandomAccessIter __first, 
-                            _RandomAccessIter __last, _Distance __chunk_size)
-{
-  while (__last - __first >= __chunk_size) {
-    __insertion_sort(__first, __first + __chunk_size);
-    __first += __chunk_size;
-  }
-  __insertion_sort(__first, __last);
-}
-
-template <class _RandomAccessIter, class _Distance, class _Compare>
-void __chunk_insertion_sort(_RandomAccessIter __first, 
-                            _RandomAccessIter __last,
-                            _Distance __chunk_size, _Compare __comp)
-{
-  while (__last - __first >= __chunk_size) {
-    __insertion_sort(__first, __first + __chunk_size, __comp);
-    __first += __chunk_size;
-  }
-  __insertion_sort(__first, __last, __comp);
-}
-
-template <class _RandomAccessIter, class _Pointer, class _Distance>
-void __merge_sort_with_buffer(_RandomAccessIter __first, 
-                              _RandomAccessIter __last,
-                              _Pointer __buffer, _Distance*) {
-  _Distance __len = __last - __first;
-  _Pointer __buffer_last = __buffer + __len;
-
-  _Distance __step_size = __stl_chunk_size;
-  __chunk_insertion_sort(__first, __last, __step_size);
-
-  while (__step_size < __len) {
-    __merge_sort_loop(__first, __last, __buffer, __step_size);
-    __step_size *= 2;
-    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
-    __step_size *= 2;
-  }
-}
-
-template <class _RandomAccessIter, class _Pointer, class _Distance,
-          class _Compare>
-void __merge_sort_with_buffer(_RandomAccessIter __first, 
-                              _RandomAccessIter __last, _Pointer __buffer,
-                              _Distance*, _Compare __comp) {
-  _Distance __len = __last - __first;
-  _Pointer __buffer_last = __buffer + __len;
-
-  _Distance __step_size = __stl_chunk_size;
-  __chunk_insertion_sort(__first, __last, __step_size, __comp);
-
-  while (__step_size < __len) {
-    __merge_sort_loop(__first, __last, __buffer, __step_size, __comp);
-    __step_size *= 2;
-    __merge_sort_loop(__buffer, __buffer_last, __first, __step_size, __comp);
-    __step_size *= 2;
-  }
-}
-
-template <class _RandomAccessIter, class _Pointer, class _Distance>
-void __stable_sort_adaptive(_RandomAccessIter __first, 
-                            _RandomAccessIter __last, _Pointer __buffer,
-                            _Distance __buffer_size) {
-  _Distance __len = (__last - __first + 1) / 2;
-  _RandomAccessIter __middle = __first + __len;
-  if (__len > __buffer_size) {
-    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size);
-    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size);
-  }
-  else {
-    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)0);
-    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)0);
-  }
-  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), 
-                   _Distance(__last - __middle), __buffer, __buffer_size);
-}
-
-template <class _RandomAccessIter, class _Pointer, class _Distance, 
-          class _Compare>
-void __stable_sort_adaptive(_RandomAccessIter __first, 
-                            _RandomAccessIter __last, _Pointer __buffer,
-                            _Distance __buffer_size, _Compare __comp) {
-  _Distance __len = (__last - __first + 1) / 2;
-  _RandomAccessIter __middle = __first + __len;
-  if (__len > __buffer_size) {
-    __stable_sort_adaptive(__first, __middle, __buffer, __buffer_size, 
-                           __comp);
-    __stable_sort_adaptive(__middle, __last, __buffer, __buffer_size, 
-                           __comp);
-  }
-  else {
-    __merge_sort_with_buffer(__first, __middle, __buffer, (_Distance*)0,
-                               __comp);
-    __merge_sort_with_buffer(__middle, __last, __buffer, (_Distance*)0,
-                               __comp);
-  }
-  __merge_adaptive(__first, __middle, __last, _Distance(__middle - __first), 
-                   _Distance(__last - __middle), __buffer, __buffer_size,
-                   __comp);
-}
-
-template <class _RandomAccessIter, class _Tp, class _Distance>
-inline void __stable_sort_aux(_RandomAccessIter __first,
-                              _RandomAccessIter __last, _Tp*, _Distance*) {
-  _Temporary_buffer<_RandomAccessIter, _Tp> buf(__first, __last);
-  if (buf.begin() == 0)
-    __inplace_stable_sort(__first, __last);
-  else 
-    __stable_sort_adaptive(__first, __last, buf.begin(),
-                           _Distance(buf.size()));
-}
-
-template <class _RandomAccessIter, class _Tp, class _Distance, class _Compare>
-inline void __stable_sort_aux(_RandomAccessIter __first,
-                              _RandomAccessIter __last, _Tp*, _Distance*,
-                              _Compare __comp) {
-  _Temporary_buffer<_RandomAccessIter, _Tp> buf(__first, __last);
-  if (buf.begin() == 0)
-    __inplace_stable_sort(__first, __last, __comp);
-  else 
-    __stable_sort_adaptive(__first, __last, buf.begin(),
-                           _Distance(buf.size()),
-                           __comp);
-}
-
-template <class _RandomAccessIter>
-inline void stable_sort(_RandomAccessIter __first,
-                        _RandomAccessIter __last) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,
-                 _LessThanComparable);
-  __stable_sort_aux(__first, __last,
-                    __VALUE_TYPE(__first),
-                    __DISTANCE_TYPE(__first));
-}
-
-template <class _RandomAccessIter, class _Compare>
-inline void stable_sort(_RandomAccessIter __first,
-                        _RandomAccessIter __last, _Compare __comp) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-       typename iterator_traits<_RandomAccessIter>::value_type,
-       typename iterator_traits<_RandomAccessIter>::value_type);
-  __stable_sort_aux(__first, __last,
-                    __VALUE_TYPE(__first),
-                    __DISTANCE_TYPE(__first), 
-                    __comp);
-}
-
-// partial_sort, partial_sort_copy, and auxiliary functions.
-
-template <class _RandomAccessIter, class _Tp>
-void __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,
-                    _RandomAccessIter __last, _Tp*) {
-  make_heap(__first, __middle);
-  for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
-    if (*__i < *__first) 
-      __pop_heap(__first, __middle, __i, _Tp(*__i),
-                 __DISTANCE_TYPE(__first));
-  sort_heap(__first, __middle);
-}
-
-template <class _RandomAccessIter>
-inline void partial_sort(_RandomAccessIter __first,
-                         _RandomAccessIter __middle,
-                         _RandomAccessIter __last) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,
-                 _LessThanComparable);
-  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first));
-}
-
-template <class _RandomAccessIter, class _Tp, class _Compare>
-void __partial_sort(_RandomAccessIter __first, _RandomAccessIter __middle,
-                    _RandomAccessIter __last, _Tp*, _Compare __comp) {
-  make_heap(__first, __middle, __comp);
-  for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
-    if (__comp(*__i, *__first))
-      __pop_heap(__first, __middle, __i, _Tp(*__i), __comp,
-                 __DISTANCE_TYPE(__first));
-  sort_heap(__first, __middle, __comp);
-}
-
-template <class _RandomAccessIter, class _Compare>
-inline void partial_sort(_RandomAccessIter __first,
-                         _RandomAccessIter __middle,
-                         _RandomAccessIter __last, _Compare __comp) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, 
-      typename iterator_traits<_RandomAccessIter>::value_type,
-      typename iterator_traits<_RandomAccessIter>::value_type);
-  __partial_sort(__first, __middle, __last, __VALUE_TYPE(__first), __comp);
-}
-
-template <class _InputIter, class _RandomAccessIter, class _Distance,
-          class _Tp>
-_RandomAccessIter __partial_sort_copy(_InputIter __first,
-                                      _InputIter __last,
-                                      _RandomAccessIter __result_first,
-                                      _RandomAccessIter __result_last, 
-                                      _Distance*, _Tp*) {
-  if (__result_first == __result_last) return __result_last;
-  _RandomAccessIter __result_real_last = __result_first;
-  while(__first != __last && __result_real_last != __result_last) {
-    *__result_real_last = *__first;
-    ++__result_real_last;
-    ++__first;
-  }
-  make_heap(__result_first, __result_real_last);
-  while (__first != __last) {
-    if (*__first < *__result_first) 
-      __adjust_heap(__result_first, _Distance(0),
-                    _Distance(__result_real_last - __result_first),
-                    _Tp(*__first));
-    ++__first;
-  }
-  sort_heap(__result_first, __result_real_last);
-  return __result_real_last;
-}
-
-template <class _InputIter, class _RandomAccessIter>
-inline _RandomAccessIter
-partial_sort_copy(_InputIter __first, _InputIter __last,
-                  _RandomAccessIter __result_first,
-                  _RandomAccessIter __result_last) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_CONVERTIBLE(typename iterator_traits<_InputIter>::value_type,
-                    typename iterator_traits<_RandomAccessIter>::value_type);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,
-                 _LessThanComparable);
-  __STL_REQUIRES(typename iterator_traits<_InputIter>::value_type,
-                 _LessThanComparable);
-  return __partial_sort_copy(__first, __last, __result_first, __result_last, 
-                             __DISTANCE_TYPE(__result_first),
-                             __VALUE_TYPE(__first));
-}
-
-template <class _InputIter, class _RandomAccessIter, class _Compare,
-          class _Distance, class _Tp>
-_RandomAccessIter __partial_sort_copy(_InputIter __first,
-                                         _InputIter __last,
-                                         _RandomAccessIter __result_first,
-                                         _RandomAccessIter __result_last,
-                                         _Compare __comp, _Distance*, _Tp*) {
-  if (__result_first == __result_last) return __result_last;
-  _RandomAccessIter __result_real_last = __result_first;
-  while(__first != __last && __result_real_last != __result_last) {
-    *__result_real_last = *__first;
-    ++__result_real_last;
-    ++__first;
-  }
-  make_heap(__result_first, __result_real_last, __comp);
-  while (__first != __last) {
-    if (__comp(*__first, *__result_first))
-      __adjust_heap(__result_first, _Distance(0),
-                    _Distance(__result_real_last - __result_first),
-                    _Tp(*__first),
-                    __comp);
-    ++__first;
-  }
-  sort_heap(__result_first, __result_real_last, __comp);
-  return __result_real_last;
-}
-
-template <class _InputIter, class _RandomAccessIter, class _Compare>
-inline _RandomAccessIter
-partial_sort_copy(_InputIter __first, _InputIter __last,
-                  _RandomAccessIter __result_first,
-                  _RandomAccessIter __result_last, _Compare __comp) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_CONVERTIBLE(typename iterator_traits<_InputIter>::value_type,
-                    typename iterator_traits<_RandomAccessIter>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-     typename iterator_traits<_RandomAccessIter>::value_type,
-     typename iterator_traits<_RandomAccessIter>::value_type);  
-  return __partial_sort_copy(__first, __last, __result_first, __result_last,
-                             __comp,
-                             __DISTANCE_TYPE(__result_first),
-                             __VALUE_TYPE(__first));
-}
-
-// nth_element() and its auxiliary functions.  
-
-template <class _RandomAccessIter, class _Tp>
-void __nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
-                   _RandomAccessIter __last, _Tp*) {
-  while (__last - __first > 3) {
-    _RandomAccessIter __cut =
-      __unguarded_partition(__first, __last,
-                            _Tp(__median(*__first,
-                                         *(__first + (__last - __first)/2),
-                                         *(__last - 1))));
-    if (__cut <= __nth)
-      __first = __cut;
-    else 
-      __last = __cut;
-  }
-  __insertion_sort(__first, __last);
-}
-
-template <class _RandomAccessIter>
-inline void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
-                        _RandomAccessIter __last) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,
-                 _LessThanComparable);
-  __nth_element(__first, __nth, __last, __VALUE_TYPE(__first));
-}
-
-template <class _RandomAccessIter, class _Tp, class _Compare>
-void __nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
-                   _RandomAccessIter __last, _Tp*, _Compare __comp) {
-  while (__last - __first > 3) {
-    _RandomAccessIter __cut =
-      __unguarded_partition(__first, __last,
-                            _Tp(__median(*__first,
-                                         *(__first + (__last - __first)/2), 
-                                         *(__last - 1),
-                                         __comp)),
-                            __comp);
-    if (__cut <= __nth)
-      __first = __cut;
-    else 
-      __last = __cut;
-  }
-  __insertion_sort(__first, __last, __comp);
-}
-
-template <class _RandomAccessIter, class _Compare>
-inline void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,
-                        _RandomAccessIter __last, _Compare __comp) {
-  __STL_REQUIRES(_RandomAccessIter, _Mutable_RandomAccessIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-     typename iterator_traits<_RandomAccessIter>::value_type,
-     typename iterator_traits<_RandomAccessIter>::value_type);
-  __nth_element(__first, __nth, __last, __VALUE_TYPE(__first), __comp);
-}
-
-
-// Binary search (lower_bound, upper_bound, equal_range, binary_search).
-
-template <class _ForwardIter, class _Tp, class _Distance>
-_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
-                           const _Tp& __val, _Distance*) 
-{
-  _Distance __len = 0;
-  distance(__first, __last, __len);
-  _Distance __half;
-  _ForwardIter __middle;
-
-  while (__len > 0) {
-    __half = __len >> 1;
-    __middle = __first;
-    advance(__middle, __half);
-    if (*__middle < __val) {
-      __first = __middle;
-      ++__first;
-      __len = __len - __half - 1;
-    }
-    else
-      __len = __half;
-  }
-  return __first;
-}
-
-template <class _ForwardIter, class _Tp>
-inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
-        const _Tp& __val) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES_SAME_TYPE(_Tp,
-      typename iterator_traits<_ForwardIter>::value_type);
-  __STL_REQUIRES(_Tp, _LessThanComparable);
-  return __lower_bound(__first, __last, __val,
-                       __DISTANCE_TYPE(__first));
-}
-
-template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
-_ForwardIter __lower_bound(_ForwardIter __first, _ForwardIter __last,
-                              const _Tp& __val, _Compare __comp, _Distance*)
-{
-  _Distance __len = 0;
-  distance(__first, __last, __len);
-  _Distance __half;
-  _ForwardIter __middle;
-
-  while (__len > 0) {
-    __half = __len >> 1;
-    __middle = __first;
-    advance(__middle, __half);
-    if (__comp(*__middle, __val)) {
-      __first = __middle;
-      ++__first;
-      __len = __len - __half - 1;
-    }
-    else
-      __len = __half;
-  }
-  return __first;
-}
-
-template <class _ForwardIter, class _Tp, class _Compare>
-inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,
-                                const _Tp& __val, _Compare __comp) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES_SAME_TYPE(_Tp,
-      typename iterator_traits<_ForwardIter>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);
-  return __lower_bound(__first, __last, __val, __comp,
-                       __DISTANCE_TYPE(__first));
-}
-
-template <class _ForwardIter, class _Tp, class _Distance>
-_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last,
-                           const _Tp& __val, _Distance*)
-{
-  _Distance __len = 0;
-  distance(__first, __last, __len);
-  _Distance __half;
-  _ForwardIter __middle;
-
-  while (__len > 0) {
-    __half = __len >> 1;
-    __middle = __first;
-    advance(__middle, __half);
-    if (__val < *__middle)
-      __len = __half;
-    else {
-      __first = __middle;
-      ++__first;
-      __len = __len - __half - 1;
-    }
-  }
-  return __first;
-}
-
-template <class _ForwardIter, class _Tp>
-inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
-                                const _Tp& __val) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES_SAME_TYPE(_Tp,
-      typename iterator_traits<_ForwardIter>::value_type);
-  __STL_REQUIRES(_Tp, _LessThanComparable);
-  return __upper_bound(__first, __last, __val,
-                       __DISTANCE_TYPE(__first));
-}
-
-template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
-_ForwardIter __upper_bound(_ForwardIter __first, _ForwardIter __last,
-                           const _Tp& __val, _Compare __comp, _Distance*)
-{
-  _Distance __len = 0;
-  distance(__first, __last, __len);
-  _Distance __half;
-  _ForwardIter __middle;
-
-  while (__len > 0) {
-    __half = __len >> 1;
-    __middle = __first;
-    advance(__middle, __half);
-    if (__comp(__val, *__middle))
-      __len = __half;
-    else {
-      __first = __middle;
-      ++__first;
-      __len = __len - __half - 1;
-    }
-  }
-  return __first;
-}
-
-template <class _ForwardIter, class _Tp, class _Compare>
-inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,
-                                const _Tp& __val, _Compare __comp) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES_SAME_TYPE(_Tp,
-      typename iterator_traits<_ForwardIter>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);
-  return __upper_bound(__first, __last, __val, __comp,
-                       __DISTANCE_TYPE(__first));
-}
-
-template <class _ForwardIter, class _Tp, class _Distance>
-pair<_ForwardIter, _ForwardIter>
-__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
-              _Distance*)
-{
-  _Distance __len = 0;
-  distance(__first, __last, __len);
-  _Distance __half;
-  _ForwardIter __middle, __left, __right;
-
-  while (__len > 0) {
-    __half = __len >> 1;
-    __middle = __first;
-    advance(__middle, __half);
-    if (*__middle < __val) {
-      __first = __middle;
-      ++__first;
-      __len = __len - __half - 1;
-    }
-    else if (__val < *__middle)
-      __len = __half;
-    else {
-      __left = lower_bound(__first, __middle, __val);
-      advance(__first, __len);
-      __right = upper_bound(++__middle, __first, __val);
-      return pair<_ForwardIter, _ForwardIter>(__left, __right);
-    }
-  }
-  return pair<_ForwardIter, _ForwardIter>(__first, __first);
-}
-
-template <class _ForwardIter, class _Tp>
-inline pair<_ForwardIter, _ForwardIter>
-equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES_SAME_TYPE(_Tp, 
-       typename iterator_traits<_ForwardIter>::value_type);
-  __STL_REQUIRES(_Tp, _LessThanComparable);
-  return __equal_range(__first, __last, __val,
-                       __DISTANCE_TYPE(__first));
-}
-
-template <class _ForwardIter, class _Tp, class _Compare, class _Distance>
-pair<_ForwardIter, _ForwardIter>
-__equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
-              _Compare __comp, _Distance*)
-{
-  _Distance __len = 0;
-  distance(__first, __last, __len);
-  _Distance __half;
-  _ForwardIter __middle, __left, __right;
-
-  while (__len > 0) {
-    __half = __len >> 1;
-    __middle = __first;
-    advance(__middle, __half);
-    if (__comp(*__middle, __val)) {
-      __first = __middle;
-      ++__first;
-      __len = __len - __half - 1;
-    }
-    else if (__comp(__val, *__middle))
-      __len = __half;
-    else {
-      __left = lower_bound(__first, __middle, __val, __comp);
-      advance(__first, __len);
-      __right = upper_bound(++__middle, __first, __val, __comp);
-      return pair<_ForwardIter, _ForwardIter>(__left, __right);
-    }
-  }
-  return pair<_ForwardIter, _ForwardIter>(__first, __first);
-}           
-
-template <class _ForwardIter, class _Tp, class _Compare>
-inline pair<_ForwardIter, _ForwardIter>
-equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,
-            _Compare __comp) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES_SAME_TYPE(_Tp, 
-       typename iterator_traits<_ForwardIter>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);
-  return __equal_range(__first, __last, __val, __comp,
-                       __DISTANCE_TYPE(__first));
-} 
-
-template <class _ForwardIter, class _Tp>
-bool binary_search(_ForwardIter __first, _ForwardIter __last,
-                   const _Tp& __val) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES_SAME_TYPE(_Tp,
-        typename iterator_traits<_ForwardIter>::value_type);
-  __STL_REQUIRES(_Tp, _LessThanComparable);
-  _ForwardIter __i = lower_bound(__first, __last, __val);
-  return __i != __last && !(__val < *__i);
-}
-
-template <class _ForwardIter, class _Tp, class _Compare>
-bool binary_search(_ForwardIter __first, _ForwardIter __last,
-                   const _Tp& __val,
-                   _Compare __comp) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES_SAME_TYPE(_Tp,
-        typename iterator_traits<_ForwardIter>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);
-  _ForwardIter __i = lower_bound(__first, __last, __val, __comp);
-  return __i != __last && !__comp(__val, *__i);
-}
-
-// merge, with and without an explicitly supplied comparison function.
-
-template <class _InputIter1, class _InputIter2, class _OutputIter>
-_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
-                  _InputIter2 __first2, _InputIter2 __last2,
-                  _OutputIter __result) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-          typename iterator_traits<_InputIter1>::value_type,
-          typename iterator_traits<_InputIter2>::value_type);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _LessThanComparable);
-  while (__first1 != __last1 && __first2 != __last2) {
-    if (*__first2 < *__first1) {
-      *__result = *__first2;
-      ++__first2;
-    }
-    else {
-      *__result = *__first1;
-      ++__first1;
-    }
-    ++__result;
-  }
-  return copy(__first2, __last2, copy(__first1, __last1, __result));
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter,
-          class _Compare>
-_OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,
-                  _InputIter2 __first2, _InputIter2 __last2,
-                  _OutputIter __result, _Compare __comp) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-          typename iterator_traits<_InputIter1>::value_type,
-          typename iterator_traits<_InputIter2>::value_type);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-          typename iterator_traits<_InputIter1>::value_type,
-          typename iterator_traits<_InputIter1>::value_type);
-  while (__first1 != __last1 && __first2 != __last2) {
-    if (__comp(*__first2, *__first1)) {
-      *__result = *__first2;
-      ++__first2;
-    }
-    else {
-      *__result = *__first1;
-      ++__first1;
-    }
-    ++__result;
-  }
-  return copy(__first2, __last2, copy(__first1, __last1, __result));
-}
-
-// inplace_merge and its auxiliary functions. 
-
-template <class _BidirectionalIter, class _Distance>
-void __merge_without_buffer(_BidirectionalIter __first,
-                            _BidirectionalIter __middle,
-                            _BidirectionalIter __last,
-                            _Distance __len1, _Distance __len2) {
-  if (__len1 == 0 || __len2 == 0)
-    return;
-  if (__len1 + __len2 == 2) {
-    if (*__middle < *__first)
-      iter_swap(__first, __middle);
-    return;
-  }
-  _BidirectionalIter __first_cut = __first;
-  _BidirectionalIter __second_cut = __middle;
-  _Distance __len11 = 0;
-  _Distance __len22 = 0;
-  if (__len1 > __len2) {
-    __len11 = __len1 / 2;
-    advance(__first_cut, __len11);
-    __second_cut = lower_bound(__middle, __last, *__first_cut);
-    distance(__middle, __second_cut, __len22);
-  }
-  else {
-    __len22 = __len2 / 2;
-    advance(__second_cut, __len22);
-    __first_cut = upper_bound(__first, __middle, *__second_cut);
-    distance(__first, __first_cut, __len11);
-  }
-  _BidirectionalIter __new_middle
-    = rotate(__first_cut, __middle, __second_cut);
-  __merge_without_buffer(__first, __first_cut, __new_middle,
-                         __len11, __len22);
-  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,
-                         __len2 - __len22);
-}
-
-template <class _BidirectionalIter, class _Distance, class _Compare>
-void __merge_without_buffer(_BidirectionalIter __first,
-                            _BidirectionalIter __middle,
-                            _BidirectionalIter __last,
-                            _Distance __len1, _Distance __len2,
-                            _Compare __comp) {
-  if (__len1 == 0 || __len2 == 0)
-    return;
-  if (__len1 + __len2 == 2) {
-    if (__comp(*__middle, *__first))
-      iter_swap(__first, __middle);
-    return;
-  }
-  _BidirectionalIter __first_cut = __first;
-  _BidirectionalIter __second_cut = __middle;
-  _Distance __len11 = 0;
-  _Distance __len22 = 0;
-  if (__len1 > __len2) {
-    __len11 = __len1 / 2;
-    advance(__first_cut, __len11);
-    __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
-    distance(__middle, __second_cut, __len22);
-  }
-  else {
-    __len22 = __len2 / 2;
-    advance(__second_cut, __len22);
-    __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
-    distance(__first, __first_cut, __len11);
-  }
-  _BidirectionalIter __new_middle
-    = rotate(__first_cut, __middle, __second_cut);
-  __merge_without_buffer(__first, __first_cut, __new_middle, __len11, __len22,
-                         __comp);
-  __merge_without_buffer(__new_middle, __second_cut, __last, __len1 - __len11,
-                         __len2 - __len22, __comp);
-}
-
-template <class _BidirectionalIter1, class _BidirectionalIter2,
-          class _Distance>
-_BidirectionalIter1 __rotate_adaptive(_BidirectionalIter1 __first,
-                                      _BidirectionalIter1 __middle,
-                                      _BidirectionalIter1 __last,
-                                      _Distance __len1, _Distance __len2,
-                                      _BidirectionalIter2 __buffer,
-                                      _Distance __buffer_size) {
-  _BidirectionalIter2 __buffer_end;
-  if (__len1 > __len2 && __len2 <= __buffer_size) {
-    __buffer_end = copy(__middle, __last, __buffer);
-    copy_backward(__first, __middle, __last);
-    return copy(__buffer, __buffer_end, __first);
-  }
-  else if (__len1 <= __buffer_size) {
-    __buffer_end = copy(__first, __middle, __buffer);
-    copy(__middle, __last, __first);
-    return copy_backward(__buffer, __buffer_end, __last);
-  }
-  else
-    return rotate(__first, __middle, __last);
-}
-
-template <class _BidirectionalIter1, class _BidirectionalIter2,
-          class _BidirectionalIter3>
-_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
-                                     _BidirectionalIter1 __last1,
-                                     _BidirectionalIter2 __first2,
-                                     _BidirectionalIter2 __last2,
-                                     _BidirectionalIter3 __result) {
-  if (__first1 == __last1)
-    return copy_backward(__first2, __last2, __result);
-  if (__first2 == __last2)
-    return copy_backward(__first1, __last1, __result);
-  --__last1;
-  --__last2;
-  while (true) {
-    if (*__last2 < *__last1) {
-      *--__result = *__last1;
-      if (__first1 == __last1)
-        return copy_backward(__first2, ++__last2, __result);
-      --__last1;
-    }
-    else {
-      *--__result = *__last2;
-      if (__first2 == __last2)
-        return copy_backward(__first1, ++__last1, __result);
-      --__last2;
-    }
-  }
-}
-
-template <class _BidirectionalIter1, class _BidirectionalIter2,
-          class _BidirectionalIter3, class _Compare>
-_BidirectionalIter3 __merge_backward(_BidirectionalIter1 __first1,
-                                     _BidirectionalIter1 __last1,
-                                     _BidirectionalIter2 __first2,
-                                     _BidirectionalIter2 __last2,
-                                     _BidirectionalIter3 __result,
-                                     _Compare __comp) {
-  if (__first1 == __last1)
-    return copy_backward(__first2, __last2, __result);
-  if (__first2 == __last2)
-    return copy_backward(__first1, __last1, __result);
-  --__last1;
-  --__last2;
-  while (true) {
-    if (__comp(*__last2, *__last1)) {
-      *--__result = *__last1;
-      if (__first1 == __last1)
-        return copy_backward(__first2, ++__last2, __result);
-      --__last1;
-    }
-    else {
-      *--__result = *__last2;
-      if (__first2 == __last2)
-        return copy_backward(__first1, ++__last1, __result);
-      --__last2;
-    }
-  }
-}
-
-template <class _BidirectionalIter, class _Distance, class _Pointer>
-void __merge_adaptive(_BidirectionalIter __first,
-                      _BidirectionalIter __middle, 
-                      _BidirectionalIter __last,
-                      _Distance __len1, _Distance __len2,
-                      _Pointer __buffer, _Distance __buffer_size) {
-  if (__len1 <= __len2 && __len1 <= __buffer_size) {
-    _Pointer __buffer_end = copy(__first, __middle, __buffer);
-    merge(__buffer, __buffer_end, __middle, __last, __first);
-  }
-  else if (__len2 <= __buffer_size) {
-    _Pointer __buffer_end = copy(__middle, __last, __buffer);
-    __merge_backward(__first, __middle, __buffer, __buffer_end, __last);
-  }
-  else {
-    _BidirectionalIter __first_cut = __first;
-    _BidirectionalIter __second_cut = __middle;
-    _Distance __len11 = 0;
-    _Distance __len22 = 0;
-    if (__len1 > __len2) {
-      __len11 = __len1 / 2;
-      advance(__first_cut, __len11);
-      __second_cut = lower_bound(__middle, __last, *__first_cut);
-      distance(__middle, __second_cut, __len22); 
-    }
-    else {
-      __len22 = __len2 / 2;
-      advance(__second_cut, __len22);
-      __first_cut = upper_bound(__first, __middle, *__second_cut);
-      distance(__first, __first_cut, __len11);
-    }
-    _BidirectionalIter __new_middle =
-      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,
-                        __len22, __buffer, __buffer_size);
-    __merge_adaptive(__first, __first_cut, __new_middle, __len11,
-                     __len22, __buffer, __buffer_size);
-    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
-                     __len2 - __len22, __buffer, __buffer_size);
-  }
-}
-
-template <class _BidirectionalIter, class _Distance, class _Pointer,
-          class _Compare>
-void __merge_adaptive(_BidirectionalIter __first, 
-                      _BidirectionalIter __middle, 
-                      _BidirectionalIter __last,
-                      _Distance __len1, _Distance __len2,
-                      _Pointer __buffer, _Distance __buffer_size,
-                      _Compare __comp) {
-  if (__len1 <= __len2 && __len1 <= __buffer_size) {
-    _Pointer __buffer_end = copy(__first, __middle, __buffer);
-    merge(__buffer, __buffer_end, __middle, __last, __first, __comp);
-  }
-  else if (__len2 <= __buffer_size) {
-    _Pointer __buffer_end = copy(__middle, __last, __buffer);
-    __merge_backward(__first, __middle, __buffer, __buffer_end, __last,
-                     __comp);
-  }
-  else {
-    _BidirectionalIter __first_cut = __first;
-    _BidirectionalIter __second_cut = __middle;
-    _Distance __len11 = 0;
-    _Distance __len22 = 0;
-    if (__len1 > __len2) {
-      __len11 = __len1 / 2;
-      advance(__first_cut, __len11);
-      __second_cut = lower_bound(__middle, __last, *__first_cut, __comp);
-      distance(__middle, __second_cut, __len22);   
-    }
-    else {
-      __len22 = __len2 / 2;
-      advance(__second_cut, __len22);
-      __first_cut = upper_bound(__first, __middle, *__second_cut, __comp);
-      distance(__first, __first_cut, __len11);
-    }
-    _BidirectionalIter __new_middle =
-      __rotate_adaptive(__first_cut, __middle, __second_cut, __len1 - __len11,
-                        __len22, __buffer, __buffer_size);
-    __merge_adaptive(__first, __first_cut, __new_middle, __len11,
-                     __len22, __buffer, __buffer_size, __comp);
-    __merge_adaptive(__new_middle, __second_cut, __last, __len1 - __len11,
-                     __len2 - __len22, __buffer, __buffer_size, __comp);
-  }
-}
-
-template <class _BidirectionalIter, class _Tp, class _Distance>
-inline void __inplace_merge_aux(_BidirectionalIter __first,
-                                _BidirectionalIter __middle,
-                                _BidirectionalIter __last, _Tp*, _Distance*) {
-  _Distance __len1 = 0;
-  distance(__first, __middle, __len1);
-  _Distance __len2 = 0;
-  distance(__middle, __last, __len2);
-
-  _Temporary_buffer<_BidirectionalIter, _Tp> __buf(__first, __last);
-  if (__buf.begin() == 0)
-    __merge_without_buffer(__first, __middle, __last, __len1, __len2);
-  else
-    __merge_adaptive(__first, __middle, __last, __len1, __len2,
-                     __buf.begin(), _Distance(__buf.size()));
-}
-
-template <class _BidirectionalIter, class _Tp, 
-          class _Distance, class _Compare>
-inline void __inplace_merge_aux(_BidirectionalIter __first,
-                                _BidirectionalIter __middle,
-                                _BidirectionalIter __last, _Tp*, _Distance*,
-                                _Compare __comp) {
-  _Distance __len1 = 0;
-  distance(__first, __middle, __len1);
-  _Distance __len2 = 0;
-  distance(__middle, __last, __len2);
-
-  _Temporary_buffer<_BidirectionalIter, _Tp> __buf(__first, __last);
-  if (__buf.begin() == 0)
-    __merge_without_buffer(__first, __middle, __last, __len1, __len2, __comp);
-  else
-    __merge_adaptive(__first, __middle, __last, __len1, __len2,
-                     __buf.begin(), _Distance(__buf.size()),
-                     __comp);
-}
-
-template <class _BidirectionalIter>
-inline void inplace_merge(_BidirectionalIter __first,
-                          _BidirectionalIter __middle,
-                          _BidirectionalIter __last) {
-  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);
-  __STL_REQUIRES(typename iterator_traits<_BidirectionalIter>::value_type,
-                 _LessThanComparable);
-  if (__first == __middle || __middle == __last)
-    return;
-  __inplace_merge_aux(__first, __middle, __last,
-                      __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));
-}
-
-template <class _BidirectionalIter, class _Compare>
-inline void inplace_merge(_BidirectionalIter __first,
-                          _BidirectionalIter __middle,
-                          _BidirectionalIter __last, _Compare __comp) {
-  __STL_REQUIRES(_BidirectionalIter, _Mutable_BidirectionalIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-           typename iterator_traits<_BidirectionalIter>::value_type,
-           typename iterator_traits<_BidirectionalIter>::value_type);
-  if (__first == __middle || __middle == __last)
-    return;
-  __inplace_merge_aux(__first, __middle, __last,
-                      __VALUE_TYPE(__first), __DISTANCE_TYPE(__first),
-                      __comp);
-}
-
-// Set algorithms: includes, set_union, set_intersection, set_difference,
-// set_symmetric_difference.  All of these algorithms have the precondition
-// that their input ranges are sorted and the postcondition that their output
-// ranges are sorted.
-
-template <class _InputIter1, class _InputIter2>
-bool includes(_InputIter1 __first1, _InputIter1 __last1,
-              _InputIter2 __first2, _InputIter2 __last2) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _LessThanComparable);
-  while (__first1 != __last1 && __first2 != __last2)
-    if (*__first2 < *__first1)
-      return false;
-    else if(*__first1 < *__first2) 
-      ++__first1;
-    else
-      ++__first1, ++__first2;
-
-  return __first2 == __last2;
-}
-
-template <class _InputIter1, class _InputIter2, class _Compare>
-bool includes(_InputIter1 __first1, _InputIter1 __last1,
-              _InputIter2 __first2, _InputIter2 __last2, _Compare __comp) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  while (__first1 != __last1 && __first2 != __last2)
-    if (__comp(*__first2, *__first1))
-      return false;
-    else if(__comp(*__first1, *__first2)) 
-      ++__first1;
-    else
-      ++__first1, ++__first2;
-
-  return __first2 == __last2;
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter>
-_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
-                      _InputIter2 __first2, _InputIter2 __last2,
-                      _OutputIter __result) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _LessThanComparable);
-  while (__first1 != __last1 && __first2 != __last2) {
-    if (*__first1 < *__first2) {
-      *__result = *__first1;
-      ++__first1;
-    }
-    else if (*__first2 < *__first1) {
-      *__result = *__first2;
-      ++__first2;
-    }
-    else {
-      *__result = *__first1;
-      ++__first1;
-      ++__first2;
-    }
-    ++__result;
-  }
-  return copy(__first2, __last2, copy(__first1, __last1, __result));
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter,
-          class _Compare>
-_OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,
-                      _InputIter2 __first2, _InputIter2 __last2,
-                      _OutputIter __result, _Compare __comp) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  while (__first1 != __last1 && __first2 != __last2) {
-    if (__comp(*__first1, *__first2)) {
-      *__result = *__first1;
-      ++__first1;
-    }
-    else if (__comp(*__first2, *__first1)) {
-      *__result = *__first2;
-      ++__first2;
-    }
-    else {
-      *__result = *__first1;
-      ++__first1;
-      ++__first2;
-    }
-    ++__result;
-  }
-  return copy(__first2, __last2, copy(__first1, __last1, __result));
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter>
-_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
-                             _InputIter2 __first2, _InputIter2 __last2,
-                             _OutputIter __result) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _LessThanComparable);
-  while (__first1 != __last1 && __first2 != __last2) 
-    if (*__first1 < *__first2) 
-      ++__first1;
-    else if (*__first2 < *__first1) 
-      ++__first2;
-    else {
-      *__result = *__first1;
-      ++__first1;
-      ++__first2;
-      ++__result;
-    }
-  return __result;
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter,
-          class _Compare>
-_OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,
-                             _InputIter2 __first2, _InputIter2 __last2,
-                             _OutputIter __result, _Compare __comp) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-
-  while (__first1 != __last1 && __first2 != __last2)
-    if (__comp(*__first1, *__first2))
-      ++__first1;
-    else if (__comp(*__first2, *__first1))
-      ++__first2;
-    else {
-      *__result = *__first1;
-      ++__first1;
-      ++__first2;
-      ++__result;
-    }
-  return __result;
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter>
-_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
-                           _InputIter2 __first2, _InputIter2 __last2,
-                           _OutputIter __result) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _LessThanComparable);
-  while (__first1 != __last1 && __first2 != __last2)
-    if (*__first1 < *__first2) {
-      *__result = *__first1;
-      ++__first1;
-      ++__result;
-    }
-    else if (*__first2 < *__first1)
-      ++__first2;
-    else {
-      ++__first1;
-      ++__first2;
-    }
-  return copy(__first1, __last1, __result);
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter, 
-          class _Compare>
-_OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,
-                           _InputIter2 __first2, _InputIter2 __last2, 
-                           _OutputIter __result, _Compare __comp) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-
-  while (__first1 != __last1 && __first2 != __last2)
-    if (__comp(*__first1, *__first2)) {
-      *__result = *__first1;
-      ++__first1;
-      ++__result;
-    }
-    else if (__comp(*__first2, *__first1))
-      ++__first2;
-    else {
-      ++__first1;
-      ++__first2;
-    }
-  return copy(__first1, __last1, __result);
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter>
-_OutputIter 
-set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
-                         _InputIter2 __first2, _InputIter2 __last2,
-                         _OutputIter __result) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _LessThanComparable);
-  while (__first1 != __last1 && __first2 != __last2)
-    if (*__first1 < *__first2) {
-      *__result = *__first1;
-      ++__first1;
-      ++__result;
-    }
-    else if (*__first2 < *__first1) {
-      *__result = *__first2;
-      ++__first2;
-      ++__result;
-    }
-    else {
-      ++__first1;
-      ++__first2;
-    }
-  return copy(__first2, __last2, copy(__first1, __last1, __result));
-}
-
-template <class _InputIter1, class _InputIter2, class _OutputIter,
-          class _Compare>
-_OutputIter 
-set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,
-                         _InputIter2 __first2, _InputIter2 __last2,
-                         _OutputIter __result,
-                         _Compare __comp) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  __STL_REQUIRES_SAME_TYPE(
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-       typename iterator_traits<_InputIter1>::value_type,
-       typename iterator_traits<_InputIter2>::value_type);
-  while (__first1 != __last1 && __first2 != __last2)
-    if (__comp(*__first1, *__first2)) {
-      *__result = *__first1;
-      ++__first1;
-      ++__result;
-    }
-    else if (__comp(*__first2, *__first1)) {
-      *__result = *__first2;
-      ++__first2;
-      ++__result;
-    }
-    else {
-      ++__first1;
-      ++__first2;
-    }
-  return copy(__first2, __last2, copy(__first1, __last1, __result));
-}
-
-// min_element and max_element, with and without an explicitly supplied
-// comparison function.
-
-template <class _ForwardIter>
-_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,
-                 _LessThanComparable);
-  if (__first == __last) return __first;
-  _ForwardIter __result = __first;
-  while (++__first != __last) 
-    if (*__result < *__first)
-      __result = __first;
-  return __result;
-}
-
-template <class _ForwardIter, class _Compare>
-_ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,
-       _Compare __comp) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-    typename iterator_traits<_ForwardIter>::value_type,
-    typename iterator_traits<_ForwardIter>::value_type);
-  if (__first == __last) return __first;
-  _ForwardIter __result = __first;
-  while (++__first != __last) 
-    if (__comp(*__result, *__first)) __result = __first;
-  return __result;
-}
-
-template <class _ForwardIter>
-_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,
-                 _LessThanComparable);
-  if (__first == __last) return __first;
-  _ForwardIter __result = __first;
-  while (++__first != __last) 
-    if (*__first < *__result)
-      __result = __first;
-  return __result;
-}
-
-template <class _ForwardIter, class _Compare>
-_ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,
-       _Compare __comp) {
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-    typename iterator_traits<_ForwardIter>::value_type,
-    typename iterator_traits<_ForwardIter>::value_type);
-  if (__first == __last) return __first;
-  _ForwardIter __result = __first;
-  while (++__first != __last) 
-    if (__comp(*__first, *__result))
-      __result = __first;
-  return __result;
-}
-
-// next_permutation and prev_permutation, with and without an explicitly 
-// supplied comparison function.
-
-template <class _BidirectionalIter>
-bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {
-  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);
-  __STL_REQUIRES(typename iterator_traits<_BidirectionalIter>::value_type,
-                 _LessThanComparable);
-  if (__first == __last)
-    return false;
-  _BidirectionalIter __i = __first;
-  ++__i;
-  if (__i == __last)
-    return false;
-  __i = __last;
-  --__i;
-
-  for(;;) {
-    _BidirectionalIter __ii = __i;
-    --__i;
-    if (*__i < *__ii) {
-      _BidirectionalIter __j = __last;
-      while (!(*__i < *--__j))
-        {}
-      iter_swap(__i, __j);
-      reverse(__ii, __last);
-      return true;
-    }
-    if (__i == __first) {
-      reverse(__first, __last);
-      return false;
-    }
-  }
-}
-
-template <class _BidirectionalIter, class _Compare>
-bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
-                      _Compare __comp) {
-  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-    typename iterator_traits<_BidirectionalIter>::value_type,
-    typename iterator_traits<_BidirectionalIter>::value_type);
-  if (__first == __last)
-    return false;
-  _BidirectionalIter __i = __first;
-  ++__i;
-  if (__i == __last)
-    return false;
-  __i = __last;
-  --__i;
-
-  for(;;) {
-    _BidirectionalIter __ii = __i;
-    --__i;
-    if (__comp(*__i, *__ii)) {
-      _BidirectionalIter __j = __last;
-      while (!__comp(*__i, *--__j))
-        {}
-      iter_swap(__i, __j);
-      reverse(__ii, __last);
-      return true;
-    }
-    if (__i == __first) {
-      reverse(__first, __last);
-      return false;
-    }
-  }
-}
-
-template <class _BidirectionalIter>
-bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last) {
-  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);
-  __STL_REQUIRES(typename iterator_traits<_BidirectionalIter>::value_type,
-                 _LessThanComparable);
-  if (__first == __last)
-    return false;
-  _BidirectionalIter __i = __first;
-  ++__i;
-  if (__i == __last)
-    return false;
-  __i = __last;
-  --__i;
-
-  for(;;) {
-    _BidirectionalIter __ii = __i;
-    --__i;
-    if (*__ii < *__i) {
-      _BidirectionalIter __j = __last;
-      while (!(*--__j < *__i))
-        {}
-      iter_swap(__i, __j);
-      reverse(__ii, __last);
-      return true;
-    }
-    if (__i == __first) {
-      reverse(__first, __last);
-      return false;
-    }
-  }
-}
-
-template <class _BidirectionalIter, class _Compare>
-bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,
-                      _Compare __comp) {
-  __STL_REQUIRES(_BidirectionalIter, _BidirectionalIterator);
-  __STL_BINARY_FUNCTION_CHECK(_Compare, bool,
-    typename iterator_traits<_BidirectionalIter>::value_type,
-    typename iterator_traits<_BidirectionalIter>::value_type);
-  if (__first == __last)
-    return false;
-  _BidirectionalIter __i = __first;
-  ++__i;
-  if (__i == __last)
-    return false;
-  __i = __last;
-  --__i;
-
-  for(;;) {
-    _BidirectionalIter __ii = __i;
-    --__i;
-    if (__comp(*__ii, *__i)) {
-      _BidirectionalIter __j = __last;
-      while (!__comp(*--__j, *__i))
-        {}
-      iter_swap(__i, __j);
-      reverse(__ii, __last);
-      return true;
-    }
-    if (__i == __first) {
-      reverse(__first, __last);
-      return false;
-    }
-  }
-}
-
-// find_first_of, with and without an explicitly supplied comparison function.
-
-template <class _InputIter, class _ForwardIter>
-_InputIter find_first_of(_InputIter __first1, _InputIter __last1,
-                         _ForwardIter __first2, _ForwardIter __last2)
-{
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool, 
-     typename iterator_traits<_InputIter>::value_type,
-     typename iterator_traits<_ForwardIter>::value_type);
-
-  for ( ; __first1 != __last1; ++__first1) 
-    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
-      if (*__first1 == *__iter)
-        return __first1;
-  return __last1;
-}
-
-template <class _InputIter, class _ForwardIter, class _BinaryPredicate>
-_InputIter find_first_of(_InputIter __first1, _InputIter __last1,
-                         _ForwardIter __first2, _ForwardIter __last2,
-                         _BinaryPredicate __comp)
-{
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool,
-     typename iterator_traits<_InputIter>::value_type,
-     typename iterator_traits<_ForwardIter>::value_type);
-
-  for ( ; __first1 != __last1; ++__first1) 
-    for (_ForwardIter __iter = __first2; __iter != __last2; ++__iter)
-      if (__comp(*__first1, *__iter))
-        return __first1;
-  return __last1;
-}
-
-
-// find_end, with and without an explicitly supplied comparison function.
-// Search [first2, last2) as a subsequence in [first1, last1), and return
-// the *last* possible match.  Note that find_end for bidirectional iterators
-// is much faster than for forward iterators.
-
-// find_end for forward iterators. 
-template <class _ForwardIter1, class _ForwardIter2>
-_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
-                         _ForwardIter2 __first2, _ForwardIter2 __last2,
-                         forward_iterator_tag, forward_iterator_tag)
-{
-  if (__first2 == __last2)
-    return __last1;
-  else {
-    _ForwardIter1 __result = __last1;
-    while (1) {
-      _ForwardIter1 __new_result
-        = search(__first1, __last1, __first2, __last2);
-      if (__new_result == __last1)
-        return __result;
-      else {
-        __result = __new_result;
-        __first1 = __new_result;
-        ++__first1;
-      }
-    }
-  }
-}
-
-template <class _ForwardIter1, class _ForwardIter2,
-          class _BinaryPredicate>
-_ForwardIter1 __find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,
-                         _ForwardIter2 __first2, _ForwardIter2 __last2,
-                         forward_iterator_tag, forward_iterator_tag,
-                         _BinaryPredicate __comp)
-{
-  if (__first2 == __last2)
-    return __last1;
-  else {
-    _ForwardIter1 __result = __last1;
-    while (1) {
-      _ForwardIter1 __new_result
-        = search(__first1, __last1, __first2, __last2, __comp);
-      if (__new_result == __last1)
-        return __result;
-      else {
-        __result = __new_result;
-        __first1 = __new_result;
-        ++__first1;
-      }
-    }
-  }
-}
-
-// find_end for bidirectional iterators.  Requires partial specialization.
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _BidirectionalIter1, class _BidirectionalIter2>
-_BidirectionalIter1
-__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
-           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
-           bidirectional_iterator_tag, bidirectional_iterator_tag)
-{
-  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);
-  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);
-  typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
-  typedef reverse_iterator<_BidirectionalIter2> _RevIter2;
-
-  _RevIter1 __rlast1(__first1);
-  _RevIter2 __rlast2(__first2);
-  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
-                               _RevIter2(__last2), __rlast2);
-
-  if (__rresult == __rlast1)
-    return __last1;
-  else {
-    _BidirectionalIter1 __result = __rresult.base();
-    advance(__result, -distance(__first2, __last2));
-    return __result;
-  }
-}
-
-template <class _BidirectionalIter1, class _BidirectionalIter2,
-          class _BinaryPredicate>
-_BidirectionalIter1
-__find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,
-           _BidirectionalIter2 __first2, _BidirectionalIter2 __last2,
-           bidirectional_iterator_tag, bidirectional_iterator_tag, 
-           _BinaryPredicate __comp)
-{
-  __STL_REQUIRES(_BidirectionalIter1, _BidirectionalIterator);
-  __STL_REQUIRES(_BidirectionalIter2, _BidirectionalIterator);
-  typedef reverse_iterator<_BidirectionalIter1> _RevIter1;
-  typedef reverse_iterator<_BidirectionalIter2> _RevIter2;
-
-  _RevIter1 __rlast1(__first1);
-  _RevIter2 __rlast2(__first2);
-  _RevIter1 __rresult = search(_RevIter1(__last1), __rlast1,
-                               _RevIter2(__last2), __rlast2,
-                               __comp);
-
-  if (__rresult == __rlast1)
-    return __last1;
-  else {
-    _BidirectionalIter1 __result = __rresult.base();
-    advance(__result, -distance(__first2, __last2));
-    return __result;
-  }
-}
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-// Dispatching functions for find_end.
-
-template <class _ForwardIter1, class _ForwardIter2>
-inline _ForwardIter1 
-find_end(_ForwardIter1 __first1, _ForwardIter1 __last1, 
-         _ForwardIter2 __first2, _ForwardIter2 __last2)
-{
-  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);
-  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);
-  __STL_REQUIRES_BINARY_OP(_OP_EQUAL, bool,
-   typename iterator_traits<_ForwardIter1>::value_type,
-   typename iterator_traits<_ForwardIter2>::value_type);
-  return __find_end(__first1, __last1, __first2, __last2,
-                    __ITERATOR_CATEGORY(__first1),
-                    __ITERATOR_CATEGORY(__first2));
-}
-
-template <class _ForwardIter1, class _ForwardIter2, 
-          class _BinaryPredicate>
-inline _ForwardIter1 
-find_end(_ForwardIter1 __first1, _ForwardIter1 __last1, 
-         _ForwardIter2 __first2, _ForwardIter2 __last2,
-         _BinaryPredicate __comp)
-{
-  __STL_REQUIRES(_ForwardIter1, _ForwardIterator);
-  __STL_REQUIRES(_ForwardIter2, _ForwardIterator);
-  __STL_BINARY_FUNCTION_CHECK(_BinaryPredicate, bool,
-   typename iterator_traits<_ForwardIter1>::value_type,
-   typename iterator_traits<_ForwardIter2>::value_type);
-
-  return __find_end(__first1, __last1, __first2, __last2,
-                    __ITERATOR_CATEGORY(__first1),
-                    __ITERATOR_CATEGORY(__first2),
-                    __comp);
-}
-
-// is_heap, a predicate testing whether or not a range is
-// a heap.  This function is an extension, not part of the C++
-// standard.
-
-template <class _RandomAccessIter, class _Distance>
-bool __is_heap(_RandomAccessIter __first, _Distance __n)
-{
-  _Distance __parent = 0;
-  for (_Distance __child = 1; __child < __n; ++__child) {
-    if (__first[__parent] < __first[__child]) 
-      return false;
-    if ((__child & 1) == 0)
-      ++__parent;
-  }
-  return true;
-}
-
-template <class _RandomAccessIter, class _Distance, class _StrictWeakOrdering>
-bool __is_heap(_RandomAccessIter __first, _StrictWeakOrdering __comp,
-               _Distance __n)
-{
-  _Distance __parent = 0;
-  for (_Distance __child = 1; __child < __n; ++__child) {
-    if (__comp(__first[__parent], __first[__child]))
-      return false;
-    if ((__child & 1) == 0)
-      ++__parent;
-  }
-  return true;
-}
-
-template <class _RandomAccessIter>
-inline bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last)
-{
-  __STL_REQUIRES(_RandomAccessIter, _RandomAccessIterator);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIter>::value_type,
-                 _LessThanComparable);
-  return __is_heap(__first, __last - __first);
-}
-
-
-template <class _RandomAccessIter, class _StrictWeakOrdering>
-inline bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,
-                    _StrictWeakOrdering __comp)
-{
-  __STL_REQUIRES(_RandomAccessIter, _RandomAccessIterator);
-  __STL_BINARY_FUNCTION_CHECK(_StrictWeakOrdering, bool, 
-         typename iterator_traits<_RandomAccessIter>::value_type, 
-         typename iterator_traits<_RandomAccessIter>::value_type);
-  return __is_heap(__first, __comp, __last - __first);
-}
-
-// is_sorted, a predicated testing whether a range is sorted in
-// nondescending order.  This is an extension, not part of the C++
-// standard.
-
-template <class _ForwardIter>
-bool is_sorted(_ForwardIter __first, _ForwardIter __last)
-{
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_REQUIRES(typename iterator_traits<_ForwardIter>::value_type,
-                 _LessThanComparable);
-  if (__first == __last)
-    return true;
-
-  _ForwardIter __next = __first;
-  for (++__next; __next != __last; __first = __next, ++__next) {
-    if (*__next < *__first)
-      return false;
-  }
-
-  return true;
-}
-
-template <class _ForwardIter, class _StrictWeakOrdering>
-bool is_sorted(_ForwardIter __first, _ForwardIter __last,
-               _StrictWeakOrdering __comp)
-{
-  __STL_REQUIRES(_ForwardIter, _ForwardIterator);
-  __STL_BINARY_FUNCTION_CHECK(_StrictWeakOrdering, bool, 
-        typename iterator_traits<_ForwardIter>::value_type,
-        typename iterator_traits<_ForwardIter>::value_type);
-  if (__first == __last)
-    return true;
-
-  _ForwardIter __next = __first;
-  for (++__next; __next != __last; __first = __next, ++__next) {
-    if (__comp(*__next, *__first))
-      return false;
-  }
-
-  return true;
-}
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1209
-#endif
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_ALGO_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_algobase.h b/lib/include/stl/stl_algobase.h
deleted file mode 100644
index 41380f2..0000000
--- a/lib/include/stl/stl_algobase.h
+++ /dev/null
@@ -1,698 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996-1998
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-
-#ifndef __SGI_STL_INTERNAL_ALGOBASE_H
-#define __SGI_STL_INTERNAL_ALGOBASE_H
-
-#ifndef __STL_CONFIG_H
-#include <stl_config.h>
-#endif
-#ifndef __SGI_STL_INTERNAL_RELOPS
-#include <stl_relops.h>
-#endif
-#ifndef __SGI_STL_INTERNAL_PAIR_H
-#include <stl_pair.h>
-#endif
-#ifndef __TYPE_TRAITS_H
-#include <type_traits.h>
-#endif
-
-#include <string.h>
-#include <limits.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <new>
-
-#ifndef STM32PLUS_BUILD
-#ifdef __STL_USE_NEW_IOSTREAMS 
-#include <iosfwd>
-#else /* __STL_USE_NEW_IOSTREAMS */
-#include <iostream.h>
-#endif /* __STL_USE_NEW_IOSTREAMS */
-#endif
-
-#ifndef __SGI_STL_INTERNAL_ITERATOR_H
-#include <stl_iterator_base.h>
-#include <stl_iterator.h>
-#endif
-
-// We pick up concept_checks.h from stl_iterator_base.h.
-
-__STL_BEGIN_NAMESPACE
-
-// swap and iter_swap
-
-template <class _ForwardIter1, class _ForwardIter2, class _Tp>
-inline void __iter_swap(_ForwardIter1 __a, _ForwardIter2 __b, _Tp*) {
-  _Tp __tmp = *__a;
-  *__a = *__b;
-  *__b = __tmp;
-}
-
-template <class _ForwardIter1, class _ForwardIter2>
-inline void iter_swap(_ForwardIter1 __a, _ForwardIter2 __b) {
-  __STL_REQUIRES(_ForwardIter1, _Mutable_ForwardIterator);
-  __STL_REQUIRES(_ForwardIter2, _Mutable_ForwardIterator);
-  __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter1>::value_type,
-                    typename iterator_traits<_ForwardIter2>::value_type);
-  __STL_CONVERTIBLE(typename iterator_traits<_ForwardIter2>::value_type,
-                    typename iterator_traits<_ForwardIter1>::value_type);
-  __iter_swap(__a, __b, __VALUE_TYPE(__a));
-}
-
-template <class _Tp>
-inline void swap(_Tp& __a, _Tp& __b) {
-  __STL_REQUIRES(_Tp, _Assignable);
-  _Tp __tmp = __a;
-  __a = __b;
-  __b = __tmp;
-}
-
-//--------------------------------------------------
-// min and max
-
-#if !defined(__BORLANDC__) || __BORLANDC__ >= 0x540 /* C++ Builder 4.0 */
-
-#undef min
-#undef max
-
-template <class _Tp>
-inline const _Tp& min(const _Tp& __a, const _Tp& __b) {
-  __STL_REQUIRES(_Tp, _LessThanComparable);
-  return __b < __a ? __b : __a;
-}
-
-template <class _Tp>
-inline const _Tp& max(const _Tp& __a, const _Tp& __b) {
-  __STL_REQUIRES(_Tp, _LessThanComparable);
-  return  __a < __b ? __b : __a;
-}
-
-#endif /* __BORLANDC__ */
-
-template <class _Tp, class _Compare>
-inline const _Tp& min(const _Tp& __a, const _Tp& __b, _Compare __comp) {
-  return __comp(__b, __a) ? __b : __a;
-}
-
-template <class _Tp, class _Compare>
-inline const _Tp& max(const _Tp& __a, const _Tp& __b, _Compare __comp) {
-  return __comp(__a, __b) ? __b : __a;
-}
-
-//--------------------------------------------------
-// copy
-
-// All of these auxiliary functions serve two purposes.  (1) Replace
-// calls to copy with memmove whenever possible.  (Memmove, not memcpy,
-// because the input and output ranges are permitted to overlap.)
-// (2) If we're using random access iterators, then write the loop as
-// a for loop with an explicit count.
-
-template <class _InputIter, class _OutputIter, class _Distance>
-inline _OutputIter __copy(_InputIter __first, _InputIter __last,
-                          _OutputIter __result,
-                          input_iterator_tag, _Distance*)
-{
-  for ( ; __first != __last; ++__result, ++__first)
-    *__result = *__first;
-  return __result;
-}
-
-template <class _RandomAccessIter, class _OutputIter, class _Distance>
-inline _OutputIter
-__copy(_RandomAccessIter __first, _RandomAccessIter __last,
-       _OutputIter __result, random_access_iterator_tag, _Distance*)
-{
-  for (_Distance __n = __last - __first; __n > 0; --__n) {
-    *__result = *__first;
-    ++__first;
-    ++__result;
-  }
-  return __result;
-}
-
-template <class _Tp>
-inline _Tp*
-__copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result) {
-  memmove(__result, __first, sizeof(_Tp) * (__last - __first));
-  return __result + (__last - __first);
-}
-
-#if defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER)
-
-template <class _InputIter, class _OutputIter>
-inline _OutputIter __copy_aux2(_InputIter __first, _InputIter __last,
-                               _OutputIter __result, __false_type) {
-  return __copy(__first, __last, __result,
-                __ITERATOR_CATEGORY(__first),
-                __DISTANCE_TYPE(__first));
-}
-
-template <class _InputIter, class _OutputIter>
-inline _OutputIter __copy_aux2(_InputIter __first, _InputIter __last,
-                               _OutputIter __result, __true_type) {
-  return __copy(__first, __last, __result,
-                __ITERATOR_CATEGORY(__first),
-                __DISTANCE_TYPE(__first));
-}
-
-#ifndef __USLC__
-
-template <class _Tp>
-inline _Tp* __copy_aux2(_Tp* __first, _Tp* __last, _Tp* __result,
-                        __true_type) {
-  return __copy_trivial(__first, __last, __result);
-}
-
-#endif /* __USLC__ */
-
-template <class _Tp>
-inline _Tp* __copy_aux2(const _Tp* __first, const _Tp* __last, _Tp* __result,
-                        __true_type) {
-  return __copy_trivial(__first, __last, __result);
-}
-
-
-template <class _InputIter, class _OutputIter, class _Tp>
-inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last,
-                              _OutputIter __result, _Tp*) {
-  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator
-          _Trivial;
-  return __copy_aux2(__first, __last, __result, _Trivial());
-}
-
-template <class _InputIter, class _OutputIter>
-inline _OutputIter copy(_InputIter __first, _InputIter __last,
-                        _OutputIter __result) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  return __copy_aux(__first, __last, __result, __VALUE_TYPE(__first));
-}
-
-// Hack for compilers that don't have partial ordering of function templates
-// but do have partial specialization of class templates.
-#elif defined(__STL_CLASS_PARTIAL_SPECIALIZATION)
-
-template <class _InputIter, class _OutputIter, class _BoolType>
-struct __copy_dispatch {
-  static _OutputIter copy(_InputIter __first, _InputIter __last,
-                          _OutputIter __result) {
-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;
-    typedef typename iterator_traits<_InputIter>::difference_type _Distance;
-    return __copy(__first, __last, __result, _Category(), (_Distance*) 0);
-  }
-};
-
-template <class _Tp>
-struct __copy_dispatch<_Tp*, _Tp*, __true_type>
-{
-  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {
-    return __copy_trivial(__first, __last, __result);
-  }
-};
-
-template <class _Tp>
-struct __copy_dispatch<const _Tp*, _Tp*, __true_type>
-{
-  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {
-    return __copy_trivial(__first, __last, __result);
-  }
-};
-
-template <class _InputIter, class _OutputIter>
-inline _OutputIter copy(_InputIter __first, _InputIter __last,
-                        _OutputIter __result) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  typedef typename iterator_traits<_InputIter>::value_type _Tp;
-  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator
-          _Trivial;
-  return __copy_dispatch<_InputIter, _OutputIter, _Trivial>
-    ::copy(__first, __last, __result);
-}
-
-// Fallback for compilers with neither partial ordering nor partial
-// specialization.  Define the faster version for the basic builtin
-// types.
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _InputIter, class _OutputIter>
-inline _OutputIter copy(_InputIter __first, _InputIter __last,
-                        _OutputIter __result)
-{
-  return __copy(__first, __last, __result,
-                __ITERATOR_CATEGORY(__first),
-                __DISTANCE_TYPE(__first));
-}
-
-#define __SGI_STL_DECLARE_COPY_TRIVIAL(_Tp)                                \
-  inline _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) { \
-    memmove(__result, __first, sizeof(_Tp) * (__last - __first));          \
-    return __result + (__last - __first);                                  \
-  }
-
-__SGI_STL_DECLARE_COPY_TRIVIAL(char)
-__SGI_STL_DECLARE_COPY_TRIVIAL(signed char)
-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned char)
-__SGI_STL_DECLARE_COPY_TRIVIAL(short)
-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned short)
-__SGI_STL_DECLARE_COPY_TRIVIAL(int)
-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned int)
-__SGI_STL_DECLARE_COPY_TRIVIAL(long)
-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned long)
-#ifdef __STL_HAS_WCHAR_T
-__SGI_STL_DECLARE_COPY_TRIVIAL(wchar_t)
-#endif
-#ifdef _STL_LONG_LONG
-__SGI_STL_DECLARE_COPY_TRIVIAL(long long)
-__SGI_STL_DECLARE_COPY_TRIVIAL(unsigned long long)
-#endif 
-__SGI_STL_DECLARE_COPY_TRIVIAL(float)
-__SGI_STL_DECLARE_COPY_TRIVIAL(double)
-__SGI_STL_DECLARE_COPY_TRIVIAL(long double)
-
-#undef __SGI_STL_DECLARE_COPY_TRIVIAL
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-//--------------------------------------------------
-// copy_backward
-
-template <class _BidirectionalIter1, class _BidirectionalIter2, 
-          class _Distance>
-inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first, 
-                                           _BidirectionalIter1 __last, 
-                                           _BidirectionalIter2 __result,
-                                           bidirectional_iterator_tag,
-                                           _Distance*)
-{
-  while (__first != __last)
-    *--__result = *--__last;
-  return __result;
-}
-
-template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>
-inline _BidirectionalIter __copy_backward(_RandomAccessIter __first, 
-                                          _RandomAccessIter __last, 
-                                          _BidirectionalIter __result,
-                                          random_access_iterator_tag,
-                                          _Distance*)
-{
-  for (_Distance __n = __last - __first; __n > 0; --__n)
-    *--__result = *--__last;
-  return __result;
-}
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION 
-
-// This dispatch class is a workaround for compilers that do not 
-// have partial ordering of function templates.  All we're doing is
-// creating a specialization so that we can turn a call to copy_backward
-// into a memmove whenever possible.
-
-template <class _BidirectionalIter1, class _BidirectionalIter2,
-          class _BoolType>
-struct __copy_backward_dispatch
-{
-  typedef typename iterator_traits<_BidirectionalIter1>::iterator_category 
-          _Cat;
-  typedef typename iterator_traits<_BidirectionalIter1>::difference_type
-          _Distance;
-
-  static _BidirectionalIter2 copy(_BidirectionalIter1 __first, 
-                                  _BidirectionalIter1 __last, 
-                                  _BidirectionalIter2 __result) {
-    return __copy_backward(__first, __last, __result, _Cat(), (_Distance*) 0);
-  }
-};
-
-template <class _Tp>
-struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
-{
-  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {
-    const ptrdiff_t _Num = __last - __first;
-    memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
-    return __result - _Num;
-  }
-};
-
-template <class _Tp>
-struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>
-{
-  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {
-    return  __copy_backward_dispatch<_Tp*, _Tp*, __true_type>
-      ::copy(__first, __last, __result);
-  }
-};
-
-template <class _BI1, class _BI2>
-inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {
-  __STL_REQUIRES(_BI1, _BidirectionalIterator);
-  __STL_REQUIRES(_BI2, _Mutable_BidirectionalIterator);
-  __STL_CONVERTIBLE(typename iterator_traits<_BI1>::value_type,
-                    typename iterator_traits<_BI2>::value_type);
-  typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>
-                        ::has_trivial_assignment_operator
-          _Trivial;
-  return __copy_backward_dispatch<_BI1, _BI2, _Trivial>
-              ::copy(__first, __last, __result);
-}
-
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _BI1, class _BI2>
-inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result) {
-  return __copy_backward(__first, __last, __result,
-                         __ITERATOR_CATEGORY(__first),
-                         __DISTANCE_TYPE(__first));
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-//--------------------------------------------------
-// copy_n (not part of the C++ standard)
-
-template <class _InputIter, class _Size, class _OutputIter>
-pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,
-                                       _OutputIter __result,
-                                       input_iterator_tag) {
-  for ( ; __count > 0; --__count) {
-    *__result = *__first;
-    ++__first;
-    ++__result;
-  }
-  return pair<_InputIter, _OutputIter>(__first, __result);
-}
-
-template <class _RAIter, class _Size, class _OutputIter>
-inline pair<_RAIter, _OutputIter>
-__copy_n(_RAIter __first, _Size __count,
-         _OutputIter __result,
-         random_access_iterator_tag) {
-  _RAIter __last = __first + __count;
-  return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));
-}
-
-template <class _InputIter, class _Size, class _OutputIter>
-inline pair<_InputIter, _OutputIter>
-__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
-  return __copy_n(__first, __count, __result,
-                  __ITERATOR_CATEGORY(__first));
-}
-
-template <class _InputIter, class _Size, class _OutputIter>
-inline pair<_InputIter, _OutputIter>
-copy_n(_InputIter __first, _Size __count, _OutputIter __result) {
-  __STL_REQUIRES(_InputIter, _InputIterator);
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  return __copy_n(__first, __count, __result);
-}
-
-//--------------------------------------------------
-// fill and fill_n
-
-
-template <class _ForwardIter, class _Tp>
-void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value) {
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  for ( ; __first != __last; ++__first)
-    *__first = __value;
-}
-
-template <class _OutputIter, class _Size, class _Tp>
-_OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __value) {
-  __STL_REQUIRES(_OutputIter, _OutputIterator);
-  for ( ; __n > 0; --__n, ++__first)
-    *__first = __value;
-  return __first;
-}
-
-// Specialization: for one-byte types we can use memset.
-
-inline void fill(unsigned char* __first, unsigned char* __last,
-                 const unsigned char& __c) {
-  unsigned char __tmp = __c;
-  memset(__first, __tmp, __last - __first);
-}
-
-inline void fill(signed char* __first, signed char* __last,
-                 const signed char& __c) {
-  signed char __tmp = __c;
-  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
-}
-
-inline void fill(char* __first, char* __last, const char& __c) {
-  char __tmp = __c;
-  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Size>
-inline unsigned char* fill_n(unsigned char* __first, _Size __n,
-                             const unsigned char& __c) {
-  fill(__first, __first + __n, __c);
-  return __first + __n;
-}
-
-template <class _Size>
-inline signed char* fill_n(char* __first, _Size __n,
-                           const signed char& __c) {
-  fill(__first, __first + __n, __c);
-  return __first + __n;
-}
-
-template <class _Size>
-inline char* fill_n(char* __first, _Size __n, const char& __c) {
-  fill(__first, __first + __n, __c);
-  return __first + __n;
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-//--------------------------------------------------
-// equal and mismatch
-
-template <class _InputIter1, class _InputIter2>
-pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
-                                        _InputIter1 __last1,
-                                        _InputIter2 __first2) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _EqualityComparable);
-  __STL_REQUIRES(typename iterator_traits<_InputIter2>::value_type,
-                 _EqualityComparable);
-  while (__first1 != __last1 && *__first1 == *__first2) {
-    ++__first1;
-    ++__first2;
-  }
-  return pair<_InputIter1, _InputIter2>(__first1, __first2);
-}
-
-template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
-pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
-                                        _InputIter1 __last1,
-                                        _InputIter2 __first2,
-                                        _BinaryPredicate __binary_pred) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
-    ++__first1;
-    ++__first2;
-  }
-  return pair<_InputIter1, _InputIter2>(__first1, __first2);
-}
-
-template <class _InputIter1, class _InputIter2>
-inline bool equal(_InputIter1 __first1, _InputIter1 __last1,
-                  _InputIter2 __first2) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _EqualityComparable);
-  __STL_REQUIRES(typename iterator_traits<_InputIter2>::value_type,
-                 _EqualityComparable);
-  for ( ; __first1 != __last1; ++__first1, ++__first2)
-    if (*__first1 != *__first2)
-      return false;
-  return true;
-}
-
-template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
-inline bool equal(_InputIter1 __first1, _InputIter1 __last1,
-                  _InputIter2 __first2, _BinaryPredicate __binary_pred) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  for ( ; __first1 != __last1; ++__first1, ++__first2)
-    if (!__binary_pred(*__first1, *__first2))
-      return false;
-  return true;
-}
-
-//--------------------------------------------------
-// lexicographical_compare and lexicographical_compare_3way.
-// (the latter is not part of the C++ standard.)
-
-template <class _InputIter1, class _InputIter2>
-bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
-                             _InputIter2 __first2, _InputIter2 __last2) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _LessThanComparable);
-  __STL_REQUIRES(typename iterator_traits<_InputIter2>::value_type,
-                 _LessThanComparable);
-  for ( ; __first1 != __last1 && __first2 != __last2
-        ; ++__first1, ++__first2) {
-    if (*__first1 < *__first2)
-      return true;
-    if (*__first2 < *__first1)
-      return false;
-  }
-  return __first1 == __last1 && __first2 != __last2;
-}
-
-template <class _InputIter1, class _InputIter2, class _Compare>
-bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
-                             _InputIter2 __first2, _InputIter2 __last2,
-                             _Compare __comp) {
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  for ( ; __first1 != __last1 && __first2 != __last2
-        ; ++__first1, ++__first2) {
-    if (__comp(*__first1, *__first2))
-      return true;
-    if (__comp(*__first2, *__first1))
-      return false;
-  }
-  return __first1 == __last1 && __first2 != __last2;
-}
-
-inline bool 
-lexicographical_compare(const unsigned char* __first1,
-                        const unsigned char* __last1,
-                        const unsigned char* __first2,
-                        const unsigned char* __last2)
-{
-  const size_t __len1 = __last1 - __first1;
-  const size_t __len2 = __last2 - __first2;
-  const int __result = memcmp(__first1, __first2, min(__len1, __len2));
-  return __result != 0 ? __result < 0 : __len1 < __len2;
-}
-
-inline bool lexicographical_compare(const char* __first1, const char* __last1,
-                                    const char* __first2, const char* __last2)
-{
-#if CHAR_MAX == SCHAR_MAX
-  return lexicographical_compare((const signed char*) __first1,
-                                 (const signed char*) __last1,
-                                 (const signed char*) __first2,
-                                 (const signed char*) __last2);
-#else /* CHAR_MAX == SCHAR_MAX */
-  return lexicographical_compare((const unsigned char*) __first1,
-                                 (const unsigned char*) __last1,
-                                 (const unsigned char*) __first2,
-                                 (const unsigned char*) __last2);
-#endif /* CHAR_MAX == SCHAR_MAX */
-}
-
-template <class _InputIter1, class _InputIter2>
-int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
-                                   _InputIter2 __first2, _InputIter2 __last2)
-{
-  while (__first1 != __last1 && __first2 != __last2) {
-    if (*__first1 < *__first2)
-      return -1;
-    if (*__first2 < *__first1)
-      return 1;
-    ++__first1;
-    ++__first2;
-  }
-  if (__first2 == __last2) {
-    return !(__first1 == __last1);
-  }
-  else {
-    return -1;
-  }
-}
-
-inline int
-__lexicographical_compare_3way(const unsigned char* __first1,
-                               const unsigned char* __last1,
-                               const unsigned char* __first2,
-                               const unsigned char* __last2)
-{
-  const ptrdiff_t __len1 = __last1 - __first1;
-  const ptrdiff_t __len2 = __last2 - __first2;
-  const int __result = memcmp(__first1, __first2, min(__len1, __len2));
-  return __result != 0 ? __result 
-                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));
-}
-
-inline int 
-__lexicographical_compare_3way(const char* __first1, const char* __last1,
-                               const char* __first2, const char* __last2)
-{
-#if CHAR_MAX == SCHAR_MAX
-  return __lexicographical_compare_3way(
-                                (const signed char*) __first1,
-                                (const signed char*) __last1,
-                                (const signed char*) __first2,
-                                (const signed char*) __last2);
-#else
-  return __lexicographical_compare_3way((const unsigned char*) __first1,
-                                        (const unsigned char*) __last1,
-                                        (const unsigned char*) __first2,
-                                        (const unsigned char*) __last2);
-#endif
-}
-
-template <class _InputIter1, class _InputIter2>
-int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,
-                                 _InputIter2 __first2, _InputIter2 __last2)
-{
-  __STL_REQUIRES(_InputIter1, _InputIterator);
-  __STL_REQUIRES(_InputIter2, _InputIterator);
-  __STL_REQUIRES(typename iterator_traits<_InputIter1>::value_type,
-                 _LessThanComparable);
-  __STL_REQUIRES(typename iterator_traits<_InputIter2>::value_type,
-                 _LessThanComparable);
-  return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);
-}
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_ALGOBASE_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_alloc.h b/lib/include/stl/stl_alloc.h
deleted file mode 100644
index 64a8186..0000000
--- a/lib/include/stl/stl_alloc.h
+++ /dev/null
@@ -1,913 +0,0 @@
-/*
- * Copyright (c) 1996-1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_ALLOC_H
-#define __SGI_STL_INTERNAL_ALLOC_H
-
-#ifdef __SUNPRO_CC
-#  define __PRIVATE public
-   // Extra access restrictions prevent us from really making some things
-   // private.
-#else
-#  define __PRIVATE private
-#endif
-
-#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG
-#  define __USE_MALLOC
-#endif
-
-
-// This implements some standard node allocators.  These are
-// NOT the same as the allocators in the C++ draft standard or in
-// in the original STL.  They do not encapsulate different pointer
-// types; indeed we assume that there is only one pointer type.
-// The allocation primitives are intended to allocate individual objects,
-// not larger arenas as with the original STL allocators.
-
-#ifdef STM32PLUS_BUILD
-#define __THROW_BAD_ALLOC { for(;;); }    // this will intentionally hang the MCU
-#else
-#ifndef __THROW_BAD_ALLOC
-#  if defined(__STL_NO_BAD_ALLOC) || !defined(__STL_USE_EXCEPTIONS)
-#    include <stdio.h>
-#    include <stdlib.h>
-#    define __THROW_BAD_ALLOC fprintf(stderr, "out of memory\n"); exit(1)
-#  else /* Standard conforming out-of-memory handling */
-#    include <new>
-#    define __THROW_BAD_ALLOC throw std::bad_alloc()
-#  endif
-#endif
-#endif
-
-#include <stddef.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-#ifndef __RESTRICT
-#  define __RESTRICT
-#endif
-
-#ifdef __STL_THREADS
-# include <stl_threads.h>
-# define __NODE_ALLOCATOR_THREADS true
-# ifdef __STL_SGI_THREADS
-  // We test whether threads are in use before locking.
-  // Perhaps this should be moved into stl_threads.h, but that
-  // probably makes it harder to avoid the procedure call when
-  // it isn't needed.
-    extern "C" {
-      extern int __us_rsthread_malloc;
-    }
-  // The above is copied from malloc.h.  Including <malloc.h>
-  // would be cleaner but fails with certain levels of standard
-  // conformance.
-#   define __NODE_ALLOCATOR_LOCK if (threads && __us_rsthread_malloc) \
-                { _S_node_allocator_lock._M_acquire_lock(); }
-#   define __NODE_ALLOCATOR_UNLOCK if (threads && __us_rsthread_malloc) \
-                { _S_node_allocator_lock._M_release_lock(); }
-# else /* !__STL_SGI_THREADS */
-#   define __NODE_ALLOCATOR_LOCK \
-        { if (threads) _S_node_allocator_lock._M_acquire_lock(); }
-#   define __NODE_ALLOCATOR_UNLOCK \
-        { if (threads) _S_node_allocator_lock._M_release_lock(); }
-# endif
-#else
-//  Thread-unsafe
-#   define __NODE_ALLOCATOR_LOCK
-#   define __NODE_ALLOCATOR_UNLOCK
-#   define __NODE_ALLOCATOR_THREADS false
-#endif
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#endif
-
-
-#ifdef STM32PLUS_BUILD
-#define stm32_malloc malloc
-#define stm32_free free
-#define stm32_realloc realloc
-#endif
-
-// Malloc-based allocator.  Typically slower than default below.
-// Typically thread-safe and more storage efficient.
-#ifdef __STL_STATIC_TEMPLATE_MEMBER_BUG
-# ifdef __DECLARE_GLOBALS_HERE
-    void (* __malloc_alloc_oom_handler)() = 0;
-    // g++ 2.7.2 does not handle static template data members.
-# else
-    extern void (* __malloc_alloc_oom_handler)();
-# endif
-#endif
-
-template <int __inst>
-class __malloc_alloc_template {
-
-private:
-
-  static void* _S_oom_malloc(size_t);
-  static void* _S_oom_realloc(void*, size_t);
-
-#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
-  static void (* __malloc_alloc_oom_handler)();
-#endif
-
-public:
-
-  static void* allocate(size_t __n)
-  {
-    void* __result = stm32_malloc(__n);
-    if (0 == __result) __result = _S_oom_malloc(__n);
-    return __result;
-  }
-
-  static void deallocate(void* __p, size_t /* __n */)
-  {
-    stm32_free(__p);
-  }
-
-  static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)
-  {
-    void* __result = stm32_realloc(__p, __new_sz);
-    if (0 == __result) __result = _S_oom_realloc(__p, __new_sz);
-    return __result;
-  }
-
-  static void (* __set_malloc_handler(void (*__f)()))()
-  {
-    void (* __old)() = __malloc_alloc_oom_handler;
-    __malloc_alloc_oom_handler = __f;
-    return(__old);
-  }
-
-};
-
-
-// malloc_alloc out-of-memory handling
-
-#ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG
-template <int __inst>
-void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;
-#endif
-
-template <int __inst>
-void*
-__malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)
-{
-    void (* __my_malloc_handler)();
-    void* __result;
-
-    for (;;) {
-        __my_malloc_handler = __malloc_alloc_oom_handler;
-        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
-        (*__my_malloc_handler)();
-        __result = malloc(__n);
-        if (__result) return(__result);
-    }
-}
-
-template <int __inst>
-void* __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n)
-{
-    void (* __my_malloc_handler)();
-    void* __result;
-
-    for (;;) {
-        __my_malloc_handler = __malloc_alloc_oom_handler;
-        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }
-        (*__my_malloc_handler)();
-        __result = realloc(__p, __n);
-        if (__result) return(__result);
-    }
-}
-
-typedef __malloc_alloc_template<0> malloc_alloc;
-
-template<class _Tp, class _Alloc>
-class simple_alloc {
-
-public:
-    static _Tp* allocate(size_t __n)
-      { return 0 == __n ? 0 : (_Tp*) _Alloc::allocate(__n * sizeof (_Tp)); }
-    static _Tp* allocate(void)
-      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }
-    static void deallocate(_Tp* __p, size_t __n)
-      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }
-    static void deallocate(_Tp* __p)
-      { _Alloc::deallocate(__p, sizeof (_Tp)); }
-};
-
-// Allocator adaptor to check size arguments for debugging.
-// Reports errors using assert.  Checking can be disabled with
-// NDEBUG, but it's far better to just use the underlying allocator
-// instead when no checking is desired.
-// There is some evidence that this can confuse Purify.
-template <class _Alloc>
-class debug_alloc {
-
-private:
-
-  enum {_S_extra = 8};  // Size of space used to store size.  Note
-                        // that this must be large enough to preserve
-                        // alignment.
-
-public:
-
-  static void* allocate(size_t __n)
-  {
-    char* __result = (char*)_Alloc::allocate(__n + (int) _S_extra);
-    *(size_t*)__result = __n;
-    return __result + (int) _S_extra;
-  }
-
-  static void deallocate(void* __p, size_t __n)
-  {
-    char* __real_p = (char*)__p - (int) _S_extra;
-    assert(*(size_t*)__real_p == __n);
-    _Alloc::deallocate(__real_p, __n + (int) _S_extra);
-  }
-
-  static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz)
-  {
-    char* __real_p = (char*)__p - (int) _S_extra;
-    assert(*(size_t*)__real_p == __old_sz);
-    char* __result = (char*)
-      _Alloc::reallocate(__real_p, __old_sz + (int) _S_extra,
-                                   __new_sz + (int) _S_extra);
-    *(size_t*)__result = __new_sz;
-    return __result + (int) _S_extra;
-  }
-
-};
-
-
-# ifdef __USE_MALLOC
-
-typedef malloc_alloc alloc;
-typedef malloc_alloc single_client_alloc;
-
-# else
-
-
-// Default node allocator.
-// With a reasonable compiler, this should be roughly as fast as the
-// original STL class-specific allocators, but with less fragmentation.
-// Default_alloc_template parameters are experimental and MAY
-// DISAPPEAR in the future.  Clients should just use alloc for now.
-//
-// Important implementation properties:
-// 1. If the client request an object of size > _MAX_BYTES, the resulting
-//    object will be obtained directly from malloc.
-// 2. In all other cases, we allocate an object of size exactly
-//    _S_round_up(requested_size).  Thus the client has enough size
-//    information that we can return the object to the proper free list
-//    without permanently losing part of the object.
-//
-
-// The first template parameter specifies whether more than one thread
-// may use this allocator.  It is safe to allocate an object from
-// one instance of a default_alloc and deallocate it with another
-// one.  This effectively transfers its ownership to the second one.
-// This may have undesirable effects on reference locality.
-// The second parameter is unreferenced and serves only to allow the
-// creation of multiple default_alloc instances.
-// Node that containers built on different allocator instances have
-// different types, limiting the utility of this approach.
-
-#if defined(__SUNPRO_CC) || defined(__GNUC__)
-// breaks if we make these template class members:
-  enum {_ALIGN = 8};
-  enum {_MAX_BYTES = 128};
-  enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN
-#endif
-
-template <bool threads, int inst>
-class __default_alloc_template {
-
-private:
-  // Really we should use static const int x = N
-  // instead of enum { x = N }, but few compilers accept the former.
-#if ! (defined(__SUNPRO_CC) || defined(__GNUC__))
-    enum {_ALIGN = 8};
-    enum {_MAX_BYTES = 128};
-    enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN
-# endif
-  static size_t
-  _S_round_up(size_t __bytes) 
-    { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); }
-
-__PRIVATE:
-  union _Obj {
-        union _Obj* _M_free_list_link;
-        char _M_client_data[1];    /* The client sees this.        */
-  };
-private:
-# if defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)
-    static _Obj* __STL_VOLATILE _S_free_list[]; 
-        // Specifying a size results in duplicate def for 4.1
-# else
-    static _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; 
-# endif
-  static  size_t _S_freelist_index(size_t __bytes) {
-        return (((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1);
-  }
-
-  // Returns an object of size __n, and optionally adds to size __n free list.
-  static void* _S_refill(size_t __n);
-  // Allocates a chunk for nobjs of size size.  nobjs may be reduced
-  // if it is inconvenient to allocate the requested number.
-  static char* _S_chunk_alloc(size_t __size, int& __nobjs);
-
-  // Chunk allocation state.
-  static char* _S_start_free;
-  static char* _S_end_free;
-  static size_t _S_heap_size;
-
-# ifdef __STL_THREADS
-    static _STL_mutex_lock _S_node_allocator_lock;
-# endif
-
-    // It would be nice to use _STL_auto_lock here.  But we
-    // don't need the nullptr check.  And we do need a test whether
-    // threads have actually been started.
-    class _Lock;
-    friend class _Lock;
-    class _Lock {
-        public:
-            _Lock() { __NODE_ALLOCATOR_LOCK; }
-            ~_Lock() { __NODE_ALLOCATOR_UNLOCK; }
-    };
-
-public:
-
-  /* __n must be > 0      */
-  static void* allocate(size_t __n)
-  {
-    void* __ret = 0;
-
-    if (__n > (size_t) _MAX_BYTES) {
-      __ret = malloc_alloc::allocate(__n);
-    }
-    else {
-      _Obj* __STL_VOLATILE* __my_free_list
-          = _S_free_list + _S_freelist_index(__n);
-      // Acquire the lock here with a constructor call.
-      // This ensures that it is released in exit or during stack
-      // unwinding.
-#     ifndef _NOTHREADS
-      /*REFERENCED*/
-      _Lock __lock_instance;
-#     endif
-      _Obj* __RESTRICT __result = *__my_free_list;
-      if (__result == 0)
-        __ret = _S_refill(_S_round_up(__n));
-      else {
-        *__my_free_list = __result -> _M_free_list_link;
-        __ret = __result;
-      }
-    }
-
-    return __ret;
-  };
-
-  /* __p may not be 0 */
-  static void deallocate(void* __p, size_t __n)
-  {
-    if (__n > (size_t) _MAX_BYTES)
-      malloc_alloc::deallocate(__p, __n);
-    else {
-      _Obj* __STL_VOLATILE*  __my_free_list
-          = _S_free_list + _S_freelist_index(__n);
-      _Obj* __q = (_Obj*)__p;
-
-      // acquire lock
-#       ifndef _NOTHREADS
-      /*REFERENCED*/
-      _Lock __lock_instance;
-#       endif /* _NOTHREADS */
-      __q -> _M_free_list_link = *__my_free_list;
-      *__my_free_list = __q;
-      // lock is released here
-    }
-  }
-
-  static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz);
-
-} ;
-
-typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;
-typedef __default_alloc_template<false, 0> single_client_alloc;
-
-template <bool __threads, int __inst>
-inline bool operator==(const __default_alloc_template<__threads, __inst>&,
-                       const __default_alloc_template<__threads, __inst>&)
-{
-  return true;
-}
-
-# ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-template <bool __threads, int __inst>
-inline bool operator!=(const __default_alloc_template<__threads, __inst>&,
-                       const __default_alloc_template<__threads, __inst>&)
-{
-  return false;
-}
-# endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-
-
-/* We allocate memory in large chunks in order to avoid fragmenting     */
-/* the malloc heap too much.                                            */
-/* We assume that size is properly aligned.                             */
-/* We hold the allocation lock.                                         */
-template <bool __threads, int __inst>
-char*
-__default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size, 
-                                                            int& __nobjs)
-{
-    char* __result;
-    size_t __total_bytes = __size * __nobjs;
-    size_t __bytes_left = _S_end_free - _S_start_free;
-
-    if (__bytes_left >= __total_bytes) {
-        __result = _S_start_free;
-        _S_start_free += __total_bytes;
-        return(__result);
-    } else if (__bytes_left >= __size) {
-        __nobjs = (int)(__bytes_left/__size);
-        __total_bytes = __size * __nobjs;
-        __result = _S_start_free;
-        _S_start_free += __total_bytes;
-        return(__result);
-    } else {
-        size_t __bytes_to_get = 
-    2 * __total_bytes + _S_round_up(_S_heap_size >> 4);
-        // Try to make use of the left-over piece.
-        if (__bytes_left > 0) {
-            _Obj* __STL_VOLATILE* __my_free_list =
-                        _S_free_list + _S_freelist_index(__bytes_left);
-
-            ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;
-            *__my_free_list = (_Obj*)_S_start_free;
-        }
-        _S_start_free = (char*)malloc(__bytes_to_get);
-        if (0 == _S_start_free) {
-            size_t __i;
-            _Obj* __STL_VOLATILE* __my_free_list;
-      _Obj* __p;
-            // Try to make do with what we have.  That can't
-            // hurt.  We do not try smaller requests, since that tends
-            // to result in disaster on multi-process machines.
-            for (__i = __size;
-                 __i <= (size_t) _MAX_BYTES;
-                 __i += (size_t) _ALIGN) {
-                __my_free_list = _S_free_list + _S_freelist_index(__i);
-                __p = *__my_free_list;
-                if (0 != __p) {
-                    *__my_free_list = __p -> _M_free_list_link;
-                    _S_start_free = (char*)__p;
-                    _S_end_free = _S_start_free + __i;
-                    return(_S_chunk_alloc(__size, __nobjs));
-                    // Any leftover piece will eventually make it to the
-                    // right free list.
-                }
-            }
-      _S_end_free = 0;  // In case of exception.
-            _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get);
-            // This should either throw an
-            // exception or remedy the situation.  Thus we assume it
-            // succeeded.
-        }
-        _S_heap_size += __bytes_to_get;
-        _S_end_free = _S_start_free + __bytes_to_get;
-        return(_S_chunk_alloc(__size, __nobjs));
-    }
-}
-
-
-/* Returns an object of size __n, and optionally adds to size __n free list.*/
-/* We assume that __n is properly aligned.                                */
-/* We hold the allocation lock.                                         */
-template <bool __threads, int __inst>
-void*
-__default_alloc_template<__threads, __inst>::_S_refill(size_t __n)
-{
-    int __nobjs = 20;
-    char* __chunk = _S_chunk_alloc(__n, __nobjs);
-    _Obj* __STL_VOLATILE* __my_free_list;
-    _Obj* __result;
-    _Obj* __current_obj;
-    _Obj* __next_obj;
-    int __i;
-
-    if (1 == __nobjs) return(__chunk);
-    __my_free_list = _S_free_list + _S_freelist_index(__n);
-
-    /* Build free list in chunk */
-      __result = (_Obj*)__chunk;
-      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);
-      for (__i = 1; ; __i++) {
-        __current_obj = __next_obj;
-        __next_obj = (_Obj*)((char*)__next_obj + __n);
-        if (__nobjs - 1 == __i) {
-            __current_obj -> _M_free_list_link = 0;
-            break;
-        } else {
-            __current_obj -> _M_free_list_link = __next_obj;
-        }
-      }
-    return(__result);
-}
-
-template <bool threads, int inst>
-void*
-__default_alloc_template<threads, inst>::reallocate(void* __p,
-                                                    size_t __old_sz,
-                                                    size_t __new_sz)
-{
-    void* __result;
-    size_t __copy_sz;
-
-    if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES) {
-        return(realloc(__p, __new_sz));
-    }
-    if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p);
-    __result = allocate(__new_sz);
-    __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz;
-    memcpy(__result, __p, __copy_sz);
-    deallocate(__p, __old_sz);
-    return(__result);
-}
-
-#ifdef __STL_THREADS
-    template <bool __threads, int __inst>
-    _STL_mutex_lock
-    __default_alloc_template<__threads, __inst>::_S_node_allocator_lock
-        __STL_MUTEX_INITIALIZER;
-#endif
-
-
-template <bool __threads, int __inst>
-char* __default_alloc_template<__threads, __inst>::_S_start_free = 0;
-
-template <bool __threads, int __inst>
-char* __default_alloc_template<__threads, __inst>::_S_end_free = 0;
-
-template <bool __threads, int __inst>
-size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0;
-
-template <bool __threads, int __inst>
-typename __default_alloc_template<__threads, __inst>::_Obj* __STL_VOLATILE
-__default_alloc_template<__threads, __inst> ::_S_free_list[
-# if defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)
-    _NFREELISTS
-# else
-    __default_alloc_template<__threads, __inst>::_NFREELISTS
-# endif
-] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
-// The 16 zeros are necessary to make version 4.1 of the SunPro
-// compiler happy.  Otherwise it appears to allocate too little
-// space for the array.
-
-#endif /* ! __USE_MALLOC */
-
-// This implements allocators as specified in the C++ standard.  
-//
-// Note that standard-conforming allocators use many language features
-// that are not yet widely implemented.  In particular, they rely on
-// member templates, partial specialization, partial ordering of function
-// templates, the typename keyword, and the use of the template keyword
-// to refer to a template member of a dependent type.
-
-#ifdef __STL_USE_STD_ALLOCATORS
-
-template <class _Tp>
-class allocator {
-  typedef alloc _Alloc;          // The underlying allocator.
-public:
-  typedef size_t     size_type;
-  typedef ptrdiff_t  difference_type;
-  typedef _Tp*       pointer;
-  typedef const _Tp* const_pointer;
-  typedef _Tp&       reference;
-  typedef const _Tp& const_reference;
-  typedef _Tp        value_type;
-
-  template <class _Tp1> struct rebind {
-    typedef allocator<_Tp1> other;
-  };
-
-  allocator() __STL_NOTHROW {}
-  allocator(const allocator&) __STL_NOTHROW {}
-  template <class _Tp1> allocator(const allocator<_Tp1>&) __STL_NOTHROW {}
-  ~allocator() __STL_NOTHROW {}
-
-  pointer address(reference __x) const { return &__x; }
-  const_pointer address(const_reference __x) const { return &__x; }
-
-  // __n is permitted to be 0.  The C++ standard says nothing about what
-  // the return value is when __n == 0.
-  _Tp* allocate(size_type __n, const void* = 0) {
-    return __n != 0 ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp))) 
-                    : 0;
-  }
-
-  // __p is not permitted to be a null pointer.
-  void deallocate(pointer __p, size_type __n)
-    { _Alloc::deallocate(__p, __n * sizeof(_Tp)); }
-
-  size_type max_size() const __STL_NOTHROW 
-    { return size_t(-1) / sizeof(_Tp); }
-
-  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
-  void destroy(pointer __p) { __p->~_Tp(); }
-};
-
-template<>
-class allocator<void> {
-public:
-  typedef size_t      size_type;
-  typedef ptrdiff_t   difference_type;
-  typedef void*       pointer;
-  typedef const void* const_pointer;
-  typedef void        value_type;
-
-  template <class _Tp1> struct rebind {
-    typedef allocator<_Tp1> other;
-  };
-};
-
-
-template <class _T1, class _T2>
-inline bool operator==(const allocator<_T1>&, const allocator<_T2>&) 
-{
-  return true;
-}
-
-template <class _T1, class _T2>
-inline bool operator!=(const allocator<_T1>&, const allocator<_T2>&)
-{
-  return false;
-}
-
-// Allocator adaptor to turn an SGI-style allocator (e.g. alloc, malloc_alloc)
-// into a standard-conforming allocator.   Note that this adaptor does
-// *not* assume that all objects of the underlying alloc class are
-// identical, nor does it assume that all of the underlying alloc's
-// member functions are static member functions.  Note, also, that 
-// __allocator<_Tp, alloc> is essentially the same thing as allocator<_Tp>.
-
-template <class _Tp, class _Alloc>
-struct __allocator {
-  _Alloc __underlying_alloc;
-
-  typedef size_t    size_type;
-  typedef ptrdiff_t difference_type;
-  typedef _Tp*       pointer;
-  typedef const _Tp* const_pointer;
-  typedef _Tp&       reference;
-  typedef const _Tp& const_reference;
-  typedef _Tp        value_type;
-
-  template <class _Tp1> struct rebind {
-    typedef __allocator<_Tp1, _Alloc> other;
-  };
-
-  __allocator() __STL_NOTHROW {}
-  __allocator(const __allocator& __a) __STL_NOTHROW
-    : __underlying_alloc(__a.__underlying_alloc) {}
-  template <class _Tp1> 
-  __allocator(const __allocator<_Tp1, _Alloc>& __a) __STL_NOTHROW
-    : __underlying_alloc(__a.__underlying_alloc) {}
-  ~__allocator() __STL_NOTHROW {}
-
-  pointer address(reference __x) const { return &__x; }
-  const_pointer address(const_reference __x) const { return &__x; }
-
-  // __n is permitted to be 0.
-  _Tp* allocate(size_type __n, const void* = 0) {
-    return __n != 0 
-        ? static_cast<_Tp*>(__underlying_alloc.allocate(__n * sizeof(_Tp))) 
-        : 0;
-  }
-
-  // __p is not permitted to be a null pointer.
-  void deallocate(pointer __p, size_type __n)
-    { __underlying_alloc.deallocate(__p, __n * sizeof(_Tp)); }
-
-  size_type max_size() const __STL_NOTHROW 
-    { return size_t(-1) / sizeof(_Tp); }
-
-  void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); }
-  void destroy(pointer __p) { __p->~_Tp(); }
-};
-
-template <class _Alloc>
-class __allocator<void, _Alloc> {
-  typedef size_t      size_type;
-  typedef ptrdiff_t   difference_type;
-  typedef void*       pointer;
-  typedef const void* const_pointer;
-  typedef void        value_type;
-
-  template <class _Tp1> struct rebind {
-    typedef __allocator<_Tp1, _Alloc> other;
-  };
-};
-
-template <class _Tp, class _Alloc>
-inline bool operator==(const __allocator<_Tp, _Alloc>& __a1,
-                       const __allocator<_Tp, _Alloc>& __a2)
-{
-  return __a1.__underlying_alloc == __a2.__underlying_alloc;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-template <class _Tp, class _Alloc>
-inline bool operator!=(const __allocator<_Tp, _Alloc>& __a1,
-                       const __allocator<_Tp, _Alloc>& __a2)
-{
-  return __a1.__underlying_alloc != __a2.__underlying_alloc;
-}
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-// Comparison operators for all of the predifined SGI-style allocators.
-// This ensures that __allocator<malloc_alloc> (for example) will
-// work correctly.
-
-template <int inst>
-inline bool operator==(const __malloc_alloc_template<inst>&,
-                       const __malloc_alloc_template<inst>&)
-{
-  return true;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-template <int __inst>
-inline bool operator!=(const __malloc_alloc_template<__inst>&,
-                       const __malloc_alloc_template<__inst>&)
-{
-  return false;
-}
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-
-template <class _Alloc>
-inline bool operator==(const debug_alloc<_Alloc>&,
-                       const debug_alloc<_Alloc>&) {
-  return true;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-template <class _Alloc>
-inline bool operator!=(const debug_alloc<_Alloc>&,
-                       const debug_alloc<_Alloc>&) {
-  return false;
-}
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-// Another allocator adaptor: _Alloc_traits.  This serves two
-// purposes.  First, make it possible to write containers that can use
-// either SGI-style allocators or standard-conforming allocator.
-// Second, provide a mechanism so that containers can query whether or
-// not the allocator has distinct instances.  If not, the container
-// can avoid wasting a word of memory to store an empty object.
-
-// This adaptor uses partial specialization.  The general case of
-// _Alloc_traits<_Tp, _Alloc> assumes that _Alloc is a
-// standard-conforming allocator, possibly with non-equal instances
-// and non-static members.  (It still behaves correctly even if _Alloc
-// has static member and if all instances are equal.  Refinements
-// affect performance, not correctness.)
-
-// There are always two members: allocator_type, which is a standard-
-// conforming allocator type for allocating objects of type _Tp, and
-// _S_instanceless, a static const member of type bool.  If
-// _S_instanceless is true, this means that there is no difference
-// between any two instances of type allocator_type.  Furthermore, if
-// _S_instanceless is true, then _Alloc_traits has one additional
-// member: _Alloc_type.  This type encapsulates allocation and
-// deallocation of objects of type _Tp through a static interface; it
-// has two member functions, whose signatures are
-//    static _Tp* allocate(size_t)
-//    static void deallocate(_Tp*, size_t)
-
-// The fully general version.
-
-template <class _Tp, class _Allocator>
-struct _Alloc_traits
-{
-  static const bool _S_instanceless = false;
-  typedef typename _Allocator::__STL_TEMPLATE rebind<_Tp>::other 
-          allocator_type;
-};
-
-template <class _Tp, class _Allocator>
-const bool _Alloc_traits<_Tp, _Allocator>::_S_instanceless;
-
-// The version for the default allocator.
-
-template <class _Tp, class _Tp1>
-struct _Alloc_traits<_Tp, allocator<_Tp1> >
-{
-  static const bool _S_instanceless = true;
-#ifdef STM32PLUS_BUILD
-  typedef simple_alloc<_Tp, malloc_alloc> _Alloc_type;
-#else
-  typedef simple_alloc<_Tp, alloc> _Alloc_type;
-#endif
-  typedef allocator<_Tp> allocator_type;
-};
-
-// Versions for the predefined SGI-style allocators.
-
-template <class _Tp, int __inst>
-struct _Alloc_traits<_Tp, __malloc_alloc_template<__inst> >
-{
-  static const bool _S_instanceless = true;
-  typedef simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
-  typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
-};
-
-template <class _Tp, bool __threads, int __inst>
-struct _Alloc_traits<_Tp, __default_alloc_template<__threads, __inst> >
-{
-  static const bool _S_instanceless = true;
-  typedef simple_alloc<_Tp, __default_alloc_template<__threads, __inst> > 
-          _Alloc_type;
-  typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> > 
-          allocator_type;
-};
-
-template <class _Tp, class _Alloc>
-struct _Alloc_traits<_Tp, debug_alloc<_Alloc> >
-{
-  static const bool _S_instanceless = true;
-  typedef simple_alloc<_Tp, debug_alloc<_Alloc> > _Alloc_type;
-  typedef __allocator<_Tp, debug_alloc<_Alloc> > allocator_type;
-};
-
-// Versions for the __allocator adaptor used with the predefined
-// SGI-style allocators.
-
-template <class _Tp, class _Tp1, int __inst>
-struct _Alloc_traits<_Tp, 
-                     __allocator<_Tp1, __malloc_alloc_template<__inst> > >
-{
-  static const bool _S_instanceless = true;
-  typedef simple_alloc<_Tp, __malloc_alloc_template<__inst> > _Alloc_type;
-  typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;
-};
-
-template <class _Tp, class _Tp1, bool __thr, int __inst>
-struct _Alloc_traits<_Tp, 
-                      __allocator<_Tp1, 
-                                  __default_alloc_template<__thr, __inst> > >
-{
-  static const bool _S_instanceless = true;
-  typedef simple_alloc<_Tp, __default_alloc_template<__thr,__inst> > 
-          _Alloc_type;
-  typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> > 
-          allocator_type;
-};
-
-template <class _Tp, class _Tp1, class _Alloc>
-struct _Alloc_traits<_Tp, __allocator<_Tp1, debug_alloc<_Alloc> > >
-{
-  static const bool _S_instanceless = true;
-  typedef simple_alloc<_Tp, debug_alloc<_Alloc> > _Alloc_type;
-  typedef __allocator<_Tp, debug_alloc<_Alloc> > allocator_type;
-};
-
-
-#endif /* __STL_USE_STD_ALLOCATORS */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#endif
-
-__STL_END_NAMESPACE
-
-#undef __PRIVATE
-
-#endif /* __SGI_STL_INTERNAL_ALLOC_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_bvector.h b/lib/include/stl/stl_bvector.h
deleted file mode 100644
index ab48204..0000000
--- a/lib/include/stl/stl_bvector.h
+++ /dev/null
@@ -1,897 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996-1999
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_BVECTOR_H
-#define __SGI_STL_INTERNAL_BVECTOR_H
-
-__STL_BEGIN_NAMESPACE 
-
-static const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-struct _Bit_reference {
-  unsigned int* _M_p;
-  unsigned int _M_mask;
-  _Bit_reference(unsigned int* __x, unsigned int __y) 
-    : _M_p(__x), _M_mask(__y) {}
-
-public:
-  _Bit_reference() : _M_p(0), _M_mask(0) {}
-  operator bool() const { return !(!(*_M_p & _M_mask)); }
-  _Bit_reference& operator=(bool __x)
-  {
-    if (__x)  *_M_p |= _M_mask;
-    else      *_M_p &= ~_M_mask;
-    return *this;
-  }
-  _Bit_reference& operator=(const _Bit_reference& __x) 
-    { return *this = bool(__x); }
-  bool operator==(const _Bit_reference& __x) const
-    { return bool(*this) == bool(__x); }
-  bool operator<(const _Bit_reference& __x) const {
-    return !bool(*this) && bool(__x);
-  }
-  void flip() { *_M_p ^= _M_mask; }
-};
-
-inline void swap(_Bit_reference __x, _Bit_reference __y)
-{
-  bool __tmp = __x;
-  __x = __y;
-  __y = __tmp;
-}
-
-struct _Bit_iterator_base : public random_access_iterator<bool, ptrdiff_t> 
-{
-  unsigned int* _M_p;
-  unsigned int _M_offset;
-
-  _Bit_iterator_base(unsigned int* __x, unsigned int __y)
-    : _M_p(__x), _M_offset(__y) {}
-
-  void _M_bump_up() {
-    if (_M_offset++ == __WORD_BIT - 1) {
-      _M_offset = 0;
-      ++_M_p;
-    }
-  }
-  void _M_bump_down() {
-    if (_M_offset-- == 0) {
-      _M_offset = __WORD_BIT - 1;
-      --_M_p;
-    }
-  }
-
-  void _M_incr(ptrdiff_t __i) {
-    difference_type __n = __i + _M_offset;
-    _M_p += __n / __WORD_BIT;
-    __n = __n % __WORD_BIT;
-    if (__n < 0) {
-      _M_offset = (unsigned int) __n + __WORD_BIT;
-      --_M_p;
-    } else
-      _M_offset = (unsigned int) __n;
-  }
-
-  bool operator==(const _Bit_iterator_base& __i) const {
-    return _M_p == __i._M_p && _M_offset == __i._M_offset;
-  }
-  bool operator<(const _Bit_iterator_base& __i) const {
-    return _M_p < __i._M_p || (_M_p == __i._M_p && _M_offset < __i._M_offset);
-  }
-  bool operator!=(const _Bit_iterator_base& __i) const {
-    return !(*this == __i);
-  }
-  bool operator>(const _Bit_iterator_base& __i) const {
-    return __i < *this;
-  }
-  bool operator<=(const _Bit_iterator_base& __i) const {
-    return !(__i < *this); 
-  }
-  bool operator>=(const _Bit_iterator_base& __i) const {
-    return !(*this < __i);
-  }
-};
-
-inline ptrdiff_t
-operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y) {
-  return __WORD_BIT * (__x._M_p - __y._M_p) + __x._M_offset - __y._M_offset;
-}
-
-
-struct _Bit_iterator : public _Bit_iterator_base
-{
-  typedef _Bit_reference  reference;
-  typedef _Bit_reference* pointer;
-  typedef _Bit_iterator   iterator;
-
-  _Bit_iterator() : _Bit_iterator_base(0, 0) {}
-  _Bit_iterator(unsigned int* __x, unsigned int __y) 
-    : _Bit_iterator_base(__x, __y) {}
-
-  reference operator*() const { return reference(_M_p, 1U << _M_offset); }
-  iterator& operator++() {
-    _M_bump_up();
-    return *this;
-  }
-  iterator operator++(int) {
-    iterator __tmp = *this;
-    _M_bump_up();
-    return __tmp;
-  }
-  iterator& operator--() {
-    _M_bump_down();
-    return *this;
-  }
-  iterator operator--(int) {
-    iterator __tmp = *this;
-    _M_bump_down();
-    return __tmp;
-  }
-  iterator& operator+=(difference_type __i) {
-    _M_incr(__i);
-    return *this;
-  }
-  iterator& operator-=(difference_type __i) {
-    *this += -__i;
-    return *this;
-  }
-  iterator operator+(difference_type __i) const {
-    iterator __tmp = *this;
-    return __tmp += __i;
-  }
-  iterator operator-(difference_type __i) const {
-    iterator __tmp = *this;
-    return __tmp -= __i;
-  }
-
-  reference operator[](difference_type __i) { return *(*this + __i); }
-};
-
-inline _Bit_iterator 
-operator+(ptrdiff_t __n, const _Bit_iterator& __x) { return __x + __n; }
-
-
-struct _Bit_const_iterator : public _Bit_iterator_base
-{
-  typedef bool                 reference;
-  typedef bool                 const_reference;
-  typedef const bool*          pointer;
-  typedef _Bit_const_iterator  const_iterator;
-
-  _Bit_const_iterator() : _Bit_iterator_base(0, 0) {}
-  _Bit_const_iterator(unsigned int* __x, unsigned int __y) 
-    : _Bit_iterator_base(__x, __y) {}
-  _Bit_const_iterator(const _Bit_iterator& __x) 
-    : _Bit_iterator_base(__x._M_p, __x._M_offset) {}
-
-  const_reference operator*() const {
-    return _Bit_reference(_M_p, 1U << _M_offset);
-  }
-  const_iterator& operator++() {
-    _M_bump_up();
-    return *this;
-  }
-  const_iterator operator++(int) {
-    const_iterator __tmp = *this;
-    _M_bump_up();
-    return __tmp;
-  }
-  const_iterator& operator--() {
-    _M_bump_down();
-    return *this;
-  }
-  const_iterator operator--(int) {
-    const_iterator __tmp = *this;
-    _M_bump_down();
-    return __tmp;
-  }
-  const_iterator& operator+=(difference_type __i) {
-    _M_incr(__i);
-    return *this;
-  }
-  const_iterator& operator-=(difference_type __i) {
-    *this += -__i;
-    return *this;
-  }
-  const_iterator operator+(difference_type __i) const {
-    const_iterator __tmp = *this;
-    return __tmp += __i;
-  }
-  const_iterator operator-(difference_type __i) const {
-    const_iterator __tmp = *this;
-    return __tmp -= __i;
-  }
-  const_reference operator[](difference_type __i) { 
-    return *(*this + __i); 
-  }
-};
-
-inline _Bit_const_iterator 
-operator+(ptrdiff_t __n, const _Bit_const_iterator& __x) { return __x + __n; }
-
-
-// Bit-vector base class, which encapsulates the difference between
-// old SGI-style allocators and standard-conforming allocators.
-
-#ifdef __STL_USE_STD_ALLOCATORS
-
-// Base class for ordinary allocators.
-template <class _Allocator, bool __is_static>
-class _Bvector_alloc_base {
-public:
-  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type
-          allocator_type;
-  allocator_type get_allocator() const { return _M_data_allocator; }
-
-  _Bvector_alloc_base(const allocator_type& __a)
-    : _M_data_allocator(__a), _M_start(), _M_finish(), _M_end_of_storage(0) {}
-
-protected:
-  unsigned int* _M_bit_alloc(size_t __n) 
-    { return _M_data_allocator.allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }
-  void _M_deallocate() {
-    if (_M_start._M_p)
-      _M_data_allocator.deallocate(_M_start._M_p, 
-                                   _M_end_of_storage - _M_start._M_p);
-  }  
-
-  typename _Alloc_traits<unsigned int, _Allocator>::allocator_type 
-          _M_data_allocator;
-  _Bit_iterator _M_start;
-  _Bit_iterator _M_finish;
-  unsigned int* _M_end_of_storage;
-};
-
-// Specialization for instanceless allocators.
-template <class _Allocator>
-class _Bvector_alloc_base<_Allocator, true> {
-public:
-  typedef typename _Alloc_traits<bool, _Allocator>::allocator_type
-          allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Bvector_alloc_base(const allocator_type&)
-    : _M_start(), _M_finish(), _M_end_of_storage(0) {}
-
-protected:
-  typedef typename _Alloc_traits<unsigned int, _Allocator>::_Alloc_type
-          _Alloc_type;
-          
-  unsigned int* _M_bit_alloc(size_t __n) 
-    { return _Alloc_type::allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }
-  void _M_deallocate() {
-    if (_M_start._M_p)
-      _Alloc_type::deallocate(_M_start._M_p,
-                              _M_end_of_storage - _M_start._M_p);
-  }  
-
-  _Bit_iterator _M_start;
-  _Bit_iterator _M_finish;
-  unsigned int* _M_end_of_storage;
-};  
-
-template <class _Alloc>
-class _Bvector_base
-  : public _Bvector_alloc_base<_Alloc,
-                               _Alloc_traits<bool, _Alloc>::_S_instanceless>
-{
-  typedef _Bvector_alloc_base<_Alloc,
-                              _Alloc_traits<bool, _Alloc>::_S_instanceless>
-          _Base;
-public:
-  typedef typename _Base::allocator_type allocator_type;
-
-  _Bvector_base(const allocator_type& __a) : _Base(__a) {}
-  ~_Bvector_base() { _Base::_M_deallocate(); }
-};
-
-#else /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Alloc>
-class _Bvector_base
-{
-public:
-  typedef _Alloc allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Bvector_base(const allocator_type&)
-    : _M_start(), _M_finish(), _M_end_of_storage(0) {}
-  ~_Bvector_base() { _M_deallocate(); }
-
-protected:
-  typedef simple_alloc<unsigned int, _Alloc> _Alloc_type;
-  
-  unsigned int* _M_bit_alloc(size_t __n) 
-    { return _Alloc_type::allocate((__n + __WORD_BIT - 1)/__WORD_BIT); }
-  void _M_deallocate() {
-    if (_M_start._M_p)
-      _Alloc_type::deallocate(_M_start._M_p,
-                              _M_end_of_storage - _M_start._M_p);
-  }
-
-  _Bit_iterator _M_start;
-  _Bit_iterator _M_finish;
-  unsigned int* _M_end_of_storage;  
-};
-
-#endif /* __STL_USE_STD_ALLOCATORS */
-
-// The next few lines are confusing.  What we're doing is declaring a
-//  partial specialization of vector<T, Alloc> if we have the necessary
-//  compiler support.  Otherwise, we define a class bit_vector which uses
-//  the default allocator. 
-
-#if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) && !defined(__STL_NO_BOOL)
-#  define __SGI_STL_VECBOOL_TEMPLATE
-#  define __BVECTOR           vector<bool, _Alloc>
-#  define __VECTOR            vector
-#  define __BVECTOR_BASE      _Bvector_base<_Alloc>
-#  define __BVECTOR_TMPL_LIST template <class _Alloc>
-   __STL_END_NAMESPACE
-#  include <stl_vector.h>
-   __STL_BEGIN_NAMESPACE
-#else  /* __STL_CLASS_PARTIAL_SPECIALIZATION && !__STL_NO_BOOL */
-#  undef  __SGI_STL_VECBOOL_TEMPLATE
-#  define __BVECTOR           bit_vector
-#  define __VECTOR            bit_vector
-#  define __BVECTOR_BASE      _Bvector_base<__STL_DEFAULT_ALLOCATOR(bool) >
-#  define __BVECTOR_TMPL_LIST
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION && !__STL_NO_BOOL */
-
-
-__BVECTOR_TMPL_LIST 
-class __BVECTOR : public __BVECTOR_BASE 
-{
-public:
-  typedef bool value_type;
-  typedef size_t size_type;
-  typedef ptrdiff_t difference_type; 
-  typedef _Bit_reference reference;
-  typedef bool const_reference;
-  typedef _Bit_reference* pointer;
-  typedef const bool* const_pointer;
-
-  typedef _Bit_iterator                iterator;
-  typedef _Bit_const_iterator          const_iterator;
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
-  typedef std::reverse_iterator<iterator> reverse_iterator;
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-  typedef std::reverse_iterator<const_iterator, value_type, const_reference,
-                           difference_type> const_reverse_iterator;
-  typedef std::reverse_iterator<iterator, value_type, reference, difference_type>
-          reverse_iterator;
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-  typedef typename __BVECTOR_BASE::allocator_type allocator_type;
-  allocator_type get_allocator() const {
-    return __BVECTOR_BASE::get_allocator();
-  }
-
-protected:
-#ifdef __STL_USE_NAMESPACES  
-  using __BVECTOR_BASE::_M_bit_alloc;
-  using __BVECTOR_BASE::_M_deallocate;
-  using __BVECTOR_BASE::_M_start;
-  using __BVECTOR_BASE::_M_finish;
-  using __BVECTOR_BASE::_M_end_of_storage;
-#endif /* __STL_USE_NAMESPACES */
-
-protected:
-  void _M_initialize(size_type __n) {
-    unsigned int* __q = _M_bit_alloc(__n);
-    _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;
-    _M_start = iterator(__q, 0);
-    _M_finish = _M_start + difference_type(__n);
-  }
-  void _M_insert_aux(iterator __position, bool __x) {
-    if (_M_finish._M_p != _M_end_of_storage) {
-      copy_backward(__position, _M_finish, _M_finish + 1);
-      *__position = __x;
-      ++_M_finish;
-    }
-    else {
-      size_type __len = size() ? 2 * size() : __WORD_BIT;
-
-      unsigned int* __q = _M_bit_alloc(__len);
-      iterator __i = copy(begin(), __position, iterator(__q, 0));
-      *__i++ = __x;
-      _M_finish = copy(__position, end(), __i);
-      _M_deallocate();
-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;
-      _M_start = iterator(__q, 0);
-    }
-  }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  void _M_initialize_range(_InputIterator __first, _InputIterator __last,
-                           input_iterator_tag) {
-    _M_start = iterator();
-    _M_finish = iterator();
-    _M_end_of_storage = 0;
-    for ( ; __first != __last; ++__first) 
-      push_back(*__first);
-  }
-
-  template <class _ForwardIterator>
-  void _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
-                           forward_iterator_tag) {
-    size_type __n = 0;
-    distance(__first, __last, __n);
-    _M_initialize(__n);
-    copy(__first, __last, _M_start);
-  }
-
-  template <class _InputIterator>
-  void _M_insert_range(iterator __pos,
-                       _InputIterator __first, _InputIterator __last,
-                       input_iterator_tag) {
-    for ( ; __first != __last; ++__first) {
-      __pos = insert(__pos, *__first);
-      ++__pos;
-    }
-  }
-
-  template <class _ForwardIterator>
-  void _M_insert_range(iterator __position,
-                       _ForwardIterator __first, _ForwardIterator __last,
-                       forward_iterator_tag) {
-    if (__first != __last) {
-      size_type __n = 0;
-      distance(__first, __last, __n);
-      if (capacity() - size() >= __n) {
-        copy_backward(__position, end(), _M_finish + difference_type(__n));
-        copy(__first, __last, __position);
-        _M_finish += difference_type(__n);
-      }
-      else {
-        size_type __len = size() + max(size(), __n);
-        unsigned int* __q = _M_bit_alloc(__len);
-        iterator __i = copy(begin(), __position, iterator(__q, 0));
-        __i = copy(__first, __last, __i);
-        _M_finish = copy(__position, end(), __i);
-        _M_deallocate();
-        _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;
-        _M_start = iterator(__q, 0);
-      }
-    }
-  }      
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:
-  iterator begin() { return _M_start; }
-  const_iterator begin() const { return _M_start; }
-  iterator end() { return _M_finish; }
-  const_iterator end() const { return _M_finish; }
-
-  reverse_iterator rbegin() { return reverse_iterator(end()); }
-  const_reverse_iterator rbegin() const { 
-    return const_reverse_iterator(end()); 
-  }
-  reverse_iterator rend() { return reverse_iterator(begin()); }
-  const_reverse_iterator rend() const { 
-    return const_reverse_iterator(begin()); 
-  }
-
-  size_type size() const { return size_type(end() - begin()); }
-  size_type max_size() const { return size_type(-1); }
-  size_type capacity() const {
-    return size_type(const_iterator(_M_end_of_storage, 0) - begin());
-  }
-  bool empty() const { return begin() == end(); }
-
-  reference operator[](size_type __n)
-    { return *(begin() + difference_type(__n)); }
-  const_reference operator[](size_type __n) const
-    { return *(begin() + difference_type(__n)); }
-
-#ifdef __STL_THROW_RANGE_ERRORS
-  void _M_range_check(size_type __n) const {
-    if (__n >= this->size())
-      __stl_throw_range_error("vector<bool>");
-  }
-
-  reference at(size_type __n)
-    { _M_range_check(__n); return (*this)[__n]; }
-  const_reference at(size_type __n) const
-    { _M_range_check(__n); return (*this)[__n]; }
-#endif /* __STL_THROW_RANGE_ERRORS */
-
-  explicit __VECTOR(const allocator_type& __a = allocator_type())
-    : __BVECTOR_BASE(__a) {}
-
-  __VECTOR(size_type __n, bool __value,
-            const allocator_type& __a = allocator_type())
-    : __BVECTOR_BASE(__a)
-  {
-    _M_initialize(__n);
-    fill(_M_start._M_p, _M_end_of_storage, __value ? ~0 : 0);
-  }
-
-  explicit __VECTOR(size_type __n)
-    : __BVECTOR_BASE(allocator_type())
-  {
-    _M_initialize(__n);
-    fill(_M_start._M_p, _M_end_of_storage, 0);
-  }
-
-  __VECTOR(const __VECTOR& __x) : __BVECTOR_BASE(__x.get_allocator()) {
-    _M_initialize(__x.size());
-    copy(__x.begin(), __x.end(), _M_start);
-  }
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  // Check whether it's an integral type.  If so, it's not an iterator.
-
-  template <class _Integer>
-  void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {
-    _M_initialize(__n);
-    fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);
-  }
-
-  template <class _InputIterator>
-  void _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
-                              __false_type) {
-    _M_initialize_range(__first, __last, __ITERATOR_CATEGORY(__first));
-  }
-
-  template <class _InputIterator>
-  __VECTOR(_InputIterator __first, _InputIterator __last,
-           const allocator_type& __a = allocator_type())
-    : __BVECTOR_BASE(__a)
-  {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_initialize_dispatch(__first, __last, _Integral());
-  }
-    
-#else /* __STL_MEMBER_TEMPLATES */
-
-  __VECTOR(const_iterator __first, const_iterator __last,
-           const allocator_type& __a = allocator_type())
-    : __BVECTOR_BASE(__a)
-  {
-    size_type __n = 0;
-    distance(__first, __last, __n);
-    _M_initialize(__n);
-    copy(__first, __last, _M_start);
-  }
-  __VECTOR(const bool* __first, const bool* __last,
-           const allocator_type& __a = allocator_type())
-    : __BVECTOR_BASE(__a)
-  {
-    size_type __n = 0;
-    distance(__first, __last, __n);
-    _M_initialize(__n);
-    copy(__first, __last, _M_start);
-  }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  ~__VECTOR() { }
-
-  __VECTOR& operator=(const __VECTOR& __x) {
-    if (&__x == this) return *this;
-    if (__x.size() > capacity()) {
-      _M_deallocate();
-      _M_initialize(__x.size());
-    }
-    copy(__x.begin(), __x.end(), begin());
-    _M_finish = begin() + difference_type(__x.size());
-    return *this;
-  }
-
-  // assign(), a generalized assignment member function.  Two
-  // versions: one that takes a count, and one that takes a range.
-  // The range version is a member template, so we dispatch on whether
-  // or not the type is an integer.
-
-  void _M_fill_assign(size_t __n, bool __x) {
-    if (__n > size()) {
-      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);
-      insert(end(), __n - size(), __x);
-    }
-    else {
-      erase(begin() + __n, end());
-      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);
-    }
-  }
-
-  void assign(size_t __n, bool __x) { _M_fill_assign(__n, __x); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  template <class _InputIterator>
-  void assign(_InputIterator __first, _InputIterator __last) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_assign_dispatch(__first, __last, _Integral());
-  }
-
-  template <class _Integer>
-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
-    { _M_fill_assign((size_t) __n, (bool) __val); }
-
-  template <class _InputIter>
-  void _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)
-    { _M_assign_aux(__first, __last, __ITERATOR_CATEGORY(__first)); }
-
-  template <class _InputIterator>
-  void _M_assign_aux(_InputIterator __first, _InputIterator __last,
-                     input_iterator_tag) {
-    iterator __cur = begin();
-    for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
-      *__cur = *__first;
-    if (__first == __last)
-      erase(__cur, end());
-    else
-      insert(end(), __first, __last);
-  }
-
-  template <class _ForwardIterator>
-  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
-                     forward_iterator_tag) {
-    size_type __len = 0;
-    distance(__first, __last, __len);
-    if (__len < size())
-      erase(copy(__first, __last, begin()), end());
-    else {
-      _ForwardIterator __mid = __first;
-      advance(__mid, size());
-      copy(__first, __mid, begin());
-      insert(end(), __mid, __last);
-    }
-  }    
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  void reserve(size_type __n) {
-    if (capacity() < __n) {
-      unsigned int* __q = _M_bit_alloc(__n);
-      _M_finish = copy(begin(), end(), iterator(__q, 0));
-      _M_deallocate();
-      _M_start = iterator(__q, 0);
-      _M_end_of_storage = __q + (__n + __WORD_BIT - 1)/__WORD_BIT;
-    }
-  }
-
-  reference front() { return *begin(); }
-  const_reference front() const { return *begin(); }
-  reference back() { return *(end() - 1); }
-  const_reference back() const { return *(end() - 1); }
-  void push_back(bool __x) {
-    if (_M_finish._M_p != _M_end_of_storage)
-      *_M_finish++ = __x;
-    else
-      _M_insert_aux(end(), __x);
-  }
-  void swap(__BVECTOR& __x) {
-    __STD::swap(_M_start, __x._M_start);
-    __STD::swap(_M_finish, __x._M_finish);
-    __STD::swap(_M_end_of_storage, __x._M_end_of_storage);
-  }
-  iterator insert(iterator __position, bool __x = bool()) {
-    difference_type __n = __position - begin();
-    if (_M_finish._M_p != _M_end_of_storage && __position == end())
-      *_M_finish++ = __x;
-    else
-      _M_insert_aux(__position, __x);
-    return begin() + __n;
-  }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  // Check whether it's an integral type.  If so, it's not an iterator.
-
-  template <class _Integer>
-  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
-                          __true_type) {
-    _M_fill_insert(__pos, __n, __x);
-  }
-
-  template <class _InputIterator>
-  void _M_insert_dispatch(iterator __pos,
-                          _InputIterator __first, _InputIterator __last,
-                          __false_type) {
-    _M_insert_range(__pos, __first, __last, __ITERATOR_CATEGORY(__first));
-  }
-
-  template <class _InputIterator>
-  void insert(iterator __position,
-              _InputIterator __first, _InputIterator __last) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_insert_dispatch(__position, __first, __last, _Integral());
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-  void insert(iterator __position,
-              const_iterator __first, const_iterator __last) {
-    if (__first == __last) return;
-    size_type __n = 0;
-    distance(__first, __last, __n);
-    if (capacity() - size() >= __n) {
-      copy_backward(__position, end(), _M_finish + __n);
-      copy(__first, __last, __position);
-      _M_finish += __n;
-    }
-    else {
-      size_type __len = size() + max(size(), __n);
-      unsigned int* __q = _M_bit_alloc(__len);
-      iterator __i = copy(begin(), __position, iterator(__q, 0));
-      __i = copy(__first, __last, __i);
-      _M_finish = copy(__position, end(), __i);
-      _M_deallocate();
-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;
-      _M_start = iterator(__q, 0);
-    }
-  }
-
-  void insert(iterator __position, const bool* __first, const bool* __last) {
-    if (__first == __last) return;
-    size_type __n = 0;
-    distance(__first, __last, __n);
-    if (capacity() - size() >= __n) {
-      copy_backward(__position, end(), _M_finish + __n);
-      copy(__first, __last, __position);
-      _M_finish += __n;
-    }
-    else {
-      size_type __len = size() + max(size(), __n);
-      unsigned int* __q = _M_bit_alloc(__len);
-      iterator __i = copy(begin(), __position, iterator(__q, 0));
-      __i = copy(__first, __last, __i);
-      _M_finish = copy(__position, end(), __i);
-      _M_deallocate();
-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;
-      _M_start = iterator(__q, 0);
-    }
-  }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  void _M_fill_insert(iterator __position, size_type __n, bool __x) {
-    if (__n == 0) return;
-    if (capacity() - size() >= __n) {
-      copy_backward(__position, end(), _M_finish + difference_type(__n));
-      fill(__position, __position + difference_type(__n), __x);
-      _M_finish += difference_type(__n);
-    }
-    else {
-      size_type __len = size() + max(size(), __n);
-      unsigned int* __q = _M_bit_alloc(__len);
-      iterator __i = copy(begin(), __position, iterator(__q, 0));
-      fill_n(__i, __n, __x);
-      _M_finish = copy(__position, end(), __i + difference_type(__n));
-      _M_deallocate();
-      _M_end_of_storage = __q + (__len + __WORD_BIT - 1)/__WORD_BIT;
-      _M_start = iterator(__q, 0);
-    }
-  }
-
-  void insert(iterator __position, size_type __n, bool __x) {
-    _M_fill_insert(__position, __n, __x);
-  }
-
-  void pop_back() { --_M_finish; }
-  iterator erase(iterator __position) {
-    if (__position + 1 != end())
-      copy(__position + 1, end(), __position);
-    --_M_finish;
-    return __position;
-  }
-  iterator erase(iterator __first, iterator __last) {
-    _M_finish = copy(__last, end(), __first);
-    return __first;
-  }
-  void resize(size_type __new_size, bool __x = bool()) {
-    if (__new_size < size()) 
-      erase(begin() + difference_type(__new_size), end());
-    else
-      insert(end(), __new_size - size(), __x);
-  }
-  void flip() {
-    for (unsigned int* __p = _M_start._M_p; __p != _M_end_of_storage; ++__p)
-      *__p = ~*__p;
-  }
-
-  void clear() { erase(begin(), end()); }
-};
-
-#ifdef __SGI_STL_VECBOOL_TEMPLATE
-
-// This typedef is non-standard.  It is provided for backward compatibility.
-typedef vector<bool, alloc> bit_vector;
-
-#else /* __SGI_STL_VECBOOL_TEMPLATE */
-
-inline void swap(bit_vector& __x, bit_vector& __y) {
-  __x.swap(__y);
-}
-
-inline bool 
-operator==(const bit_vector& __x, const bit_vector& __y)
-{
-  return (__x.size() == __y.size() && 
-          equal(__x.begin(), __x.end(), __y.begin()));
-}
-
-inline bool 
-operator!=(const bit_vector& __x, const bit_vector& __y)
-{
-  return !(__x == __y);
-}
-
-inline bool 
-operator<(const bit_vector& __x, const bit_vector& __y)
-{
-  return lexicographical_compare(__x.begin(), __x.end(), 
-                                 __y.begin(), __y.end());
-}
-
-inline bool operator>(const bit_vector& __x, const bit_vector& __y)
-{
-  return __y < __x;
-}
-
-inline bool operator<=(const bit_vector& __x, const bit_vector& __y)
-{
-  return !(__y < __x);
-}
-
-inline bool operator>=(const bit_vector& __x, const bit_vector& __y)
-{
-  return !(__x < __y);
-}
-
-#endif /* __SGI_STL_VECBOOL_TEMPLATE */
-
-#undef __SGI_STL_VECBOOL_TEMPLATE
-#undef __BVECTOR
-#undef __VECTOR
-#undef __BVECTOR_BASE
-#undef __BVECTOR_TMPL_LIST 
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE 
-
-#endif /* __SGI_STL_INTERNAL_BVECTOR_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_config.h b/lib/include/stl/stl_config.h
deleted file mode 100644
index 3bc3654..0000000
--- a/lib/include/stl/stl_config.h
+++ /dev/null
@@ -1,607 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- * Copyright (c) 1997
- * Silicon Graphics
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef __STL_CONFIG_H
-# define __STL_CONFIG_H
-
-// Flags:
-// * __STL_NO_BOOL: defined if the compiler doesn't have bool as a builtin
-//   type.
-// * __STL_HAS_WCHAR_T: defined if the compier has wchar_t as a builtin type.
-// * __STL_NO_DRAND48: defined if the compiler doesn't have the drand48 
-//   function.
-// * __STL_STATIC_TEMPLATE_MEMBER_BUG: defined if the compiler can't handle
-//   static members of template classes.
-// * __STL_STATIC_CONST_INIT_BUG: defined if the compiler can't handle a
-//   constant-initializer in the declaration of a static const data member
-//   of integer type.  (See section 9.4.2, paragraph 4, of the C++ standard.)
-// * __STL_CLASS_PARTIAL_SPECIALIZATION: defined if the compiler supports
-//   partial specialization of template classes.
-// * __STL_PARTIAL_SPECIALIZATION_SYNTAX: defined if the compiler 
-//   supports partial specialization syntax for full specialization of
-//   class templates.  (Even if it doesn't actually support partial 
-//   specialization itself.)
-// * __STL_FUNCTION_TMPL_PARTIAL_ORDER: defined if the compiler supports
-//   partial ordering of function templates.  (a.k.a partial specialization
-//   of function templates.)
-// * __STL_MEMBER_TEMPLATES: defined if the compiler supports template
-//   member functions of classes.
-// * __STL_MEMBER_TEMPLATE_CLASSES: defined if the compiler supports 
-//   nested classes that are member templates of other classes.
-// * __STL_TEMPLATE_FRIENDS: defined if the compiler supports templatized
-//   friend declarations.
-// * __STL_EXPLICIT_FUNCTION_TMPL_ARGS: defined if the compiler 
-//   supports calling a function template by providing its template
-//   arguments explicitly.
-// * __STL_LIMITED_DEFAULT_TEMPLATES: defined if the compiler is unable
-//   to handle default template parameters that depend on previous template
-//   parameters.
-// * __STL_NON_TYPE_TMPL_PARAM_BUG: defined if the compiler has trouble with
-//   function template argument deduction for non-type template parameters.
-// * __SGI_STL_NO_ARROW_OPERATOR: defined if the compiler is unable
-//   to support the -> operator for iterators.
-// * __STL_DEFAULT_CONSTRUCTOR_BUG: defined if T() does not work properly
-//   when T is a builtin type.
-// * __STL_USE_EXCEPTIONS: defined if the compiler (in the current compilation
-//   mode) supports exceptions.
-// * __STL_USE_NAMESPACES: defined if the compiler has the necessary
-//   support for namespaces.
-// * __STL_NO_EXCEPTION_HEADER: defined if the compiler does not have a
-//   standard-conforming header <exception>.
-// * __STL_NO_BAD_ALLOC: defined if the compiler does not have a <new>
-//   header, or if <new> does not contain a bad_alloc class.  If a bad_alloc
-//   class exists, it is assumed to be in namespace std.
-// * __STL_SGI_THREADS: defined if this is being compiled for an SGI IRIX
-//   system in multithreaded mode, using native SGI threads instead of 
-//   pthreads.
-// * __STL_WIN32THREADS: defined if this is being compiled on a WIN32
-//   compiler in multithreaded mode.
-// * __STL_PTHREADS: defined if we should use portable pthreads
-//   synchronization.
-// * __STL_UITHREADS: defined if we should use UI / solaris / UnixWare threads
-//   synchronization.  UIthreads are similar to pthreads, but are based 
-//   on an earlier version of the Posix threads standard.
-// * __STL_LONG_LONG if the compiler has long long and unsigned long long
-//   types.  (They're not in the C++ standard, but they are expected to be 
-//   included in the forthcoming C9X standard.)
-// * __STL_THREADS is defined if thread safety is needed.
-// * __STL_VOLATILE is defined to be "volatile" if threads are being
-//   used, and the empty string otherwise.
-// * __STL_USE_CONCEPT_CHECKS enables some extra compile-time error
-//   checking to make sure that user-defined template arguments satisfy
-//   all of the appropriate requirements.  This may result in more
-//   comprehensible error messages.  It incurs no runtime overhead.  This 
-//   feature requires member templates and partial specialization.
-// * __STL_NO_USING_CLAUSE_IN_CLASS: The compiler does not handle "using"
-//   clauses inside of class definitions.
-// * __STL_NO_FRIEND_TEMPLATE_CLASS: The compiler does not handle friend
-//   declaractions where the friend is a template class.
-// * __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE: The compiler does not
-//   support the use of a function pointer type as the argument
-//   for a template.
-// * __STL_MEMBER_TEMPLATE_KEYWORD: standard C++ requires the template
-//   keyword in a few new places (14.2.4).  This flag is set for
-//   compilers that support (and require) this usage.
-
-
-// User-settable macros that control compilation:
-// * __STL_USE_SGI_ALLOCATORS: if defined, then the STL will use older
-//   SGI-style allocators, instead of standard-conforming allocators,
-//   even if the compiler supports all of the language features needed
-//   for standard-conforming allocators.
-// * __STL_NO_NAMESPACES: if defined, don't put the library in namespace
-//   std, even if the compiler supports namespaces.
-// * __STL_NO_RELOPS_NAMESPACE: if defined, don't put the relational
-//   operator templates (>, <=. >=, !=) in namespace std::rel_ops, even
-//   if the compiler supports namespaces and partial ordering of
-//   function templates.
-// * __STL_ASSERTIONS: if defined, then enable runtime checking through the
-//   __stl_assert macro.
-// * _PTHREADS: if defined, use Posix threads for multithreading support.
-// * _UITHREADS:if defined, use SCO/Solaris/UI threads for multithreading 
-//   support
-// * _NOTHREADS: if defined, don't use any multithreading support.  
-// * _STL_NO_CONCEPT_CHECKS: if defined, disables the error checking that
-//   we get from __STL_USE_CONCEPT_CHECKS.
-// * __STL_USE_NEW_IOSTREAMS: if defined, then the STL will use new,
-//   standard-conforming iostreams (e.g. the <iosfwd> header).  If not
-//   defined, the STL will use old cfront-style iostreams (e.g. the
-//   <iostream.h> header).
-
-// Other macros defined by this file:
-
-// * bool, true, and false, if __STL_NO_BOOL is defined.
-// * typename, as a null macro if it's not already a keyword.
-// * explicit, as a null macro if it's not already a keyword.
-// * namespace-related macros (__STD, __STL_BEGIN_NAMESPACE, etc.)
-// * exception-related macros (__STL_TRY, __STL_UNWIND, etc.)
-// * __stl_assert, either as a test or as a null macro, depending on
-//   whether or not __STL_ASSERTIONS is defined.
-
-#if defined(STM32PLUS_BUILD)
-
-#include <stm32_config.h>
-
-// don't change these
-
-#define __STL_NO_DRAND48
-#define __STL_NO_BAD_ALLOC
-#define __STL_PARTIAL_SPECIALIZATION_SYNTAX
-#define __STL_CLASS_PARTIAL_SPECIALIZATION
-#define __STL_USE_NEW_IOSTREAMS       // not really :-/
-#define __STL_FUNCTION_TMPL_PARTIAL_ORDER
-#define __STL_EXPLICIT_FUNCTION_TMPL_ARGS
-#define __STL_MEMBER_TEMPLATES
-#define __STL_MEMBER_TEMPLATE_CLASSES
-#define __STL_TEMPLATE_FRIENDS
-#define __SGI_STL_USE_AUTO_PTR_CONVERSIONS
-#define __STL_HAS_NAMESPACES
-#define __STL_USE_NAMESPACES
-#define __STL_MEMBER_TEMPLATE_KEYWORD
-#define _NOTHREADS
-
-#if !defined(__STRICT_ANSI__)
-#define __STRICT_ANSI__
-#endif
-
-#undef __STL_USE_CONCEPT_CHECKS
-
-#endif
-
-
-# if defined(_PTHREADS) && !defined(_NOTHREADS)
-#     define __STL_PTHREADS
-# endif
-
-# if defined(_UITHREADS) && !defined(_PTHREADS) && !defined(_NOTHREADS)
-#     define __STL_UITHREADS
-# endif
-
-# if defined(__sgi) && !defined(__GNUC__)
-#   include <standards.h>
-#   if !defined(_BOOL)
-#     define __STL_NO_BOOL
-#   endif
-#   if defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32
-#     define __STL_STATIC_CONST_INIT_BUG
-#   endif
-#   if defined(_WCHAR_T_IS_KEYWORD)
-#     define __STL_HAS_WCHAR_T 
-#   endif
-#   if !defined(_TYPENAME_IS_KEYWORD)
-#     define __STL_NEED_TYPENAME
-#   endif
-#   ifdef _PARTIAL_SPECIALIZATION_OF_CLASS_TEMPLATES
-#     define __STL_CLASS_PARTIAL_SPECIALIZATION
-#   endif
-#   if (_COMPILER_VERSION >= 730) && defined(_MIPS_SIM) && _MIPS_SIM != _ABIO32
-#     define __STL_FUNCTION_TMPL_PARTIAL_ORDER
-#   endif
-#   ifdef _MEMBER_TEMPLATES
-#     define __STL_MEMBER_TEMPLATES
-#     define __STL_TEMPLATE_FRIENDS
-#     define __STL_MEMBER_TEMPLATE_CLASSES
-#   endif
-#   if defined(_MEMBER_TEMPLATE_KEYWORD)
-#     define __STL_MEMBER_TEMPLATE_KEYWORD
-#   endif
-#   if defined(_STANDARD_C_PLUS_PLUS)
-#     define __STL_EXPLICIT_FUNCTION_TMPL_ARGS
-#   endif
-#   if (_COMPILER_VERSION >= 730) && defined(_MIPS_SIM) && _MIPS_SIM != _ABIO32
-#     define __STL_MEMBER_TEMPLATE_KEYWORD
-#   endif
-#   if COMPILER_VERSION < 720 || (defined(_MIPS_SIM) && _MIPS_SIM == _ABIO32)
-#     define __STL_DEFAULT_CONSTRUCTOR_BUG
-#   endif
-#   if !defined(_EXPLICIT_IS_KEYWORD)
-#     define __STL_NEED_EXPLICIT
-#   endif
-#   ifdef __EXCEPTIONS
-#     define __STL_USE_EXCEPTIONS
-#   endif
-#   if (_COMPILER_VERSION >= 721) && defined(_NAMESPACES)
-#     define __STL_HAS_NAMESPACES
-#   endif 
-#   if (_COMPILER_VERSION < 721) || \
-    !defined(__STL_HAS_NAMESPACES) || defined(__STL_NO_NAMESPACES)
-#     define __STL_NO_EXCEPTION_HEADER
-#   endif
-#   if _COMPILER_VERSION < 730 || !defined(_STANDARD_C_PLUS_PLUS) || \
-      !defined(_NAMESPACES)
-#     define __STL_NO_BAD_ALLOC
-#   endif
-#   if !defined(_NOTHREADS) && !defined(__STL_PTHREADS)
-#     define __STL_SGI_THREADS
-#   endif
-#   if defined(_LONGLONG) && defined(_SGIAPI) && _SGIAPI
-#     define __STL_LONG_LONG
-#   endif
-#   if _COMPILER_VERSION >= 730 && defined(_STANDARD_C_PLUS_PLUS)
-#     define __STL_USE_NEW_IOSTREAMS
-#   endif
-#   if _COMPILER_VERSION >= 730 && defined(_STANDARD_C_PLUS_PLUS)
-#     define __STL_CAN_THROW_RANGE_ERRORS
-#   endif
-#   if _COMPILER_VERSION >= 730 && defined(_STANDARD_C_PLUS_PLUS)
-#     define __SGI_STL_USE_AUTO_PTR_CONVERSIONS
-#   endif
-# endif
-
-
-/*
- * Jochen Schlick '1999  - added new #defines (__STL)_UITHREADS (for 
- *                         providing SCO / Solaris / UI thread support)
- *                       - added the necessary defines for the SCO UDK 7 
- *                         compiler (and its template friend behavior)
- *                       - all UDK7 specific STL changes are based on the 
- *                         macro __USLC__ being defined
- */
-// SCO UDK 7 compiler (UnixWare 7x, OSR 5, UnixWare 2x)
-# if defined(__USLC__)
-#     define __STL_HAS_WCHAR_T 
-#     define __STL_CLASS_PARTIAL_SPECIALIZATION
-#     define __STL_PARTIAL_SPECIALIZATION_SYNTAX
-#     define __STL_FUNCTION_TMPL_PARTIAL_ORDER
-#     define __STL_MEMBER_TEMPLATES
-#     define __STL_MEMBER_TEMPLATE_CLASSES
-#     define __STL_USE_EXCEPTIONS
-#     define __STL_HAS_NAMESPACES
-#     define __STL_USE_NAMESPACES
-#     define __STL_LONG_LONG
-#     if defined(_REENTRANT)
-#           define _UITHREADS     /* if      UnixWare < 7.0.1 */
-#           define __STL_UITHREADS
-//   use the following defines instead of the UI threads defines when
-//   you want to use POSIX threads
-//#         define _PTHREADS      /* only if UnixWare >=7.0.1 */
-//#         define __STL_PTHREADS
-#     endif
-# endif
-
-
-
-# ifdef __GNUC__
-#   if __GNUC__ == 2 && __GNUC_MINOR__ <= 7
-#     define __STL_STATIC_TEMPLATE_MEMBER_BUG
-#   endif
-#   if __GNUC__ < 2 
-#     define __STL_NEED_TYPENAME
-#     define __STL_NEED_EXPLICIT
-#   endif
-#   if __GNUC__ == 2 && __GNUC_MINOR__ <= 8
-#     define __STL_NO_EXCEPTION_HEADER
-#     define __STL_NO_BAD_ALLOC
-#   endif
-#   if __GNUC__ == 2 && __GNUC_MINOR__ >= 8
-#     define __STL_CLASS_PARTIAL_SPECIALIZATION
-#     define __STL_FUNCTION_TMPL_PARTIAL_ORDER
-#     define __STL_EXPLICIT_FUNCTION_TMPL_ARGS
-#     define __STL_MEMBER_TEMPLATES
-#     define __STL_CAN_THROW_RANGE_ERRORS
-      //    g++ 2.8.1 supports member template functions, but not member
-      //    template nested classes.
-#     if __GNUC_MINOR__ >= 9
-#       define __STL_MEMBER_TEMPLATE_CLASSES
-#       define __STL_TEMPLATE_FRIENDS
-#       define __SGI_STL_USE_AUTO_PTR_CONVERSIONS
-#       define __STL_HAS_NAMESPACES
-//#       define __STL_USE_NEW_IOSTREAMS
-#     endif
-#   endif
-#   define __STL_DEFAULT_CONSTRUCTOR_BUG
-#   ifdef __EXCEPTIONS
-#     define __STL_USE_EXCEPTIONS
-#   endif
-#   ifdef _REENTRANT
-#     define __STL_PTHREADS
-#   endif
-#   if (__GNUC__ < 2) || (__GNUC__ == 2 && __GNUC_MINOR__ < 95)
-#     define __STL_NO_FUNCTION_PTR_IN_CLASS_TEMPLATE
-#   endif
-# endif
-
-# if defined(__SUNPRO_CC) 
-#   define __STL_NO_BOOL
-#   define __STL_NEED_TYPENAME
-#   define __STL_NEED_EXPLICIT
-#   define __STL_USE_EXCEPTIONS
-#   ifdef _REENTRANT
-#     define __STL_PTHREADS
-#   endif
-#   define __SGI_STL_NO_ARROW_OPERATOR
-#   define __STL_PARTIAL_SPECIALIZATION_SYNTAX
-#   define __STL_NO_EXCEPTION_HEADER
-#   define __STL_NO_BAD_ALLOC
-# endif
-
-# if defined(__COMO__)
-#   define __STL_MEMBER_TEMPLATES
-#   define __STL_MEMBER_TEMPLATE_CLASSES
-#   define __STL_TEMPLATE_FRIENDS
-#   define __STL_CLASS_PARTIAL_SPECIALIZATION
-#   define __STL_USE_EXCEPTIONS
-#   define __STL_HAS_NAMESPACES
-# endif
-
-// Intel compiler, which uses the EDG front end.
-# if defined(__ICL)
-#   define __STL_LONG_LONG 
-#   define __STL_MEMBER_TEMPLATES
-#   define __STL_MEMBER_TEMPLATE_CLASSES
-#   define __STL_TEMPLATE_FRIENDS
-#   define __STL_FUNCTION_TMPL_PARTIAL_ORDER
-#   define __STL_CLASS_PARTIAL_SPECIALIZATION
-#   define __STL_NO_DRAND48
-#   define __STL_HAS_NAMESPACES
-#   define __STL_USE_EXCEPTIONS
-#   define __STL_MEMBER_TEMPLATE_KEYWORD
-#   ifdef _CPPUNWIND
-#     define __STL_USE_EXCEPTIONS
-#   endif
-#   ifdef _MT
-#     define __STL_WIN32THREADS
-#   endif
-# endif
-
-// Mingw32, egcs compiler using the Microsoft C runtime
-# if defined(__MINGW32__)
-#   define __STL_NO_DRAND48
-#   ifdef _MT
-#     define __STL_WIN32THREADS
-#   endif
-# endif
-
-// Cygwin32, egcs compiler on MS Windows
-# if defined(__CYGWIN__)
-#   define __STL_NO_DRAND48
-# endif
-
-
-
-// Microsoft compiler.
-# if defined(_MSC_VER) && !defined(__ICL) && !defined(__MWERKS__)
-#   define __STL_NO_DRAND48
-#   define __STL_STATIC_CONST_INIT_BUG
-#   define __STL_NEED_TYPENAME
-#   define __STL_NO_USING_CLAUSE_IN_CLASS
-#   define __STL_NO_FRIEND_TEMPLATE_CLASS
-#   if _MSC_VER < 1100  /* 1000 is version 4.0, 1100 is 5.0, 1200 is 6.0. */
-#     define __STL_NEED_EXPLICIT
-#     define __STL_NO_BOOL
-#     define __STL_NO_BAD_ALLOC
-#   endif
-#   if _MSC_VER > 1000
-#     include <yvals.h>
-#     define __STL_DONT_USE_BOOL_TYPEDEF
-#   endif
-#   define __STL_NON_TYPE_TMPL_PARAM_BUG
-#   define __SGI_STL_NO_ARROW_OPERATOR
-#   define __STL_DEFAULT_CONSTRUCTOR_BUG
-#   ifdef _CPPUNWIND
-#     define __STL_USE_EXCEPTIONS
-#   endif
-#   ifdef _MT
-#     define __STL_WIN32THREADS
-#   endif
-#   if _MSC_VER >= 1200
-#     define __STL_PARTIAL_SPECIALIZATION_SYNTAX
-#     define __STL_HAS_NAMESPACES
-#     define __STL_CAN_THROW_RANGE_ERRORS
-#     define NOMINMAX
-#     undef min
-#     undef max
-// disable warning 'initializers put in unrecognized initialization area'
-#     pragma warning ( disable : 4075 )
-// disable warning 'empty controlled statement found'
-#     pragma warning ( disable : 4390 )
-// disable warning 'debug symbol greater than 255 chars'
-#     pragma warning ( disable : 4786 )
-#   endif
-#   if _MSC_VER < 1100
-#     define __STL_NO_EXCEPTION_HEADER
-#     define __STL_NO_BAD_ALLOC
-#   endif
-    // Because of a Microsoft front end bug, we must not provide a
-    // namespace qualifier when declaring a friend function.
-#   define __STD_QUALIFIER
-# endif
-
-# if defined(__BORLANDC__)
-#     define __STL_NO_BAD_ALLOC
-#     define __STL_NO_DRAND48
-#     define __STL_DEFAULT_CONSTRUCTOR_BUG
-#   if __BORLANDC__ >= 0x540 /* C++ Builder 4.0 */
-#     define __STL_CLASS_PARTIAL_SPECIALIZATION
-#     define __STL_FUNCTION_TMPL_PARTIAL_ORDER
-#     define __STL_EXPLICIT_FUNCTION_TMPL_ARGS
-#     define __STL_MEMBER_TEMPLATES
-#     define __STL_TEMPLATE_FRIENDS
-#   else
-#     define __STL_NEED_TYPENAME
-#     define __STL_LIMITED_DEFAULT_TEMPLATES
-#     define __SGI_STL_NO_ARROW_OPERATOR
-#     define __STL_NON_TYPE_TMPL_PARAM_BUG
-#   endif
-#   ifdef _CPPUNWIND
-#     define __STL_USE_EXCEPTIONS
-#   endif
-#   ifdef __MT__
-#     define __STL_WIN32THREADS
-#   endif
-# endif
-
-# if defined(__STL_NO_BOOL) && !defined(__STL_DONT_USE_BOOL_TYPEDEF)
-    typedef int bool;
-#   define true 1
-#   define false 0
-# endif
-
-# ifdef __STL_NEED_TYPENAME
-#   define typename
-# endif
-
-# ifdef __STL_LIMITED_DEFAULT_TEMPLATES
-#   define __STL_DEPENDENT_DEFAULT_TMPL(_Tp)
-# else
-#   define __STL_DEPENDENT_DEFAULT_TMPL(_Tp) = _Tp
-# endif
-
-# ifdef __STL_MEMBER_TEMPLATE_KEYWORD
-#   define __STL_TEMPLATE template
-# else
-#   define __STL_TEMPLATE
-# endif
-
-# ifdef __STL_NEED_EXPLICIT
-#   define explicit
-# endif
-
-# ifdef __STL_EXPLICIT_FUNCTION_TMPL_ARGS
-#   define __STL_nullptr_TMPL_ARGS <>
-# else
-#   define __STL_nullptr_TMPL_ARGS
-# endif
-
-# if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) \
-     || defined (__STL_PARTIAL_SPECIALIZATION_SYNTAX)
-#   define __STL_TEMPLATE_nullptr template<>
-# else
-#   define __STL_TEMPLATE_nullptr
-# endif
-
-// Use standard-conforming allocators if we have the necessary language
-// features.  __STL_USE_SGI_ALLOCATORS is a hook so that users can 
-// disable new-style allocators, and continue to use the same kind of
-// allocators as before, without having to edit library headers.
-# if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) && \
-     defined(__STL_MEMBER_TEMPLATES) && \
-     defined(__STL_MEMBER_TEMPLATE_CLASSES) && \
-    !defined(__STL_NO_BOOL) && \
-    !defined(__STL_NON_TYPE_TMPL_PARAM_BUG) && \
-    !defined(__STL_LIMITED_DEFAULT_TEMPLATES) && \
-    !defined(__STL_USE_SGI_ALLOCATORS) 
-#   define __STL_USE_STD_ALLOCATORS
-# endif
-
-# ifndef __STL_DEFAULT_ALLOCATOR
-#   ifdef __STL_USE_STD_ALLOCATORS
-#     define __STL_DEFAULT_ALLOCATOR(T) allocator< T >
-#   else
-#     define __STL_DEFAULT_ALLOCATOR(T) alloc
-#   endif
-# endif
-
-// __STL_NO_NAMESPACES is a hook so that users can disable namespaces
-// without having to edit library headers.  __STL_NO_RELOPS_NAMESPACE is
-// a hook so that users can disable the std::rel_ops namespace, keeping 
-// the relational operator template in namespace std, without having to 
-// edit library headers.
-# if defined(__STL_HAS_NAMESPACES) && !defined(__STL_NO_NAMESPACES)
-#   define __STL_USE_NAMESPACES
-#   define __STD std
-#   define __STL_BEGIN_NAMESPACE namespace std {
-#   define __STL_END_NAMESPACE }
-#   if defined(__STL_FUNCTION_TMPL_PARTIAL_ORDER) && \
-       !defined(__STL_NO_RELOPS_NAMESPACE)
-#     define __STL_USE_NAMESPACE_FOR_RELOPS
-#     define __STL_BEGIN_RELOPS_NAMESPACE namespace std { namespace rel_ops {
-#     define __STL_END_RELOPS_NAMESPACE } }
-#     define __STD_RELOPS std::rel_ops
-#   else /* Use std::rel_ops namespace */
-#     define __STL_USE_NAMESPACE_FOR_RELOPS
-#     define __STL_BEGIN_RELOPS_NAMESPACE namespace std {
-#     define __STL_END_RELOPS_NAMESPACE }
-#     define __STD_RELOPS std
-#   endif /* Use std::rel_ops namespace */
-# else
-#   define __STD 
-#   define __STL_BEGIN_NAMESPACE 
-#   define __STL_END_NAMESPACE 
-#   undef  __STL_USE_NAMESPACE_FOR_RELOPS
-#   define __STL_BEGIN_RELOPS_NAMESPACE 
-#   define __STL_END_RELOPS_NAMESPACE 
-#   define __STD_RELOPS 
-#   undef  __STL_USE_NAMESPACES
-# endif
-
-// Some versions of the EDG front end sometimes require an explicit
-// namespace spec where they shouldn't.  This macro facilitates that.
-// If the bug becomes irrelevant, then all uses of __STD_QUALIFIER
-// should be removed.  The 7.3 beta SGI compiler has this bug, but the
-// MR version is not expected to have it.
-
-# if defined(__STL_USE_NAMESPACES) && !defined(__STD_QUALIFIER)
-#   define __STD_QUALIFIER std::
-# else
-#   define __STD_QUALIFIER
-# endif
-
-# ifdef __STL_USE_EXCEPTIONS
-#   define __STL_TRY try
-#   define __STL_CATCH_ALL catch(...)
-#   define __STL_THROW(x) throw x
-#   define __STL_RETHROW throw
-#   define __STL_NOTHROW throw()
-#   define __STL_UNWIND(action) catch(...) { action; throw; }
-# else
-#   define __STL_TRY 
-#   define __STL_CATCH_ALL if (false)
-#   define __STL_THROW(x) 
-#   define __STL_RETHROW 
-#   define __STL_NOTHROW 
-#   define __STL_UNWIND(action) 
-# endif
-
-#ifdef __STL_ASSERTIONS
-# include <stdio.h>
-# define __stl_assert(expr) \
-    if (!(expr)) { fprintf(stderr, "%s:%d STL assertion failure: %s\n", \
-        __FILE__, __LINE__, # expr); abort(); }
-#else
-# define __stl_assert(expr)
-#endif
-
-#if defined(__STL_WIN32THREADS) || defined(__STL_SGI_THREADS) \
-    || defined(__STL_PTHREADS)  || defined(__STL_UITHREADS)
-#   define __STL_THREADS
-#   define __STL_VOLATILE volatile
-#else
-#   define __STL_VOLATILE
-#endif
-
-#if defined(__STL_CLASS_PARTIAL_SPECIALIZATION) \
-    && defined(__STL_MEMBER_TEMPLATES) \
-    && !defined(_STL_NO_CONCEPT_CHECKS)
-#undef __STL_USE_CONCEPT_CHECKS
-#endif
-
-
-#endif /* __STL_CONFIG_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_construct.h b/lib/include/stl/stl_construct.h
deleted file mode 100644
index 8cb7ca0..0000000
--- a/lib/include/stl/stl_construct.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_CONSTRUCT_H
-#define __SGI_STL_INTERNAL_CONSTRUCT_H
-
-#include <new>
-
-__STL_BEGIN_NAMESPACE
-
-// construct and destroy.  These functions are not part of the C++ standard,
-// and are provided for backward compatibility with the HP STL.  We also
-// provide internal names _Construct and _Destroy that can be used within
-// the library, so that standard-conforming pieces don't have to rely on
-// non-standard extensions.
-
-template <class _T1, class _T2> void construct(_T1* __p, const _T2& __value);
-template <class _T1> void construct(_T1* __p);
-template <class _Tp> void destroy(_Tp* __pointer);
-template <class _ForwardIterator> void destroy(_ForwardIterator __first, _ForwardIterator __last);
-
-
-// Internal names
-
-template <class _T1, class _T2>
-inline void _Construct(_T1* __p, const _T2& __value) {
-  new ((void*) __p) _T1(__value);
-}
-
-template <class _T1>
-inline void _Construct(_T1* __p) {
-  new ((void*) __p) _T1();
-}
-
-template <class _Tp>
-inline void _Destroy(_Tp* __pointer) {
-  __pointer->~_Tp();
-}
-
-template <class _ForwardIterator>
-void
-__destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type)
-{
-  for ( ; __first != __last; ++__first)
-    destroy(&*__first);
-}
-
-template <class _ForwardIterator> 
-inline void __destroy_aux(_ForwardIterator, _ForwardIterator, __true_type) {}
-
-template <class _ForwardIterator, class _Tp>
-inline void 
-__destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)
-{
-  typedef typename __type_traits<_Tp>::has_trivial_destructor
-          _Trivial_destructor;
-  __destroy_aux(__first, __last, _Trivial_destructor());
-}
-
-template <class _ForwardIterator>
-inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
-  __destroy(__first, __last, __VALUE_TYPE(__first));
-}
-
-inline void _Destroy(char*, char*) {}
-inline void _Destroy(int*, int*) {}
-inline void _Destroy(long*, long*) {}
-inline void _Destroy(float*, float*) {}
-inline void _Destroy(double*, double*) {}
-#ifdef __STL_HAS_WCHAR_T
-inline void _Destroy(wchar_t*, wchar_t*) {}
-#endif /* __STL_HAS_WCHAR_T */
-
-// --------------------------------------------------
-// Old names from the HP STL.
-
-template <class _T1, class _T2>
-inline void construct(_T1* __p, const _T2& __value) {
-  _Construct(__p, __value);
-}
-
-template <class _T1>
-inline void construct(_T1* __p) {
-  _Construct(__p);
-}
-
-template <class _Tp>
-inline void destroy(_Tp* __pointer) {
-  _Destroy(__pointer);
-}
-
-template <class _ForwardIterator>
-inline void destroy(_ForwardIterator __first, _ForwardIterator __last) {
-  _Destroy(__first, __last);
-}
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_CONSTRUCT_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_ctraits_fns.h b/lib/include/stl/stl_ctraits_fns.h
deleted file mode 100644
index 5577f4d..0000000
--- a/lib/include/stl/stl_ctraits_fns.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (c) 1999
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */ 
-
-// WARNING: This is an internal header file, included by other C++
-// standard library headers.  You should not attempt to use this header
-// file directly.
-
-#ifndef __SGI_STL_INTERNAL_CTRAITS_FUNCTIONS_H
-#define __SGI_STL_INTERNAL_CTRAITS_FUNCTIONS_H
-
-// This file contains a few small adapters that allow a character
-// traits class to be used as a function object.
-
-__STL_BEGIN_NAMESPACE
-
-template <class _Traits>
-struct _Eq_traits
-  : public binary_function<typename _Traits::char_type,
-                           typename _Traits::char_type,
-                           bool>
-{
-  bool operator()(const typename _Traits::char_type& __x,
-                  const typename _Traits::char_type& __y) const
-    { return _Traits::eq(__x, __y); }
-};
-
-template <class _Traits>
-struct _Eq_int_traits
-  : public binary_function<typename _Traits::char_type,
-                           typename _Traits::int_type,
-                           bool>
-{
-  bool operator()(const typename _Traits::char_type& __x,
-                  const typename _Traits::int_type& __y) const
-    { return _Traits::eq_int_type(_Traits::to_int_type(__x), __y); }
-};
-
-template <class _Traits>
-struct _Lt_traits
-  : public binary_function<typename _Traits::char_type,
-                           typename _Traits::char_type,
-                           bool>
-{
-  bool operator()(const typename _Traits::char_type& __x,
-                  const typename _Traits::char_type& __y) const
-    { return _Traits::lt(__x, __y); }
-};
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_CTRAITS_FUNCTIONS_H */
-
-// Local Variables:
-// mode:C++
-// End:
-
-
-
-
diff --git a/lib/include/stl/stl_deque.h b/lib/include/stl/stl_deque.h
deleted file mode 100644
index 13570c5..0000000
--- a/lib/include/stl/stl_deque.h
+++ /dev/null
@@ -1,1664 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#include <concept_checks.h>
-
-#ifndef __SGI_STL_INTERNAL_DEQUE_H
-#define __SGI_STL_INTERNAL_DEQUE_H
-
-/* Class invariants:
- *  For any nonsingular iterator i:
- *    i.node is the address of an element in the map array.  The
- *      contents of i.node is a pointer to the beginning of a node.
- *    i.first == *(i.node) 
- *    i.last  == i.first + node_size
- *    i.cur is a pointer in the range [i.first, i.last).  NOTE:
- *      the implication of this is that i.cur is always a dereferenceable
- *      pointer, even if i is a past-the-end iterator.
- *  Start and Finish are always nonsingular iterators.  NOTE: this means
- *    that an empty deque must have one node, and that a deque
- *    with N elements, where N is the buffer size, must have two nodes.
- *  For every node other than start.node and finish.node, every element
- *    in the node is an initialized object.  If start.node == finish.node,
- *    then [start.cur, finish.cur) are initialized objects, and
- *    the elements outside that range are uninitialized storage.  Otherwise,
- *    [start.cur, start.last) and [finish.first, finish.cur) are initialized
- *    objects, and [start.first, start.cur) and [finish.cur, finish.last)
- *    are uninitialized storage.
- *  [map, map + map_size) is a valid, non-empty range.  
- *  [start.node, finish.node] is a valid range contained within 
- *    [map, map + map_size).  
- *  A pointer in the range [map, map + map_size) points to an allocated node
- *    if and only if the pointer is in the range [start.node, finish.node].
- */
-
-
-/*
- * In previous versions of deque, there was an extra template 
- * parameter so users could control the node size.  This extension
- * turns out to violate the C++ standard (it can be detected using
- * template template parameters), and it has been removed.
- */
-
-__STL_BEGIN_NAMESPACE 
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-// Note: this function is simply a kludge to work around several compilers'
-//  bugs in handling constant expressions.
-
-#ifdef STM32PLUS_BUILD
-inline size_t __deque_buf_size(size_t __size) {
-  return __size < stm32plus::Stm32DequeBufferSize() ? size_t(stm32plus::Stm32DequeBufferSize() / __size) : size_t(1);
-}
-#else
-inline size_t __deque_buf_size(size_t __size) {
-  return __size < 512 ? size_t(512 / __size) : size_t(1);
-}
-#endif
-
-template <class _Tp, class _Ref, class _Ptr>
-struct _Deque_iterator {
-  typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;
-  typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
-  static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }
-
-  typedef random_access_iterator_tag iterator_category;
-  typedef _Tp value_type;
-  typedef _Ptr pointer;
-  typedef _Ref reference;
-  typedef size_t size_type;
-  typedef ptrdiff_t difference_type;
-  typedef _Tp** _Map_pointer;
-
-  typedef _Deque_iterator _Self;
-
-  _Tp* _M_cur;
-  _Tp* _M_first;
-  _Tp* _M_last;
-  _Map_pointer _M_node;
-
-  _Deque_iterator(_Tp* __x, _Map_pointer __y) 
-    : _M_cur(__x), _M_first(*__y),
-      _M_last(*__y + _S_buffer_size()), _M_node(__y) {}
-  _Deque_iterator() : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) {}
-  _Deque_iterator(const iterator& __x)
-    : _M_cur(__x._M_cur), _M_first(__x._M_first), 
-      _M_last(__x._M_last), _M_node(__x._M_node) {}
-
-  reference operator*() const { return *_M_cur; }
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return _M_cur; }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-
-  difference_type operator-(const _Self& __x) const {
-    return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - 1) +
-      (_M_cur - _M_first) + (__x._M_last - __x._M_cur);
-  }
-
-  _Self& operator++() {
-    ++_M_cur;
-    if (_M_cur == _M_last) {
-      _M_set_node(_M_node + 1);
-      _M_cur = _M_first;
-    }
-    return *this; 
-  }
-  _Self operator++(int)  {
-    _Self __tmp = *this;
-    ++*this;
-    return __tmp;
-  }
-
-  _Self& operator--() {
-    if (_M_cur == _M_first) {
-      _M_set_node(_M_node - 1);
-      _M_cur = _M_last;
-    }
-    --_M_cur;
-    return *this;
-  }
-  _Self operator--(int) {
-    _Self __tmp = *this;
-    --*this;
-    return __tmp;
-  }
-
-  _Self& operator+=(difference_type __n)
-  {
-    difference_type __offset = __n + (_M_cur - _M_first);
-    if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
-      _M_cur += __n;
-    else {
-      difference_type __node_offset =
-        __offset > 0 ? __offset / difference_type(_S_buffer_size())
-                   : -difference_type((-__offset - 1) / _S_buffer_size()) - 1;
-      _M_set_node(_M_node + __node_offset);
-      _M_cur = _M_first + 
-        (__offset - __node_offset * difference_type(_S_buffer_size()));
-    }
-    return *this;
-  }
-
-  _Self operator+(difference_type __n) const
-  {
-    _Self __tmp = *this;
-    return __tmp += __n;
-  }
-
-  _Self& operator-=(difference_type __n) { return *this += -__n; }
- 
-  _Self operator-(difference_type __n) const {
-    _Self __tmp = *this;
-    return __tmp -= __n;
-  }
-
-  reference operator[](difference_type __n) const { return *(*this + __n); }
-
-  bool operator==(const _Self& __x) const { return _M_cur == __x._M_cur; }
-  bool operator!=(const _Self& __x) const { return !(*this == __x); }
-  bool operator<(const _Self& __x) const {
-    return (_M_node == __x._M_node) ? 
-      (_M_cur < __x._M_cur) : (_M_node < __x._M_node);
-  }
-  bool operator>(const _Self& __x) const  { return __x < *this; }
-  bool operator<=(const _Self& __x) const { return !(__x < *this); }
-  bool operator>=(const _Self& __x) const { return !(*this < __x); }
-
-  void _M_set_node(_Map_pointer __new_node) {
-    _M_node = __new_node;
-    _M_first = *__new_node;
-    _M_last = _M_first + difference_type(_S_buffer_size());
-  }
-};
-
-template <class _Tp, class _Ref, class _Ptr>
-inline _Deque_iterator<_Tp, _Ref, _Ptr>
-operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
-{
-  return __x + __n;
-}
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Tp, class _Ref, class _Ptr>
-inline random_access_iterator_tag
-iterator_category(const _Deque_iterator<_Tp,_Ref,_Ptr>&)
-{
-  return random_access_iterator_tag();
-}
-
-template <class _Tp, class _Ref, class _Ptr>
-inline _Tp* value_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) { return 0; }
-
-template <class _Tp, class _Ref, class _Ptr>
-inline ptrdiff_t* distance_type(const _Deque_iterator<_Tp,_Ref,_Ptr>&) {
-  return 0;
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-// Deque base class.  It has two purposes.  First, its constructor
-//  and destructor allocate (but don't initialize) storage.  This makes
-//  exception safety easier.  Second, the base class encapsulates all of
-//  the differences between SGI-style allocators and standard-conforming
-//  allocators.
-
-#ifdef __STL_USE_STD_ALLOCATORS
-
-// Base class for ordinary allocators.
-template <class _Tp, class _Alloc, bool __is_static>
-class _Deque_alloc_base {
-public:
-  typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _M_node_allocator; }
-
-  _Deque_alloc_base(const allocator_type& __a)
-    : _M_node_allocator(__a), _M_map_allocator(__a),
-      _M_map(0), _M_map_size(0)
-  {}
-  
-protected:
-  typedef typename _Alloc_traits<_Tp*, _Alloc>::allocator_type
-          _Map_allocator_type;
-
-  allocator_type      _M_node_allocator;
-  _Map_allocator_type _M_map_allocator;
-
-  _Tp* _M_allocate_node() {
-    return _M_node_allocator.allocate(__deque_buf_size(sizeof(_Tp)));
-  }
-  void _M_deallocate_node(_Tp* __p) {
-    _M_node_allocator.deallocate(__p, __deque_buf_size(sizeof(_Tp)));
-  }
-  _Tp** _M_allocate_map(size_t __n) 
-    { return _M_map_allocator.allocate(__n); }
-  void _M_deallocate_map(_Tp** __p, size_t __n) 
-    { _M_map_allocator.deallocate(__p, __n); }
-
-  _Tp** _M_map;
-  size_t _M_map_size;
-};
-
-// Specialization for instanceless allocators.
-template <class _Tp, class _Alloc>
-class _Deque_alloc_base<_Tp, _Alloc, true>
-{
-public:
-  typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Deque_alloc_base(const allocator_type&) : _M_map(0), _M_map_size(0) {}
-  
-protected:
-  typedef typename _Alloc_traits<_Tp, _Alloc>::_Alloc_type _Node_alloc_type;
-  typedef typename _Alloc_traits<_Tp*, _Alloc>::_Alloc_type _Map_alloc_type;
-
-  _Tp* _M_allocate_node() {
-    return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
-  }
-  void _M_deallocate_node(_Tp* __p) {
-    _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
-  }
-  _Tp** _M_allocate_map(size_t __n) 
-    { return _Map_alloc_type::allocate(__n); }
-  void _M_deallocate_map(_Tp** __p, size_t __n) 
-    { _Map_alloc_type::deallocate(__p, __n); }
-
-  _Tp** _M_map;
-  size_t _M_map_size;
-};
-
-template <class _Tp, class _Alloc>
-class _Deque_base
-  : public _Deque_alloc_base<_Tp,_Alloc,
-                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-{
-public:
-  typedef _Deque_alloc_base<_Tp,_Alloc,
-                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-          _Base;
-  typedef typename _Base::allocator_type allocator_type;
-  typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;
-  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;
-
-  _Deque_base(const allocator_type& __a, size_t __num_elements)
-    : _Base(__a), _M_start(), _M_finish()
-    { _M_initialize_map(__num_elements); }
-  _Deque_base(const allocator_type& __a) 
-    : _Base(__a), _M_start(), _M_finish() {}
-  ~_Deque_base();    
-
-protected:
-  void _M_initialize_map(size_t);
-  void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
-  void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
-  enum { _S_initial_map_size = 8 };
-
-protected:
-  iterator _M_start;
-  iterator _M_finish;
-};
-
-#else /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Tp, class _Alloc>
-class _Deque_base {
-public:
-  typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;
-  typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;
-
-  typedef _Alloc allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Deque_base(const allocator_type&, size_t __num_elements)
-    : _M_map(0), _M_map_size(0),  _M_start(), _M_finish() {
-    _M_initialize_map(__num_elements);
-  }
-  _Deque_base(const allocator_type&)
-    : _M_map(0), _M_map_size(0),  _M_start(), _M_finish() {}
-  ~_Deque_base();    
-
-protected:
-  void _M_initialize_map(size_t);
-  void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
-  void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
-  enum { _S_initial_map_size = 8 };
-
-protected:
-  _Tp** _M_map;
-  size_t _M_map_size;  
-  iterator _M_start;
-  iterator _M_finish;
-
-  typedef simple_alloc<_Tp, _Alloc>  _Node_alloc_type;
-  typedef simple_alloc<_Tp*, _Alloc> _Map_alloc_type;
-
-  _Tp* _M_allocate_node()
-    { return _Node_alloc_type::allocate(__deque_buf_size(sizeof(_Tp))); }
-  void _M_deallocate_node(_Tp* __p)
-    { _Node_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp))); }
-  _Tp** _M_allocate_map(size_t __n) 
-    { return _Map_alloc_type::allocate(__n); }
-  void _M_deallocate_map(_Tp** __p, size_t __n) 
-    { _Map_alloc_type::deallocate(__p, __n); }
-};
-
-#endif /* __STL_USE_STD_ALLOCATORS */
-
-// Non-inline member functions from _Deque_base.
-
-template <class _Tp, class _Alloc>
-_Deque_base<_Tp,_Alloc>::~_Deque_base() {
-  if (_Base::_M_map) {
-    _M_destroy_nodes(_M_start._M_node, _M_finish._M_node + 1);
-    this->_M_deallocate_map(_Base::_M_map, _Base::_M_map_size);
-  }
-}
-
-template <class _Tp, class _Alloc>
-void
-_Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)
-{
-  size_t __num_nodes = 
-    __num_elements / __deque_buf_size(sizeof(_Tp)) + 1;
-
-  _Base::_M_map_size = max((size_t) _S_initial_map_size, __num_nodes + 2);
-  _Base::_M_map = this->_M_allocate_map(_Base::_M_map_size);
-
-  _Tp** __nstart = _Base::_M_map + (_Base::_M_map_size - __num_nodes) / 2;
-  _Tp** __nfinish = __nstart + __num_nodes;
-    
-  __STL_TRY {
-    _M_create_nodes(__nstart, __nfinish);
-  }
-  __STL_UNWIND((this->_M_deallocate_map(_Base::_M_map, _Base::_M_map_size), 
-                _Base::_M_map = 0, _Base::_M_map_size = 0));
-  _M_start._M_set_node(__nstart);
-  _M_finish._M_set_node(__nfinish - 1);
-  _M_start._M_cur = _M_start._M_first;
-  _M_finish._M_cur = _M_finish._M_first +
-               __num_elements % __deque_buf_size(sizeof(_Tp));
-}
-
-template <class _Tp, class _Alloc>
-void _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
-{
-  _Tp** __cur;
-  __STL_TRY {
-    for (__cur = __nstart; __cur < __nfinish; ++__cur)
-      *__cur = _Base::_M_allocate_node();
-  }
-  __STL_UNWIND(_M_destroy_nodes(__nstart, __cur));
-}
-
-template <class _Tp, class _Alloc>
-void
-_Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
-{
-  for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
-    this->_M_deallocate_node(*__n);
-}
-
-template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >
-class deque : protected _Deque_base<_Tp, _Alloc> {
-
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-
-  typedef _Deque_base<_Tp, _Alloc> _Base;
-public:                         // Basic types
-  typedef _Tp value_type;
-  typedef value_type* pointer;
-  typedef const value_type* const_pointer;
-  typedef value_type& reference;
-  typedef const value_type& const_reference;
-  typedef size_t size_type;
-  typedef ptrdiff_t difference_type;
-
-  typedef typename _Base::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _Base::get_allocator(); }
-
-public:                         // Iterators
-  typedef typename _Base::iterator       iterator;
-  typedef typename _Base::const_iterator const_iterator;
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
-  typedef std::reverse_iterator<iterator> reverse_iterator;
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-  typedef reverse_iterator<const_iterator, value_type, const_reference, 
-                           difference_type>  
-          const_reverse_iterator;
-  typedef reverse_iterator<iterator, value_type, reference, difference_type>
-          reverse_iterator; 
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-protected:                      // Internal typedefs
-  typedef pointer* _Map_pointer;
-  static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }
-
-protected:
-#ifdef __STL_USE_NAMESPACES
-  using _Base::_M_initialize_map;
-  using _Base::_M_create_nodes;
-  using _Base::_M_destroy_nodes;
-  using _Base::_M_allocate_node;
-  using _Base::_M_deallocate_node;
-  using _Base::_M_allocate_map;
-  using _Base::_M_deallocate_map;
-
-  using _Base::_M_map;
-  using _Base::_M_map_size;
-  using _Base::_M_start;
-  using _Base::_M_finish;
-#endif /* __STL_USE_NAMESPACES */
-
-public:                         // Basic accessors
-  iterator begin() { return _M_start; }
-  iterator end() { return _M_finish; }
-  const_iterator begin() const { return _M_start; }
-  const_iterator end() const { return _M_finish; }
-
-  reverse_iterator rbegin() { return reverse_iterator(_M_finish); }
-  reverse_iterator rend() { return reverse_iterator(_M_start); }
-  const_reverse_iterator rbegin() const 
-    { return const_reverse_iterator(_M_finish); }
-  const_reverse_iterator rend() const 
-    { return const_reverse_iterator(_M_start); }
-
-  reference operator[](size_type __n)
-    { return _M_start[difference_type(__n)]; }
-  const_reference operator[](size_type __n) const 
-    { return _M_start[difference_type(__n)]; }
-
-#ifdef __STL_THROW_RANGE_ERRORS
-  void _M_range_check(size_type __n) const {
-    if (__n >= this->size())
-      __stl_throw_range_error("deque");
-  }
-
-  reference at(size_type __n)
-    { _M_range_check(__n); return (*this)[__n]; }
-  const_reference at(size_type __n) const
-    { _M_range_check(__n); return (*this)[__n]; }
-#endif /* __STL_THROW_RANGE_ERRORS */
-
-  reference front() { return *_M_start; }
-  reference back() {
-    iterator __tmp = _M_finish;
-    --__tmp;
-    return *__tmp;
-  }
-  const_reference front() const { return *_M_start; }
-  const_reference back() const {
-    const_iterator __tmp = _M_finish;
-    --__tmp;
-    return *__tmp;
-  }
-
-  size_type size() const { return _M_finish - _M_start; }
-  size_type max_size() const { return size_type(-1); }
-  bool empty() const { return _M_finish == _M_start; }
-
-public:                         // Constructor, destructor.
-  explicit deque(const allocator_type& __a = allocator_type()) 
-    : _Base(__a, 0) {}
-  deque(const deque& __x) : _Base(__x.get_allocator(), __x.size()) 
-    { uninitialized_copy(__x.begin(), __x.end(), _M_start); }
-  deque(size_type __n, const value_type& __value,
-        const allocator_type& __a = allocator_type()) : _Base(__a, __n)
-    { _M_fill_initialize(__value); }
-  explicit deque(size_type __n) : _Base(allocator_type(), __n)
-    { _M_fill_initialize(value_type()); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  // Check whether it's an integral type.  If so, it's not an iterator.
-  template <class _InputIterator>
-  deque(_InputIterator __first, _InputIterator __last,
-        const allocator_type& __a = allocator_type()) : _Base(__a) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_initialize_dispatch(__first, __last, _Integral());
-  }
-
-  template <class _Integer>
-  void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {
-    _M_initialize_map(__n);
-    _M_fill_initialize(__x);
-  }
-
-  template <class _InputIter>
-  void _M_initialize_dispatch(_InputIter __first, _InputIter __last,
-                              __false_type) {
-    _M_range_initialize(__first, __last, __ITERATOR_CATEGORY(__first));
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-  deque(const value_type* __first, const value_type* __last,
-        const allocator_type& __a = allocator_type()) 
-    : _Base(__a, __last - __first)
-    { uninitialized_copy(__first, __last, _M_start); }
-  deque(const_iterator __first, const_iterator __last,
-        const allocator_type& __a = allocator_type()) 
-    : _Base(__a, __last - __first)
-    { uninitialized_copy(__first, __last, _M_start); }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  ~deque() { destroy(_M_start, _M_finish); }
-
-  deque& operator= (const deque& __x) {
-    const size_type __len = size();
-    if (&__x != this) {
-      if (__len >= __x.size())
-        erase(copy(__x.begin(), __x.end(), _M_start), _M_finish);
-      else {
-        const_iterator __mid = __x.begin() + difference_type(__len);
-        copy(__x.begin(), __mid, _M_start);
-        insert(_M_finish, __mid, __x.end());
-      }
-    }
-    return *this;
-  }        
-
-  void swap(deque& __x) {
-    __STD::swap(_M_start, __x._M_start);
-    __STD::swap(_M_finish, __x._M_finish);
-    __STD::swap(_M_map, __x._M_map);
-    __STD::swap(_M_map_size, __x._M_map_size);
-  }
-
-public: 
-  // assign(), a generalized assignment member function.  Two
-  // versions: one that takes a count, and one that takes a range.
-  // The range version is a member template, so we dispatch on whether
-  // or not the type is an integer.
-
-  void _M_fill_assign(size_type __n, const _Tp& __val) {
-    if (__n > size()) {
-      fill(begin(), end(), __val);
-      insert(end(), __n - size(), __val);
-    }
-    else {
-      erase(begin() + __n, end());
-      fill(begin(), end(), __val);
-    }
-  }
-
-  void assign(size_type __n, const _Tp& __val) {
-    _M_fill_assign(__n, __val);
-  }
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  template <class _InputIterator>
-  void assign(_InputIterator __first, _InputIterator __last) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_assign_dispatch(__first, __last, _Integral());
-  }
-
-private:                        // helper functions for assign() 
-
-  template <class _Integer>
-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
-    { _M_fill_assign((size_type) __n, (_Tp) __val); }
-
-  template <class _InputIterator>
-  void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
-                          __false_type) {
-    _M_assign_aux(__first, __last, __ITERATOR_CATEGORY(__first));
-  }
-
-  template <class _InputIterator>
-  void _M_assign_aux(_InputIterator __first, _InputIterator __last,
-                     input_iterator_tag);
-
-  template <class _ForwardIterator>
-  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
-                     forward_iterator_tag) {
-    size_type __len = 0;
-    distance(__first, __last, __len);
-    if (__len > size()) {
-      _ForwardIterator __mid = __first;
-      advance(__mid, size());
-      copy(__first, __mid, begin());
-      insert(end(), __mid, __last);
-    }
-    else
-      erase(copy(__first, __last, begin()), end());
-  }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:                         // push_* and pop_*
-  
-  void push_back(const value_type& __t) {
-    if (_M_finish._M_cur != _M_finish._M_last - 1) {
-      construct(_M_finish._M_cur, __t);
-      ++_M_finish._M_cur;
-    }
-    else
-      _M_push_back_aux(__t);
-  }
-
-  void push_back() {
-    if (_M_finish._M_cur != _M_finish._M_last - 1) {
-      construct(_M_finish._M_cur);
-      ++_M_finish._M_cur;
-    }
-    else
-      _M_push_back_aux();
-  }
-
-  void push_front(const value_type& __t) {
-    if (_M_start._M_cur != _M_start._M_first) {
-      construct(_M_start._M_cur - 1, __t);
-      --_M_start._M_cur;
-    }
-    else
-      _M_push_front_aux(__t);
-  }
-
-  void push_front() {
-    if (_M_start._M_cur != _M_start._M_first) {
-      construct(_M_start._M_cur - 1);
-      --_M_start._M_cur;
-    }
-    else
-      _M_push_front_aux();
-  }
-
-
-  void pop_back() {
-    if (_M_finish._M_cur != _M_finish._M_first) {
-      --_M_finish._M_cur;
-      destroy(_M_finish._M_cur);
-    }
-    else
-      _M_pop_back_aux();
-  }
-
-  void pop_front() {
-    if (_M_start._M_cur != _M_start._M_last - 1) {
-      destroy(_M_start._M_cur);
-      ++_M_start._M_cur;
-    }
-    else 
-      _M_pop_front_aux();
-  }
-
-public:                         // Insert
-
-  iterator insert(iterator position, const value_type& __x) {
-    if (position._M_cur == _M_start._M_cur) {
-      push_front(__x);
-      return _M_start;
-    }
-    else if (position._M_cur == _M_finish._M_cur) {
-      push_back(__x);
-      iterator __tmp = _M_finish;
-      --__tmp;
-      return __tmp;
-    }
-    else {
-      return _M_insert_aux(position, __x);
-    }
-  }
-
-  iterator insert(iterator __position)
-    { return insert(__position, value_type()); }
-
-  void insert(iterator __pos, size_type __n, const value_type& __x)
-    { _M_fill_insert(__pos, __n, __x); }
-
-  void _M_fill_insert(iterator __pos, size_type __n, const value_type& __x); 
-
-#ifdef __STL_MEMBER_TEMPLATES  
-
-  // Check whether it's an integral type.  If so, it's not an iterator.
-  template <class _InputIterator>
-  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_insert_dispatch(__pos, __first, __last, _Integral());
-  }
-
-  template <class _Integer>
-  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
-                          __true_type) {
-    _M_fill_insert(__pos, (size_type) __n, (value_type) __x);
-  }
-
-  template <class _InputIterator>
-  void _M_insert_dispatch(iterator __pos,
-                          _InputIterator __first, _InputIterator __last,
-                          __false_type) {
-    insert(__pos, __first, __last, __ITERATOR_CATEGORY(__first));
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-  void insert(iterator __pos,
-              const value_type* __first, const value_type* __last);
-  void insert(iterator __pos,
-              const_iterator __first, const_iterator __last);
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  void resize(size_type __new_size, const value_type& __x) {
-    const size_type __len = size();
-    if (__new_size < __len) 
-      erase(_M_start + __new_size, _M_finish);
-    else
-      insert(_M_finish, __new_size - __len, __x);
-  }
-
-  void resize(size_type new_size) { resize(new_size, value_type()); }
-
-public:                         // Erase
-  iterator erase(iterator __pos) {
-    iterator __next = __pos;
-    ++__next;
-    difference_type __index = __pos - _M_start;
-    if (size_type(__index) < (this->size() >> 1)) {
-      copy_backward(_M_start, __pos, __next);
-      pop_front();
-    }
-    else {
-      copy(__next, _M_finish, __pos);
-      pop_back();
-    }
-    return _M_start + __index;
-  }
-
-  iterator erase(iterator __first, iterator __last);
-  void clear(); 
-
-protected:                        // Internal construction/destruction
-
-  void _M_fill_initialize(const value_type& __value);
-
-#ifdef __STL_MEMBER_TEMPLATES  
-
-  template <class _InputIterator>
-  void _M_range_initialize(_InputIterator __first, _InputIterator __last,
-                        input_iterator_tag);
-
-  template <class _ForwardIterator>
-  void _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
-                        forward_iterator_tag);
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-protected:                        // Internal push_* and pop_*
-
-  void _M_push_back_aux(const value_type&);
-  void _M_push_back_aux();
-  void _M_push_front_aux(const value_type&);
-  void _M_push_front_aux();
-  void _M_pop_back_aux();
-  void _M_pop_front_aux();
-
-protected:                        // Internal insert functions
-
-#ifdef __STL_MEMBER_TEMPLATES  
-
-  template <class _InputIterator>
-  void insert(iterator __pos, _InputIterator __first, _InputIterator __last,
-              input_iterator_tag);
-
-  template <class _ForwardIterator>
-  void insert(iterator __pos,
-              _ForwardIterator __first, _ForwardIterator __last,
-              forward_iterator_tag);
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  iterator _M_insert_aux(iterator __pos, const value_type& __x);
-  iterator _M_insert_aux(iterator __pos);
-  void _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);
-
-#ifdef __STL_MEMBER_TEMPLATES  
-
-  template <class _ForwardIterator>
-  void _M_insert_aux(iterator __pos, 
-                     _ForwardIterator __first, _ForwardIterator __last,
-                     size_type __n);
-
-#else /* __STL_MEMBER_TEMPLATES */
-  
-  void _M_insert_aux(iterator __pos,
-                     const value_type* __first, const value_type* __last,
-                     size_type __n);
-
-  void _M_insert_aux(iterator __pos, 
-                     const_iterator __first, const_iterator __last,
-                     size_type __n);
- 
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  iterator _M_reserve_elements_at_front(size_type __n) {
-    size_type __vacancies = _M_start._M_cur - _M_start._M_first;
-    if (__n > __vacancies) 
-      _M_new_elements_at_front(__n - __vacancies);
-    return _M_start - difference_type(__n);
-  }
-
-  iterator _M_reserve_elements_at_back(size_type __n) {
-    size_type __vacancies = (_M_finish._M_last - _M_finish._M_cur) - 1;
-    if (__n > __vacancies)
-      _M_new_elements_at_back(__n - __vacancies);
-    return _M_finish + difference_type(__n);
-  }
-
-  void _M_new_elements_at_front(size_type __new_elements);
-  void _M_new_elements_at_back(size_type __new_elements);
-
-protected:                      // Allocation of _M_map and nodes
-
-  // Makes sure the _M_map has space for new nodes.  Does not actually
-  //  add the nodes.  Can invalidate _M_map pointers.  (And consequently, 
-  //  deque iterators.)
-
-  void _M_reserve_map_at_back (size_type __nodes_to_add = 1) {
-    if (__nodes_to_add + 1 > _M_map_size - (_M_finish._M_node - _M_map))
-      _M_reallocate_map(__nodes_to_add, false);
-  }
-
-  void _M_reserve_map_at_front (size_type __nodes_to_add = 1) {
-    if (__nodes_to_add > size_type(_M_start._M_node - _M_map))
-      _M_reallocate_map(__nodes_to_add, true);
-  }
-
-  void _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
-};
-
-// Non-inline member functions
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Alloc>
-template <class _InputIter>
-void deque<_Tp, _Alloc>
-  ::_M_assign_aux(_InputIter __first, _InputIter __last, input_iterator_tag)
-{
-  iterator __cur = begin();
-  for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
-    *__cur = *__first;
-  if (__first == __last)
-    erase(__cur, end());
-  else
-    insert(end(), __first, __last);
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-void deque<_Tp, _Alloc>::_M_fill_insert(iterator __pos,
-                                        size_type __n, const value_type& __x)
-{
-  if (__pos._M_cur == _M_start._M_cur) {
-    iterator __new_start = _M_reserve_elements_at_front(__n);
-    __STL_TRY {
-      uninitialized_fill(__new_start, _M_start, __x);
-      _M_start = __new_start;
-    }
-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));
-  }
-  else if (__pos._M_cur == _M_finish._M_cur) {
-    iterator __new_finish = _M_reserve_elements_at_back(__n);
-    __STL_TRY {
-      uninitialized_fill(_M_finish, __new_finish, __x);
-      _M_finish = __new_finish;
-    }
-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, 
-                                  __new_finish._M_node + 1));    
-  }
-  else 
-    _M_insert_aux(__pos, __n, __x);
-}
-
-#ifndef __STL_MEMBER_TEMPLATES  
-
-template <class _Tp, class _Alloc>
-void deque<_Tp, _Alloc>::insert(iterator __pos,
-                                const value_type* __first,
-                                const value_type* __last) {
-  size_type __n = __last - __first;
-  if (__pos._M_cur == _M_start._M_cur) {
-    iterator __new_start = _M_reserve_elements_at_front(__n);
-    __STL_TRY {
-      uninitialized_copy(__first, __last, __new_start);
-      _M_start = __new_start;
-    }
-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));
-  }
-  else if (__pos._M_cur == _M_finish._M_cur) {
-    iterator __new_finish = _M_reserve_elements_at_back(__n);
-    __STL_TRY {
-      uninitialized_copy(__first, __last, _M_finish);
-      _M_finish = __new_finish;
-    }
-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, 
-                                  __new_finish._M_node + 1));
-  }
-  else
-    _M_insert_aux(__pos, __first, __last, __n);
-}
-
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::insert(iterator __pos,
-                               const_iterator __first, const_iterator __last)
-{
-  size_type __n = __last - __first;
-  if (__pos._M_cur == _M_start._M_cur) {
-    iterator __new_start = _M_reserve_elements_at_front(__n);
-    __STL_TRY {
-      uninitialized_copy(__first, __last, __new_start);
-      _M_start = __new_start;
-    }
-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));
-  }
-  else if (__pos._M_cur == _M_finish._M_cur) {
-    iterator __new_finish = _M_reserve_elements_at_back(__n);
-    __STL_TRY {
-      uninitialized_copy(__first, __last, _M_finish);
-      _M_finish = __new_finish;
-    }
-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, 
-                 __new_finish._M_node + 1));
-  }
-  else
-    _M_insert_aux(__pos, __first, __last, __n);
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-typename deque<_Tp,_Alloc>::iterator 
-deque<_Tp,_Alloc>::erase(iterator __first, iterator __last)
-{
-  if (__first == _M_start && __last == _M_finish) {
-    clear();
-    return _M_finish;
-  }
-  else {
-    difference_type __n = __last - __first;
-    difference_type __elems_before = __first - _M_start;
-    if (__elems_before < difference_type((this->size() - __n) / 2)) {
-      copy_backward(_M_start, __first, __last);
-      iterator __new_start = _M_start + __n;
-      destroy(_M_start, __new_start);
-      _M_destroy_nodes(__new_start._M_node, _M_start._M_node);
-      _M_start = __new_start;
-    }
-    else {
-      copy(__last, _M_finish, __first);
-      iterator __new_finish = _M_finish - __n;
-      destroy(__new_finish, _M_finish);
-      _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);
-      _M_finish = __new_finish;
-    }
-    return _M_start + __elems_before;
-  }
-}
-
-template <class _Tp, class _Alloc> 
-void deque<_Tp,_Alloc>::clear()
-{
-  for (_Map_pointer __node = _M_start._M_node + 1;
-       __node < _M_finish._M_node;
-       ++__node) {
-    destroy(*__node, *__node + _S_buffer_size());
-    _M_deallocate_node(*__node);
-  }
-
-  if (_M_start._M_node != _M_finish._M_node) {
-    destroy(_M_start._M_cur, _M_start._M_last);
-    destroy(_M_finish._M_first, _M_finish._M_cur);
-    _M_deallocate_node(_M_finish._M_first);
-  }
-  else
-    destroy(_M_start._M_cur, _M_finish._M_cur);
-
-  _M_finish = _M_start;
-}
-
-// Precondition: _M_start and _M_finish have already been initialized,
-// but none of the deque's elements have yet been constructed.
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value) {
-  _Map_pointer __cur;
-  __STL_TRY {
-    for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)
-      uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);
-    uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);
-  }
-  __STL_UNWIND(destroy(_M_start, iterator(*__cur, __cur)));
-}
-
-#ifdef __STL_MEMBER_TEMPLATES  
-
-template <class _Tp, class _Alloc> template <class _InputIterator>
-void deque<_Tp,_Alloc>::_M_range_initialize(_InputIterator __first,
-                                            _InputIterator __last,
-                                            input_iterator_tag)
-{
-  _M_initialize_map(0);
-  __STL_TRY {
-    for ( ; __first != __last; ++__first)
-      push_back(*__first);
-  }
-  __STL_UNWIND(clear());
-}
-
-template <class _Tp, class _Alloc> template <class _ForwardIterator>
-void deque<_Tp,_Alloc>::_M_range_initialize(_ForwardIterator __first,
-                                            _ForwardIterator __last,
-                                            forward_iterator_tag)
-{
-  size_type __n = 0;
-  distance(__first, __last, __n);
-  _M_initialize_map(__n);
-
-  _Map_pointer __cur_node;
-  __STL_TRY {
-    for (__cur_node = _M_start._M_node; 
-         __cur_node < _M_finish._M_node; 
-         ++__cur_node) {
-      _ForwardIterator __mid = __first;
-      advance(__mid, _S_buffer_size());
-      uninitialized_copy(__first, __mid, *__cur_node);
-      __first = __mid;
-    }
-    uninitialized_copy(__first, __last, _M_finish._M_first);
-  }
-  __STL_UNWIND(destroy(_M_start, iterator(*__cur_node, __cur_node)));
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-// Called only if _M_finish._M_cur == _M_finish._M_last - 1.
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_push_back_aux(const value_type& __t)
-{
-  value_type __t_copy = __t;
-  _M_reserve_map_at_back();
-  *(_M_finish._M_node + 1) = _M_allocate_node();
-  __STL_TRY {
-    construct(_M_finish._M_cur, __t_copy);
-    _M_finish._M_set_node(_M_finish._M_node + 1);
-    _M_finish._M_cur = _M_finish._M_first;
-  }
-  __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + 1)));
-}
-
-// Called only if _M_finish._M_cur == _M_finish._M_last - 1.
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_push_back_aux()
-{
-  _M_reserve_map_at_back();
-  *(_M_finish._M_node + 1) = _M_allocate_node();
-  __STL_TRY {
-    construct(_M_finish._M_cur);
-    _M_finish._M_set_node(_M_finish._M_node + 1);
-    _M_finish._M_cur = _M_finish._M_first;
-  }
-  __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + 1)));
-}
-
-// Called only if _M_start._M_cur == _M_start._M_first.
-template <class _Tp, class _Alloc>
-void  deque<_Tp,_Alloc>::_M_push_front_aux(const value_type& __t)
-{
-  value_type __t_copy = __t;
-  _M_reserve_map_at_front();
-  *(_M_start._M_node - 1) = _M_allocate_node();
-  __STL_TRY {
-    _M_start._M_set_node(_M_start._M_node - 1);
-    _M_start._M_cur = _M_start._M_last - 1;
-    construct(_M_start._M_cur, __t_copy);
-  }
-  __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - 1))));
-} 
-
-// Called only if _M_start._M_cur == _M_start._M_first.
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_push_front_aux()
-{
-  _M_reserve_map_at_front();
-  *(_M_start._M_node - 1) = _M_allocate_node();
-  __STL_TRY {
-    _M_start._M_set_node(_M_start._M_node - 1);
-    _M_start._M_cur = _M_start._M_last - 1;
-    construct(_M_start._M_cur);
-  }
-  __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - 1))));
-} 
-
-// Called only if _M_finish._M_cur == _M_finish._M_first.
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_pop_back_aux()
-{
-  _M_deallocate_node(_M_finish._M_first);
-  _M_finish._M_set_node(_M_finish._M_node - 1);
-  _M_finish._M_cur = _M_finish._M_last - 1;
-  destroy(_M_finish._M_cur);
-}
-
-// Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that 
-// if the deque has at least one element (a precondition for this member 
-// function), and if _M_start._M_cur == _M_start._M_last, then the deque 
-// must have at least two nodes.
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_pop_front_aux()
-{
-  destroy(_M_start._M_cur);
-  _M_deallocate_node(_M_start._M_first);
-  _M_start._M_set_node(_M_start._M_node + 1);
-  _M_start._M_cur = _M_start._M_first;
-}      
-
-#ifdef __STL_MEMBER_TEMPLATES  
-
-template <class _Tp, class _Alloc> template <class _InputIterator>
-void deque<_Tp,_Alloc>::insert(iterator __pos,
-                               _InputIterator __first, _InputIterator __last,
-                               input_iterator_tag)
-{
-  copy(__first, __last, inserter(*this, __pos));
-}
-
-template <class _Tp, class _Alloc> template <class _ForwardIterator>
-void
-deque<_Tp,_Alloc>::insert(iterator __pos,
-                          _ForwardIterator __first, _ForwardIterator __last,
-                          forward_iterator_tag) {
-  size_type __n = 0;
-  distance(__first, __last, __n);
-  if (__pos._M_cur == _M_start._M_cur) {
-    iterator __new_start = _M_reserve_elements_at_front(__n);
-    __STL_TRY {
-      uninitialized_copy(__first, __last, __new_start);
-      _M_start = __new_start;
-    }
-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));
-  }
-  else if (__pos._M_cur == _M_finish._M_cur) {
-    iterator __new_finish = _M_reserve_elements_at_back(__n);
-    __STL_TRY {
-      uninitialized_copy(__first, __last, _M_finish);
-      _M_finish = __new_finish;
-    }
-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, 
-                                  __new_finish._M_node + 1));
-  }
-  else
-    _M_insert_aux(__pos, __first, __last, __n);
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-typename deque<_Tp, _Alloc>::iterator
-deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos, const value_type& __x)
-{
-  difference_type __index = __pos - _M_start;
-  value_type __x_copy = __x;
-  if (size_type(__index) < this->size() / 2) {
-    push_front(front());
-    iterator __front1 = _M_start;
-    ++__front1;
-    iterator __front2 = __front1;
-    ++__front2;
-    __pos = _M_start + __index;
-    iterator __pos1 = __pos;
-    ++__pos1;
-    copy(__front2, __pos1, __front1);
-  }
-  else {
-    push_back(back());
-    iterator __back1 = _M_finish;
-    --__back1;
-    iterator __back2 = __back1;
-    --__back2;
-    __pos = _M_start + __index;
-    copy_backward(__pos, __back2, __back1);
-  }
-  *__pos = __x_copy;
-  return __pos;
-}
-
-template <class _Tp, class _Alloc>
-typename deque<_Tp,_Alloc>::iterator 
-deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos)
-{
-  difference_type __index = __pos - _M_start;
-  if (__index < size() / 2) {
-    push_front(front());
-    iterator __front1 = _M_start;
-    ++__front1;
-    iterator __front2 = __front1;
-    ++__front2;
-    __pos = _M_start + __index;
-    iterator __pos1 = __pos;
-    ++__pos1;
-    copy(__front2, __pos1, __front1);
-  }
-  else {
-    push_back(back());
-    iterator __back1 = _M_finish;
-    --__back1;
-    iterator __back2 = __back1;
-    --__back2;
-    __pos = _M_start + __index;
-    copy_backward(__pos, __back2, __back1);
-  }
-  *__pos = value_type();
-  return __pos;
-}
-
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,
-                                      size_type __n,
-                                      const value_type& __x)
-{
-  const difference_type __elems_before = __pos - _M_start;
-  size_type __length = this->size();
-  value_type __x_copy = __x;
-  if (__elems_before < difference_type(__length / 2)) {
-    iterator __new_start = _M_reserve_elements_at_front(__n);
-    iterator __old_start = _M_start;
-    __pos = _M_start + __elems_before;
-    __STL_TRY {
-      if (__elems_before >= difference_type(__n)) {
-        iterator __start_n = _M_start + difference_type(__n);
-        uninitialized_copy(_M_start, __start_n, __new_start);
-        _M_start = __new_start;
-        copy(__start_n, __pos, __old_start);
-        fill(__pos - difference_type(__n), __pos, __x_copy);
-      }
-      else {
-        __uninitialized_copy_fill(_M_start, __pos, __new_start, 
-                                  _M_start, __x_copy);
-        _M_start = __new_start;
-        fill(__old_start, __pos, __x_copy);
-      }
-    }
-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));
-  }
-  else {
-    iterator __new_finish = _M_reserve_elements_at_back(__n);
-    iterator __old_finish = _M_finish;
-    const difference_type __elems_after = 
-      difference_type(__length) - __elems_before;
-    __pos = _M_finish - __elems_after;
-    __STL_TRY {
-      if (__elems_after > difference_type(__n)) {
-        iterator __finish_n = _M_finish - difference_type(__n);
-        uninitialized_copy(__finish_n, _M_finish, _M_finish);
-        _M_finish = __new_finish;
-        copy_backward(__pos, __finish_n, __old_finish);
-        fill(__pos, __pos + difference_type(__n), __x_copy);
-      }
-      else {
-        __uninitialized_fill_copy(_M_finish, __pos + difference_type(__n),
-                                  __x_copy, __pos, _M_finish);
-        _M_finish = __new_finish;
-        fill(__pos, __old_finish, __x_copy);
-      }
-    }
-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, 
-                                  __new_finish._M_node + 1));
-  }
-}
-
-#ifdef __STL_MEMBER_TEMPLATES  
-
-template <class _Tp, class _Alloc> template <class _ForwardIterator>
-void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,
-                                      _ForwardIterator __first,
-                                      _ForwardIterator __last,
-                                      size_type __n)
-{
-  const difference_type __elemsbefore = __pos - _M_start;
-  size_type __length = size();
-
-#ifdef STM32PLUS_BUILD
-  if ((unsigned long)__elemsbefore < __length / 2) {        // ptrdiff_t = signed on STM32 (long int)
-#else
-  if (__elemsbefore < __length / 2) {
-#endif
-    iterator __new_start = _M_reserve_elements_at_front(__n);
-    iterator __old_start = _M_start;
-    __pos = _M_start + __elemsbefore;
-    __STL_TRY {
-      if (__elemsbefore >= difference_type(__n)) {
-        iterator __start_n = _M_start + difference_type(__n); 
-        uninitialized_copy(_M_start, __start_n, __new_start);
-        _M_start = __new_start;
-        copy(__start_n, __pos, __old_start);
-        copy(__first, __last, __pos - difference_type(__n));
-      }
-      else {
-        _ForwardIterator __mid = __first;
-        advance(__mid, difference_type(__n) - __elemsbefore);
-        __uninitialized_copy_copy(_M_start, __pos, __first, __mid,
-                                  __new_start);
-        _M_start = __new_start;
-        copy(__mid, __last, __old_start);
-      }
-    }
-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));
-  }
-  else {
-    iterator __new_finish = _M_reserve_elements_at_back(__n);
-    iterator __old_finish = _M_finish;
-    const difference_type __elemsafter = 
-      difference_type(__length) - __elemsbefore;
-    __pos = _M_finish - __elemsafter;
-    __STL_TRY {
-      if (__elemsafter > difference_type(__n)) {
-        iterator __finish_n = _M_finish - difference_type(__n);
-        uninitialized_copy(__finish_n, _M_finish, _M_finish);
-        _M_finish = __new_finish;
-        copy_backward(__pos, __finish_n, __old_finish);
-        copy(__first, __last, __pos);
-      }
-      else {
-        _ForwardIterator __mid = __first;
-        advance(__mid, __elemsafter);
-        __uninitialized_copy_copy(__mid, __last, __pos, _M_finish, _M_finish);
-        _M_finish = __new_finish;
-        copy(__first, __mid, __pos);
-      }
-    }
-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, 
-                                  __new_finish._M_node + 1));
-  }
-}
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,
-                                      const value_type* __first,
-                                      const value_type* __last,
-                                      size_type __n)
-{
-  const difference_type __elemsbefore = __pos - _M_start;
-  size_type __length = size();
-  if (__elemsbefore < __length / 2) {
-    iterator __new_start = _M_reserve_elements_at_front(__n);
-    iterator __old_start = _M_start;
-    __pos = _M_start + __elemsbefore;
-    __STL_TRY {
-      if (__elemsbefore >= difference_type(__n)) {
-        iterator __start_n = _M_start + difference_type(__n);
-        uninitialized_copy(_M_start, __start_n, __new_start);
-        _M_start = __new_start;
-        copy(__start_n, __pos, __old_start);
-        copy(__first, __last, __pos - difference_type(__n));
-      }
-      else {
-        const value_type* __mid = 
-          __first + (difference_type(__n) - __elemsbefore);
-        __uninitialized_copy_copy(_M_start, __pos, __first, __mid,
-                                  __new_start);
-        _M_start = __new_start;
-        copy(__mid, __last, __old_start);
-      }
-    }
-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));
-  }
-  else {
-    iterator __new_finish = _M_reserve_elements_at_back(__n);
-    iterator __old_finish = _M_finish;
-    const difference_type __elemsafter = 
-      difference_type(__length) - __elemsbefore;
-    __pos = _M_finish - __elemsafter;
-    __STL_TRY {
-      if (__elemsafter > difference_type(__n)) {
-        iterator __finish_n = _M_finish - difference_type(__n);
-        uninitialized_copy(__finish_n, _M_finish, _M_finish);
-        _M_finish = __new_finish;
-        copy_backward(__pos, __finish_n, __old_finish);
-        copy(__first, __last, __pos);
-      }
-      else {
-        const value_type* __mid = __first + __elemsafter;
-        __uninitialized_copy_copy(__mid, __last, __pos, _M_finish, _M_finish);
-        _M_finish = __new_finish;
-        copy(__first, __mid, __pos);
-      }
-    }
-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, 
-                                  __new_finish._M_node + 1));
-  }
-}
-
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_insert_aux(iterator __pos,
-                                      const_iterator __first,
-                                      const_iterator __last,
-                                      size_type __n)
-{
-  const difference_type __elemsbefore = __pos - _M_start;
-  size_type __length = size();
-  if (__elemsbefore < __length / 2) {
-    iterator __new_start = _M_reserve_elements_at_front(__n);
-    iterator __old_start = _M_start;
-    __pos = _M_start + __elemsbefore;
-    __STL_TRY {
-      if (__elemsbefore >= __n) {
-        iterator __start_n = _M_start + __n;
-        uninitialized_copy(_M_start, __start_n, __new_start);
-        _M_start = __new_start;
-        copy(__start_n, __pos, __old_start);
-        copy(__first, __last, __pos - difference_type(__n));
-      }
-      else {
-        const_iterator __mid = __first + (__n - __elemsbefore);
-        __uninitialized_copy_copy(_M_start, __pos, __first, __mid,
-                                  __new_start);
-        _M_start = __new_start;
-        copy(__mid, __last, __old_start);
-      }
-    }
-    __STL_UNWIND(_M_destroy_nodes(__new_start._M_node, _M_start._M_node));
-  }
-  else {
-    iterator __new_finish = _M_reserve_elements_at_back(__n);
-    iterator __old_finish = _M_finish;
-    const difference_type __elemsafter = __length - __elemsbefore;
-    __pos = _M_finish - __elemsafter;
-    __STL_TRY {
-      if (__elemsafter > __n) {
-        iterator __finish_n = _M_finish - difference_type(__n);
-        uninitialized_copy(__finish_n, _M_finish, _M_finish);
-        _M_finish = __new_finish;
-        copy_backward(__pos, __finish_n, __old_finish);
-        copy(__first, __last, __pos);
-      }
-      else {
-        const_iterator __mid = __first + __elemsafter;
-        __uninitialized_copy_copy(__mid, __last, __pos, _M_finish, _M_finish);
-        _M_finish = __new_finish;
-        copy(__first, __mid, __pos);
-      }
-    }
-    __STL_UNWIND(_M_destroy_nodes(_M_finish._M_node + 1, 
-                 __new_finish._M_node + 1));
-  }
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_new_elements_at_front(size_type __new_elems)
-{
-  size_type __new_nodes
-      = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
-  _M_reserve_map_at_front(__new_nodes);
-  size_type __i;
-  __STL_TRY {
-    for (__i = 1; __i <= __new_nodes; ++__i)
-      *(_M_start._M_node - __i) = _M_allocate_node();
-  }
-#       ifdef __STL_USE_EXCEPTIONS
-  catch(...) {
-    for (size_type __j = 1; __j < __i; ++__j)
-      _M_deallocate_node(*(_M_start._M_node - __j));      
-    throw;
-  }
-#       endif /* __STL_USE_EXCEPTIONS */
-}
-
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_new_elements_at_back(size_type __new_elems)
-{
-  size_type __new_nodes
-      = (__new_elems + _S_buffer_size() - 1) / _S_buffer_size();
-  _M_reserve_map_at_back(__new_nodes);
-  size_type __i;
-  __STL_TRY {
-    for (__i = 1; __i <= __new_nodes; ++__i)
-      *(_M_finish._M_node + __i) = _M_allocate_node();
-  }
-#       ifdef __STL_USE_EXCEPTIONS
-  catch(...) {
-    for (size_type __j = 1; __j < __i; ++__j)
-      _M_deallocate_node(*(_M_finish._M_node + __j));      
-    throw;
-  }
-#       endif /* __STL_USE_EXCEPTIONS */
-}
-
-template <class _Tp, class _Alloc>
-void deque<_Tp,_Alloc>::_M_reallocate_map(size_type __nodes_to_add,
-                                          bool __add_at_front)
-{
-  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;
-  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
-
-  _Map_pointer __new_nstart;
-  if (_M_map_size > 2 * __new_num_nodes) {
-    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 
-                     + (__add_at_front ? __nodes_to_add : 0);
-    if (__new_nstart < _M_start._M_node)
-      copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);
-    else
-      copy_backward(_M_start._M_node, _M_finish._M_node + 1, 
-                    __new_nstart + __old_num_nodes);
-  }
-  else {
-    size_type __new_map_size = 
-      _M_map_size + max(_M_map_size, __nodes_to_add) + 2;
-
-    _Map_pointer __new_map = _M_allocate_map(__new_map_size);
-    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
-                         + (__add_at_front ? __nodes_to_add : 0);
-    copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);
-    _M_deallocate_map(_M_map, _M_map_size);
-
-    _M_map = __new_map;
-    _M_map_size = __new_map_size;
-  }
-
-  _M_start._M_set_node(__new_nstart);
-  _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
-}
-
-
-// Nonmember functions.
-
-template <class _Tp, class _Alloc>
-inline bool operator==(const deque<_Tp, _Alloc>& __x,
-                       const deque<_Tp, _Alloc>& __y) {
-  return __x.size() == __y.size() &&
-         equal(__x.begin(), __x.end(), __y.begin());
-}
-
-template <class _Tp, class _Alloc>
-inline bool operator<(const deque<_Tp, _Alloc>& __x,
-                      const deque<_Tp, _Alloc>& __y) {
-  return lexicographical_compare(__x.begin(), __x.end(), 
-                                 __y.begin(), __y.end());
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Tp, class _Alloc>
-inline bool operator!=(const deque<_Tp, _Alloc>& __x,
-                       const deque<_Tp, _Alloc>& __y) {
-  return !(__x == __y);
-}
-
-template <class _Tp, class _Alloc>
-inline bool operator>(const deque<_Tp, _Alloc>& __x,
-                      const deque<_Tp, _Alloc>& __y) {
-  return __y < __x;
-}
-
-template <class _Tp, class _Alloc>
-inline bool operator<=(const deque<_Tp, _Alloc>& __x,
-                       const deque<_Tp, _Alloc>& __y) {
-  return !(__y < __x);
-}
-template <class _Tp, class _Alloc>
-inline bool operator>=(const deque<_Tp, _Alloc>& __x,
-                       const deque<_Tp, _Alloc>& __y) {
-  return !(__x < __y);
-}
-
-template <class _Tp, class _Alloc>
-inline void swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y) {
-  __x.swap(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-          
-__STL_END_NAMESPACE 
-  
-#endif /* __SGI_STL_INTERNAL_DEQUE_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_function.h b/lib/include/stl/stl_function.h
deleted file mode 100644
index 7ec55fc..0000000
--- a/lib/include/stl/stl_function.h
+++ /dev/null
@@ -1,729 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996-1998
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_FUNCTION_H
-#define __SGI_STL_INTERNAL_FUNCTION_H
-
-__STL_BEGIN_NAMESPACE
-
-template <class _Arg, class _Result>
-struct unary_function {
-  typedef _Arg argument_type;
-  typedef _Result result_type;
-};
-
-template <class _Arg1, class _Arg2, class _Result>
-struct binary_function {
-  typedef _Arg1 first_argument_type;
-  typedef _Arg2 second_argument_type;
-  typedef _Result result_type;
-};      
-
-template <class _Tp>
-struct plus : public binary_function<_Tp,_Tp,_Tp> {
-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x + __y; }
-};
-
-template <class _Tp>
-struct minus : public binary_function<_Tp,_Tp,_Tp> {
-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x - __y; }
-};
-
-template <class _Tp>
-struct multiplies : public binary_function<_Tp,_Tp,_Tp> {
-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x * __y; }
-};
-
-template <class _Tp>
-struct divides : public binary_function<_Tp,_Tp,_Tp> {
-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x / __y; }
-};
-
-// identity_element (not part of the C++ standard).
-
-template <class _Tp> inline _Tp identity_element(plus<_Tp>) {
-  return _Tp(0);
-}
-template <class _Tp> inline _Tp identity_element(multiplies<_Tp>) {
-  return _Tp(1);
-}
-
-template <class _Tp>
-struct modulus : public binary_function<_Tp,_Tp,_Tp> 
-{
-  _Tp operator()(const _Tp& __x, const _Tp& __y) const { return __x % __y; }
-};
-
-template <class _Tp>
-struct negate : public unary_function<_Tp,_Tp> 
-{
-  _Tp operator()(const _Tp& __x) const { return -__x; }
-};
-
-template <class _Tp>
-struct equal_to : public binary_function<_Tp,_Tp,bool> 
-{
-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x == __y; }
-};
-
-template <class _Tp>
-struct not_equal_to : public binary_function<_Tp,_Tp,bool> 
-{
-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x != __y; }
-};
-
-template <class _Tp>
-struct greater : public binary_function<_Tp,_Tp,bool> 
-{
-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x > __y; }
-};
-
-template <class _Tp>
-struct less : public binary_function<_Tp,_Tp,bool> 
-{
-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x < __y; }
-};
-
-template <class _Tp>
-struct greater_equal : public binary_function<_Tp,_Tp,bool>
-{
-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x >= __y; }
-};
-
-template <class _Tp>
-struct less_equal : public binary_function<_Tp,_Tp,bool> 
-{
-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x <= __y; }
-};
-
-template <class _Tp>
-struct logical_and : public binary_function<_Tp,_Tp,bool>
-{
-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x && __y; }
-};
-
-template <class _Tp>
-struct logical_or : public binary_function<_Tp,_Tp,bool>
-{
-  bool operator()(const _Tp& __x, const _Tp& __y) const { return __x || __y; }
-};
-
-template <class _Tp>
-struct logical_not : public unary_function<_Tp,bool>
-{
-  bool operator()(const _Tp& __x) const { return !__x; }
-};
-
-template <class _Predicate>
-class unary_negate
-  : public unary_function<typename _Predicate::argument_type, bool> {
-protected:
-  _Predicate _M_pred;
-public:
-  explicit unary_negate(const _Predicate& __x) : _M_pred(__x) {}
-  bool operator()(const typename _Predicate::argument_type& __x) const {
-    return !_M_pred(__x);
-  }
-};
-
-template <class _Predicate>
-inline unary_negate<_Predicate> 
-not1(const _Predicate& __pred)
-{
-  return unary_negate<_Predicate>(__pred);
-}
-
-template <class _Predicate> 
-class binary_negate 
-  : public binary_function<typename _Predicate::first_argument_type,
-                           typename _Predicate::second_argument_type,
-                           bool> {
-protected:
-  _Predicate _M_pred;
-public:
-  explicit binary_negate(const _Predicate& __x) : _M_pred(__x) {}
-  bool operator()(const typename _Predicate::first_argument_type& __x, 
-                  const typename _Predicate::second_argument_type& __y) const
-  {
-    return !_M_pred(__x, __y); 
-  }
-};
-
-template <class _Predicate>
-inline binary_negate<_Predicate> 
-not2(const _Predicate& __pred)
-{
-  return binary_negate<_Predicate>(__pred);
-}
-
-template <class _Operation> 
-class binder1st
-  : public unary_function<typename _Operation::second_argument_type,
-                          typename _Operation::result_type> {
-protected:
-  _Operation op;
-  typename _Operation::first_argument_type value;
-public:
-  binder1st(const _Operation& __x,
-            const typename _Operation::first_argument_type& __y)
-      : op(__x), value(__y) {}
-  typename _Operation::result_type
-  operator()(const typename _Operation::second_argument_type& __x) const {
-    return op(value, __x); 
-  }
-};
-
-template <class _Operation, class _Tp>
-inline binder1st<_Operation> 
-bind1st(const _Operation& __fn, const _Tp& __x) 
-{
-  typedef typename _Operation::first_argument_type _Arg1_type;
-  return binder1st<_Operation>(__fn, _Arg1_type(__x));
-}
-
-template <class _Operation> 
-class binder2nd
-  : public unary_function<typename _Operation::first_argument_type,
-                          typename _Operation::result_type> {
-protected:
-  _Operation op;
-  typename _Operation::second_argument_type value;
-public:
-  binder2nd(const _Operation& __x,
-            const typename _Operation::second_argument_type& __y) 
-      : op(__x), value(__y) {}
-  typename _Operation::result_type
-  operator()(const typename _Operation::first_argument_type& __x) const {
-    return op(__x, value); 
-  }
-};
-
-template <class _Operation, class _Tp>
-inline binder2nd<_Operation> 
-bind2nd(const _Operation& __fn, const _Tp& __x) 
-{
-  typedef typename _Operation::second_argument_type _Arg2_type;
-  return binder2nd<_Operation>(__fn, _Arg2_type(__x));
-}
-
-// unary_compose and binary_compose (extensions, not part of the standard).
-
-template <class _Operation1, class _Operation2>
-class unary_compose
-  : public unary_function<typename _Operation2::argument_type,
-                          typename _Operation1::result_type> 
-{
-protected:
-  _Operation1 _M_fn1;
-  _Operation2 _M_fn2;
-public:
-  unary_compose(const _Operation1& __x, const _Operation2& __y) 
-    : _M_fn1(__x), _M_fn2(__y) {}
-  typename _Operation1::result_type
-  operator()(const typename _Operation2::argument_type& __x) const {
-    return _M_fn1(_M_fn2(__x));
-  }
-};
-
-template <class _Operation1, class _Operation2>
-inline unary_compose<_Operation1,_Operation2> 
-compose1(const _Operation1& __fn1, const _Operation2& __fn2)
-{
-  return unary_compose<_Operation1,_Operation2>(__fn1, __fn2);
-}
-
-template <class _Operation1, class _Operation2, class _Operation3>
-class binary_compose
-  : public unary_function<typename _Operation2::argument_type,
-                          typename _Operation1::result_type> {
-protected:
-  _Operation1 _M_fn1;
-  _Operation2 _M_fn2;
-  _Operation3 _M_fn3;
-public:
-  binary_compose(const _Operation1& __x, const _Operation2& __y, 
-                 const _Operation3& __z) 
-    : _M_fn1(__x), _M_fn2(__y), _M_fn3(__z) { }
-  typename _Operation1::result_type
-  operator()(const typename _Operation2::argument_type& __x) const {
-    return _M_fn1(_M_fn2(__x), _M_fn3(__x));
-  }
-};
-
-template <class _Operation1, class _Operation2, class _Operation3>
-inline binary_compose<_Operation1, _Operation2, _Operation3> 
-compose2(const _Operation1& __fn1, const _Operation2& __fn2, 
-         const _Operation3& __fn3)
-{
-  return binary_compose<_Operation1,_Operation2,_Operation3>
-    (__fn1, __fn2, __fn3);
-}
-
-template <class _Arg, class _Result>
-class pointer_to_unary_function : public unary_function<_Arg, _Result> {
-protected:
-  _Result (*_M_ptr)(_Arg);
-public:
-  pointer_to_unary_function() {}
-  explicit pointer_to_unary_function(_Result (*__x)(_Arg)) : _M_ptr(__x) {}
-  _Result operator()(_Arg __x) const { return _M_ptr(__x); }
-};
-
-template <class _Arg, class _Result>
-inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))
-{
-  return pointer_to_unary_function<_Arg, _Result>(__x);
-}
-
-template <class _Arg1, class _Arg2, class _Result>
-class pointer_to_binary_function : 
-  public binary_function<_Arg1,_Arg2,_Result> {
-protected:
-    _Result (*_M_ptr)(_Arg1, _Arg2);
-public:
-    pointer_to_binary_function() {}
-    explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2)) 
-      : _M_ptr(__x) {}
-    _Result operator()(_Arg1 __x, _Arg2 __y) const {
-      return _M_ptr(__x, __y);
-    }
-};
-
-template <class _Arg1, class _Arg2, class _Result>
-inline pointer_to_binary_function<_Arg1,_Arg2,_Result> 
-ptr_fun(_Result (*__x)(_Arg1, _Arg2)) {
-  return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__x);
-}
-
-// identity is an extensions: it is not part of the standard.
-template <class _Tp>
-struct _Identity : public unary_function<_Tp,_Tp> {
-  const _Tp& operator()(const _Tp& __x) const { return __x; }
-};
-
-template <class _Tp> struct identity : public _Identity<_Tp> {};
-
-// select1st and select2nd are extensions: they are not part of the standard.
-template <class _Pair>
-struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
-  const typename _Pair::first_type& operator()(const _Pair& __x) const {
-    return __x.first;
-  }
-};
-
-template <class _Pair>
-struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type>
-{
-  const typename _Pair::second_type& operator()(const _Pair& __x) const {
-    return __x.second;
-  }
-};
-
-template <class _Pair> struct select1st : public _Select1st<_Pair> {};
-template <class _Pair> struct select2nd : public _Select2nd<_Pair> {};
-
-// project1st and project2nd are extensions: they are not part of the standard
-template <class _Arg1, class _Arg2>
-struct _Project1st : public binary_function<_Arg1, _Arg2, _Arg1> {
-  _Arg1 operator()(const _Arg1& __x, const _Arg2&) const { return __x; }
-};
-
-template <class _Arg1, class _Arg2>
-struct _Project2nd : public binary_function<_Arg1, _Arg2, _Arg2> {
-  _Arg2 operator()(const _Arg1&, const _Arg2& __y) const { return __y; }
-};
-
-template <class _Arg1, class _Arg2> 
-struct project1st : public _Project1st<_Arg1, _Arg2> {};
-
-template <class _Arg1, class _Arg2>
-struct project2nd : public _Project2nd<_Arg1, _Arg2> {};
-
-// constant_void_fun, constant_unary_fun, and constant_binary_fun are
-// extensions: they are not part of the standard.  (The same, of course,
-// is true of the helper functions constant0, constant1, and constant2.)
-
-template <class _Result>
-struct _Constant_void_fun {
-  typedef _Result result_type;
-  result_type _M_val;
-
-  _Constant_void_fun(const result_type& __v) : _M_val(__v) {}
-  const result_type& operator()() const { return _M_val; }
-};  
-
-template <class _Result, class _Argument>
-struct _Constant_unary_fun {
-  typedef _Argument argument_type;
-  typedef  _Result  result_type;
-  result_type _M_val;
-
-  _Constant_unary_fun(const result_type& __v) : _M_val(__v) {}
-  const result_type& operator()(const _Argument&) const { return _M_val; }
-};
-
-template <class _Result, class _Arg1, class _Arg2>
-struct _Constant_binary_fun {
-  typedef  _Arg1   first_argument_type;
-  typedef  _Arg2   second_argument_type;
-  typedef  _Result result_type;
-  _Result _M_val;
-
-  _Constant_binary_fun(const _Result& __v) : _M_val(__v) {}
-  const result_type& operator()(const _Arg1&, const _Arg2&) const {
-    return _M_val;
-  }
-};
-
-template <class _Result>
-struct constant_void_fun : public _Constant_void_fun<_Result> {
-  constant_void_fun(const _Result& __v) : _Constant_void_fun<_Result>(__v) {}
-};  
-
-
-template <class _Result,
-          class _Argument __STL_DEPENDENT_DEFAULT_TMPL(_Result)>
-struct constant_unary_fun : public _Constant_unary_fun<_Result, _Argument>
-{
-  constant_unary_fun(const _Result& __v)
-    : _Constant_unary_fun<_Result, _Argument>(__v) {}
-};
-
-
-template <class _Result,
-          class _Arg1 __STL_DEPENDENT_DEFAULT_TMPL(_Result),
-          class _Arg2 __STL_DEPENDENT_DEFAULT_TMPL(_Arg1)>
-struct constant_binary_fun
-  : public _Constant_binary_fun<_Result, _Arg1, _Arg2>
-{
-  constant_binary_fun(const _Result& __v)
-    : _Constant_binary_fun<_Result, _Arg1, _Arg2>(__v) {}
-};
-
-template <class _Result>
-inline constant_void_fun<_Result> constant0(const _Result& __val)
-{
-  return constant_void_fun<_Result>(__val);
-}
-
-template <class _Result>
-inline constant_unary_fun<_Result,_Result> constant1(const _Result& __val)
-{
-  return constant_unary_fun<_Result,_Result>(__val);
-}
-
-template <class _Result>
-inline constant_binary_fun<_Result,_Result,_Result> 
-constant2(const _Result& __val)
-{
-  return constant_binary_fun<_Result,_Result,_Result>(__val);
-}
-
-// subtractive_rng is an extension: it is not part of the standard.
-// Note: this code assumes that int is 32 bits.
-class subtractive_rng : public unary_function<unsigned int, unsigned int> {
-private:
-  unsigned int _M_table[55];
-  size_t _M_index1;
-  size_t _M_index2;
-public:
-  unsigned int operator()(unsigned int __limit) {
-    _M_index1 = (_M_index1 + 1) % 55;
-    _M_index2 = (_M_index2 + 1) % 55;
-    _M_table[_M_index1] = _M_table[_M_index1] - _M_table[_M_index2];
-    return _M_table[_M_index1] % __limit;
-  }
-
-  void _M_initialize(unsigned int __seed)
-  {
-    unsigned int __k = 1;
-    _M_table[54] = __seed;
-    size_t __i;
-    for (__i = 0; __i < 54; __i++) {
-        size_t __ii = (21 * (__i + 1) % 55) - 1;
-        _M_table[__ii] = __k;
-        __k = __seed - __k;
-        __seed = _M_table[__ii];
-    }
-    for (int __loop = 0; __loop < 4; __loop++) {
-        for (__i = 0; __i < 55; __i++)
-            _M_table[__i] = _M_table[__i] - _M_table[(1 + __i + 30) % 55];
-    }
-    _M_index1 = 0;
-    _M_index2 = 31;
-  }
-
-  subtractive_rng(unsigned int __seed) { _M_initialize(__seed); }
-#ifdef STM32PLUS_BUILD
-  subtractive_rng() { _M_initialize(16180u); }
-#else
-  subtractive_rng() { _M_initialize(161803398u); }
-#endif
-};
-
-
-// Adaptor function objects: pointers to member functions.
-
-// There are a total of 16 = 2^4 function objects in this family.
-//  (1) Member functions taking no arguments vs member functions taking
-//       one argument.
-//  (2) Call through pointer vs call through reference.
-//  (3) Member function with void return type vs member function with
-//      non-void return type.
-//  (4) Const vs non-const member function.
-
-// Note that choice (3) is nothing more than a workaround: according
-//  to the draft, compilers should handle void and non-void the same way.
-//  This feature is not yet widely implemented, though.  You can only use
-//  member functions returning void if your compiler supports partial
-//  specialization.
-
-// All of this complexity is in the function objects themselves.  You can
-//  ignore it by using the helper function mem_fun and mem_fun_ref,
-//  which create whichever type of adaptor is appropriate.
-//  (mem_fun1 and mem_fun1_ref are no longer part of the C++ standard,
-//  but they are provided for backward compatibility.)
-
-
-template <class _Ret, class _Tp>
-class mem_fun_t : public unary_function<_Tp*,_Ret> {
-public:
-  explicit mem_fun_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}
-  _Ret operator()(_Tp* __p) const { return (__p->*_M_f)(); }
-private:
-  _Ret (_Tp::*_M_f)();
-};
-
-template <class _Ret, class _Tp>
-class const_mem_fun_t : public unary_function<const _Tp*,_Ret> {
-public:
-  explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}
-  _Ret operator()(const _Tp* __p) const { return (__p->*_M_f)(); }
-private:
-  _Ret (_Tp::*_M_f)() const;
-};
-
-
-template <class _Ret, class _Tp>
-class mem_fun_ref_t : public unary_function<_Tp,_Ret> {
-public:
-  explicit mem_fun_ref_t(_Ret (_Tp::*__pf)()) : _M_f(__pf) {}
-  _Ret operator()(_Tp& __r) const { return (__r.*_M_f)(); }
-private:
-  _Ret (_Tp::*_M_f)();
-};
-
-template <class _Ret, class _Tp>
-class const_mem_fun_ref_t : public unary_function<_Tp,_Ret> {
-public:
-  explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const) : _M_f(__pf) {}
-  _Ret operator()(const _Tp& __r) const { return (__r.*_M_f)(); }
-private:
-  _Ret (_Tp::*_M_f)() const;
-};
-
-template <class _Ret, class _Tp, class _Arg>
-class mem_fun1_t : public binary_function<_Tp*,_Arg,_Ret> {
-public:
-  explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
-  _Ret operator()(_Tp* __p, _Arg __x) const { return (__p->*_M_f)(__x); }
-private:
-  _Ret (_Tp::*_M_f)(_Arg);
-};
-
-template <class _Ret, class _Tp, class _Arg>
-class const_mem_fun1_t : public binary_function<const _Tp*,_Arg,_Ret> {
-public:
-  explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
-  _Ret operator()(const _Tp* __p, _Arg __x) const
-    { return (__p->*_M_f)(__x); }
-private:
-  _Ret (_Tp::*_M_f)(_Arg) const;
-};
-
-template <class _Ret, class _Tp, class _Arg>
-class mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
-public:
-  explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
-  _Ret operator()(_Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
-private:
-  _Ret (_Tp::*_M_f)(_Arg);
-};
-
-template <class _Ret, class _Tp, class _Arg>
-class const_mem_fun1_ref_t : public binary_function<_Tp,_Arg,_Ret> {
-public:
-  explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
-  _Ret operator()(const _Tp& __r, _Arg __x) const { return (__r.*_M_f)(__x); }
-private:
-  _Ret (_Tp::*_M_f)(_Arg) const;
-};
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Tp>
-class mem_fun_t<void, _Tp> : public unary_function<_Tp*,void> {
-public:
-  explicit mem_fun_t(void (_Tp::*__pf)()) : _M_f(__pf) {}
-  void operator()(_Tp* __p) const { (__p->*_M_f)(); }
-private:
-  void (_Tp::*_M_f)();
-};
-
-template <class _Tp>
-class const_mem_fun_t<void, _Tp> : public unary_function<const _Tp*,void> {
-public:
-  explicit const_mem_fun_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}
-  void operator()(const _Tp* __p) const { (__p->*_M_f)(); }
-private:
-  void (_Tp::*_M_f)() const;
-};
-
-template <class _Tp>
-class mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
-public:
-  explicit mem_fun_ref_t(void (_Tp::*__pf)()) : _M_f(__pf) {}
-  void operator()(_Tp& __r) const { (__r.*_M_f)(); }
-private:
-  void (_Tp::*_M_f)();
-};
-
-template <class _Tp>
-class const_mem_fun_ref_t<void, _Tp> : public unary_function<_Tp,void> {
-public:
-  explicit const_mem_fun_ref_t(void (_Tp::*__pf)() const) : _M_f(__pf) {}
-  void operator()(const _Tp& __r) const { (__r.*_M_f)(); }
-private:
-  void (_Tp::*_M_f)() const;
-};
-
-template <class _Tp, class _Arg>
-class mem_fun1_t<void, _Tp, _Arg> : public binary_function<_Tp*,_Arg,void> {
-public:
-  explicit mem_fun1_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
-  void operator()(_Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
-private:
-  void (_Tp::*_M_f)(_Arg);
-};
-
-template <class _Tp, class _Arg>
-class const_mem_fun1_t<void, _Tp, _Arg> 
-  : public binary_function<const _Tp*,_Arg,void> {
-public:
-  explicit const_mem_fun1_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
-  void operator()(const _Tp* __p, _Arg __x) const { (__p->*_M_f)(__x); }
-private:
-  void (_Tp::*_M_f)(_Arg) const;
-};
-
-template <class _Tp, class _Arg>
-class mem_fun1_ref_t<void, _Tp, _Arg>
-  : public binary_function<_Tp,_Arg,void> {
-public:
-  explicit mem_fun1_ref_t(void (_Tp::*__pf)(_Arg)) : _M_f(__pf) {}
-  void operator()(_Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
-private:
-  void (_Tp::*_M_f)(_Arg);
-};
-
-template <class _Tp, class _Arg>
-class const_mem_fun1_ref_t<void, _Tp, _Arg>
-  : public binary_function<_Tp,_Arg,void> {
-public:
-  explicit const_mem_fun1_ref_t(void (_Tp::*__pf)(_Arg) const) : _M_f(__pf) {}
-  void operator()(const _Tp& __r, _Arg __x) const { (__r.*_M_f)(__x); }
-private:
-  void (_Tp::*_M_f)(_Arg) const;
-};
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-// Mem_fun adaptor helper functions.  There are only two:
-//  mem_fun and mem_fun_ref.  (mem_fun1 and mem_fun1_ref 
-//  are provided for backward compatibility, but they are no longer
-//  part of the C++ standard.)
-
-template <class _Ret, class _Tp>
-inline mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)())
-  { return mem_fun_t<_Ret,_Tp>(__f); }
-
-template <class _Ret, class _Tp>
-inline const_mem_fun_t<_Ret,_Tp> mem_fun(_Ret (_Tp::*__f)() const)
-  { return const_mem_fun_t<_Ret,_Tp>(__f); }
-
-template <class _Ret, class _Tp>
-inline mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)()) 
-  { return mem_fun_ref_t<_Ret,_Tp>(__f); }
-
-template <class _Ret, class _Tp>
-inline const_mem_fun_ref_t<_Ret,_Tp> mem_fun_ref(_Ret (_Tp::*__f)() const)
-  { return const_mem_fun_ref_t<_Ret,_Tp>(__f); }
-
-template <class _Ret, class _Tp, class _Arg>
-inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))
-  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }
-
-template <class _Ret, class _Tp, class _Arg>
-inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const)
-  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }
-
-template <class _Ret, class _Tp, class _Arg>
-inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
-  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }
-
-template <class _Ret, class _Tp, class _Arg>
-inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>
-mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
-  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }
-
-template <class _Ret, class _Tp, class _Arg>
-inline mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg))
-  { return mem_fun1_t<_Ret,_Tp,_Arg>(__f); }
-
-template <class _Ret, class _Tp, class _Arg>
-inline const_mem_fun1_t<_Ret,_Tp,_Arg> mem_fun1(_Ret (_Tp::*__f)(_Arg) const)
-  { return const_mem_fun1_t<_Ret,_Tp,_Arg>(__f); }
-
-template <class _Ret, class _Tp, class _Arg>
-inline mem_fun1_ref_t<_Ret,_Tp,_Arg> mem_fun1_ref(_Ret (_Tp::*__f)(_Arg))
-  { return mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }
-
-template <class _Ret, class _Tp, class _Arg>
-inline const_mem_fun1_ref_t<_Ret,_Tp,_Arg>
-mem_fun1_ref(_Ret (_Tp::*__f)(_Arg) const)
-  { return const_mem_fun1_ref_t<_Ret,_Tp,_Arg>(__f); }
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_FUNCTION_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_hash_fun.h b/lib/include/stl/stl_hash_fun.h
deleted file mode 100644
index ada6a0b..0000000
--- a/lib/include/stl/stl_hash_fun.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (c) 1996-1998
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_HASH_FUN_H
-#define __SGI_STL_HASH_FUN_H
-
-#include <stddef.h>
-
-__STL_BEGIN_NAMESPACE
-
-template <class _Key> struct hash { };
-
-inline size_t __stl_hash_string(const char* __s)
-{
-  unsigned long __h = 0; 
-  for ( ; *__s; ++__s)
-    __h = 5*__h + *__s;
-  
-  return size_t(__h);
-}
-
-__STL_TEMPLATE_nullptr struct hash<char*>
-{
-  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
-};
-
-__STL_TEMPLATE_nullptr struct hash<const char*>
-{
-  size_t operator()(const char* __s) const { return __stl_hash_string(__s); }
-};
-
-__STL_TEMPLATE_nullptr struct hash<char> {
-  size_t operator()(char __x) const { return __x; }
-};
-__STL_TEMPLATE_nullptr struct hash<unsigned char> {
-  size_t operator()(unsigned char __x) const { return __x; }
-};
-__STL_TEMPLATE_nullptr struct hash<signed char> {
-  size_t operator()(unsigned char __x) const { return __x; }
-};
-__STL_TEMPLATE_nullptr struct hash<short> {
-  size_t operator()(short __x) const { return __x; }
-};
-__STL_TEMPLATE_nullptr struct hash<unsigned short> {
-  size_t operator()(unsigned short __x) const { return __x; }
-};
-__STL_TEMPLATE_nullptr struct hash<int> {
-  size_t operator()(int __x) const { return __x; }
-};
-__STL_TEMPLATE_nullptr struct hash<unsigned int> {
-  size_t operator()(unsigned int __x) const { return __x; }
-};
-__STL_TEMPLATE_nullptr struct hash<long> {
-  size_t operator()(long __x) const { return __x; }
-};
-__STL_TEMPLATE_nullptr struct hash<unsigned long> {
-  size_t operator()(unsigned long __x) const { return __x; }
-};
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_HASH_FUN_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_hash_map.h b/lib/include/stl/stl_hash_map.h
deleted file mode 100644
index 245c374..0000000
--- a/lib/include/stl/stl_hash_map.h
+++ /dev/null
@@ -1,532 +0,0 @@
-/*
- * Copyright (c) 1996
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_HASH_MAP_H
-#define __SGI_STL_INTERNAL_HASH_MAP_H
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-// Forward declaration of equality operator; needed for friend declaration.
-
-template <class _Key, class _Tp,
-          class _HashFcn  __STL_DEPENDENT_DEFAULT_TMPL(hash<_Key>),
-          class _EqualKey __STL_DEPENDENT_DEFAULT_TMPL(equal_to<_Key>),
-          class _Alloc =  __STL_DEFAULT_ALLOCATOR(_Tp) >
-class hash_map;
-
-template <class _Key, class _Tp, class _HashFn, class _EqKey, class _Alloc>
-inline bool operator==(const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&,
-                       const hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc>&);
-
-template <class _Key, class _Tp, class _HashFcn, class _EqualKey,
-          class _Alloc>
-class hash_map
-{
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Key, _Assignable);
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Key);
-  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Key, _Key);
-
-private:
-  typedef hashtable<pair<const _Key,_Tp>,_Key,_HashFcn,
-                    _Select1st<pair<const _Key,_Tp> >,_EqualKey,_Alloc> _Ht;
-  _Ht _M_ht;
-
-public:
-  typedef typename _Ht::key_type key_type;
-  typedef _Tp data_type;
-  typedef _Tp mapped_type;
-  typedef typename _Ht::value_type value_type;
-  typedef typename _Ht::hasher hasher;
-  typedef typename _Ht::key_equal key_equal;
-  
-  typedef typename _Ht::size_type size_type;
-  typedef typename _Ht::difference_type difference_type;
-  typedef typename _Ht::pointer pointer;
-  typedef typename _Ht::const_pointer const_pointer;
-  typedef typename _Ht::reference reference;
-  typedef typename _Ht::const_reference const_reference;
-
-  typedef typename _Ht::iterator iterator;
-  typedef typename _Ht::const_iterator const_iterator;
-
-  typedef typename _Ht::allocator_type allocator_type;
-
-  hasher hash_funct() const { return _M_ht.hash_funct(); }
-  key_equal key_eq() const { return _M_ht.key_eq(); }
-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }
-
-public:
-  hash_map() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}
-  explicit hash_map(size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}
-  hash_map(size_type __n, const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}
-  hash_map(size_type __n, const hasher& __hf, const key_equal& __eql,
-           const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a) {}
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  hash_map(_InputIterator __f, _InputIterator __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  template <class _InputIterator>
-  hash_map(_InputIterator __f, _InputIterator __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  template <class _InputIterator>
-  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,
-           const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  template <class _InputIterator>
-  hash_map(_InputIterator __f, _InputIterator __l, size_type __n,
-           const hasher& __hf, const key_equal& __eql,
-           const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_unique(__f, __l); }
-
-#else
-  hash_map(const value_type* __f, const value_type* __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_map(const value_type* __f, const value_type* __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_map(const value_type* __f, const value_type* __l, size_type __n,
-           const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_map(const value_type* __f, const value_type* __l, size_type __n,
-           const hasher& __hf, const key_equal& __eql,
-           const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_unique(__f, __l); }
-
-  hash_map(const_iterator __f, const_iterator __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_map(const_iterator __f, const_iterator __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_map(const_iterator __f, const_iterator __l, size_type __n,
-           const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_map(const_iterator __f, const_iterator __l, size_type __n,
-           const hasher& __hf, const key_equal& __eql,
-           const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_unique(__f, __l); }
-#endif /*__STL_MEMBER_TEMPLATES */
-
-public:
-  size_type size() const { return _M_ht.size(); }
-  size_type max_size() const { return _M_ht.max_size(); }
-  bool empty() const { return _M_ht.empty(); }
-  void swap(hash_map& __hs) { _M_ht.swap(__hs._M_ht); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _K1, class _T1, class _HF, class _EqK, class _Al>
-  friend bool operator== (const hash_map<_K1, _T1, _HF, _EqK, _Al>&,
-                          const hash_map<_K1, _T1, _HF, _EqK, _Al>&);
-#else /* __STL_MEMBER_TEMPLATES */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const hash_map&, const hash_map&);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-
-  iterator begin() { return _M_ht.begin(); }
-  iterator end() { return _M_ht.end(); }
-  const_iterator begin() const { return _M_ht.begin(); }
-  const_iterator end() const { return _M_ht.end(); }
-
-public:
-  pair<iterator,bool> insert(const value_type& __obj)
-    { return _M_ht.insert_unique(__obj); }
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  void insert(_InputIterator __f, _InputIterator __l)
-    { _M_ht.insert_unique(__f,__l); }
-#else
-  void insert(const value_type* __f, const value_type* __l) {
-    _M_ht.insert_unique(__f,__l);
-  }
-  void insert(const_iterator __f, const_iterator __l)
-    { _M_ht.insert_unique(__f, __l); }
-#endif /*__STL_MEMBER_TEMPLATES */
-  pair<iterator,bool> insert_noresize(const value_type& __obj)
-    { return _M_ht.insert_unique_noresize(__obj); }    
-
-  iterator find(const key_type& __key) { return _M_ht.find(__key); }
-  const_iterator find(const key_type& __key) const 
-    { return _M_ht.find(__key); }
-
-  _Tp& operator[](const key_type& __key) {
-    return _M_ht.find_or_insert(value_type(__key, _Tp())).second;
-  }
-
-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }
-  
-  pair<iterator, iterator> equal_range(const key_type& __key)
-    { return _M_ht.equal_range(__key); }
-  pair<const_iterator, const_iterator>
-  equal_range(const key_type& __key) const
-    { return _M_ht.equal_range(__key); }
-
-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }
-  void erase(iterator __it) { _M_ht.erase(__it); }
-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }
-  void clear() { _M_ht.clear(); }
-
-  void resize(size_type __hint) { _M_ht.resize(__hint); }
-  size_type bucket_count() const { return _M_ht.bucket_count(); }
-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }
-  size_type elems_in_bucket(size_type __n) const
-    { return _M_ht.elems_in_bucket(__n); }
-};
-
-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
-inline bool 
-operator==(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
-           const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
-{
-  return __hm1._M_ht == __hm2._M_ht;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
-inline bool 
-operator!=(const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
-           const hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2) {
-  return !(__hm1 == __hm2);
-}
-
-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
-inline void 
-swap(hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
-     hash_map<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
-{
-  __hm1.swap(__hm2);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-// Forward declaration of equality operator; needed for friend declaration.
-
-template <class _Key, class _Tp,
-          class _HashFcn  __STL_DEPENDENT_DEFAULT_TMPL(hash<_Key>),
-          class _EqualKey __STL_DEPENDENT_DEFAULT_TMPL(equal_to<_Key>),
-          class _Alloc =  __STL_DEFAULT_ALLOCATOR(_Tp) >
-class hash_multimap;
-
-template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>
-inline bool 
-operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,
-           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2);
-
-template <class _Key, class _Tp, class _HashFcn, class _EqualKey, 
-          class _Alloc>
-class hash_multimap
-{
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Key, _Assignable);
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Key);
-  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Key, _Key);
-
-private:
-  typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,
-                    _Select1st<pair<const _Key, _Tp> >, _EqualKey, _Alloc> 
-          _Ht;
-  _Ht _M_ht;
-
-public:
-  typedef typename _Ht::key_type key_type;
-  typedef _Tp data_type;
-  typedef _Tp mapped_type;
-  typedef typename _Ht::value_type value_type;
-  typedef typename _Ht::hasher hasher;
-  typedef typename _Ht::key_equal key_equal;
-
-  typedef typename _Ht::size_type size_type;
-  typedef typename _Ht::difference_type difference_type;
-  typedef typename _Ht::pointer pointer;
-  typedef typename _Ht::const_pointer const_pointer;
-  typedef typename _Ht::reference reference;
-  typedef typename _Ht::const_reference const_reference;
-
-  typedef typename _Ht::iterator iterator;
-  typedef typename _Ht::const_iterator const_iterator;
-
-  typedef typename _Ht::allocator_type allocator_type;
-
-  hasher hash_funct() const { return _M_ht.hash_funct(); }
-  key_equal key_eq() const { return _M_ht.key_eq(); }
-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }
-
-public:
-  hash_multimap() : _M_ht(100, hasher(), key_equal(), allocator_type()) {}
-  explicit hash_multimap(size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}
-  hash_multimap(size_type __n, const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}
-  hash_multimap(size_type __n, const hasher& __hf, const key_equal& __eql,
-                const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a) {}
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  hash_multimap(_InputIterator __f, _InputIterator __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  template <class _InputIterator>
-  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  template <class _InputIterator>
-  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,
-                const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  template <class _InputIterator>
-  hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,
-                const hasher& __hf, const key_equal& __eql,
-                const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_equal(__f, __l); }
-
-#else
-  hash_multimap(const value_type* __f, const value_type* __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multimap(const value_type* __f, const value_type* __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multimap(const value_type* __f, const value_type* __l, size_type __n,
-                const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multimap(const value_type* __f, const value_type* __l, size_type __n,
-                const hasher& __hf, const key_equal& __eql,
-                const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_equal(__f, __l); }
-
-  hash_multimap(const_iterator __f, const_iterator __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multimap(const_iterator __f, const_iterator __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multimap(const_iterator __f, const_iterator __l, size_type __n,
-                const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multimap(const_iterator __f, const_iterator __l, size_type __n,
-                const hasher& __hf, const key_equal& __eql,
-                const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_equal(__f, __l); }
-#endif /*__STL_MEMBER_TEMPLATES */
-
-public:
-  size_type size() const { return _M_ht.size(); }
-  size_type max_size() const { return _M_ht.max_size(); }
-  bool empty() const { return _M_ht.empty(); }
-  void swap(hash_multimap& __hs) { _M_ht.swap(__hs._M_ht); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _K1, class _T1, class _HF, class _EqK, class _Al>
-  friend bool operator== (const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&,
-                          const hash_multimap<_K1, _T1, _HF, _EqK, _Al>&);
-#else /* __STL_MEMBER_TEMPLATES */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const hash_multimap&,const hash_multimap&);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  iterator begin() { return _M_ht.begin(); }
-  iterator end() { return _M_ht.end(); }
-  const_iterator begin() const { return _M_ht.begin(); }
-  const_iterator end() const { return _M_ht.end(); }
-
-public:
-  iterator insert(const value_type& __obj) 
-    { return _M_ht.insert_equal(__obj); }
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  void insert(_InputIterator __f, _InputIterator __l) 
-    { _M_ht.insert_equal(__f,__l); }
-#else
-  void insert(const value_type* __f, const value_type* __l) {
-    _M_ht.insert_equal(__f,__l);
-  }
-  void insert(const_iterator __f, const_iterator __l) 
-    { _M_ht.insert_equal(__f, __l); }
-#endif /*__STL_MEMBER_TEMPLATES */
-  iterator insert_noresize(const value_type& __obj)
-    { return _M_ht.insert_equal_noresize(__obj); }    
-
-  iterator find(const key_type& __key) { return _M_ht.find(__key); }
-  const_iterator find(const key_type& __key) const 
-    { return _M_ht.find(__key); }
-
-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }
-  
-  pair<iterator, iterator> equal_range(const key_type& __key)
-    { return _M_ht.equal_range(__key); }
-  pair<const_iterator, const_iterator>
-  equal_range(const key_type& __key) const
-    { return _M_ht.equal_range(__key); }
-
-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }
-  void erase(iterator __it) { _M_ht.erase(__it); }
-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }
-  void clear() { _M_ht.clear(); }
-
-public:
-  void resize(size_type __hint) { _M_ht.resize(__hint); }
-  size_type bucket_count() const { return _M_ht.bucket_count(); }
-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }
-  size_type elems_in_bucket(size_type __n) const
-    { return _M_ht.elems_in_bucket(__n); }
-};
-
-template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>
-inline bool 
-operator==(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,
-           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2)
-{
-  return __hm1._M_ht == __hm2._M_ht;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Key, class _Tp, class _HF, class _EqKey, class _Alloc>
-inline bool 
-operator!=(const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm1,
-           const hash_multimap<_Key,_Tp,_HF,_EqKey,_Alloc>& __hm2) {
-  return !(__hm1 == __hm2);
-}
-
-template <class _Key, class _Tp, class _HashFcn, class _EqlKey, class _Alloc>
-inline void 
-swap(hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm1,
-     hash_multimap<_Key,_Tp,_HashFcn,_EqlKey,_Alloc>& __hm2)
-{
-  __hm1.swap(__hm2);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-// Specialization of insert_iterator so that it will work for hash_map
-// and hash_multimap.
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Key, class _Tp, class _HashFn,  class _EqKey, class _Alloc>
-class insert_iterator<hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc> > {
-protected:
-  typedef hash_map<_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;
-  _Container* container;
-public:
-  typedef _Container          container_type;
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  insert_iterator(_Container& __x) : container(&__x) {}
-  insert_iterator(_Container& __x, typename _Container::iterator)
-    : container(&__x) {}
-  insert_iterator<_Container>&
-  operator=(const typename _Container::value_type& __value) { 
-    container->insert(__value);
-    return *this;
-  }
-  insert_iterator<_Container>& operator*() { return *this; }
-  insert_iterator<_Container>& operator++() { return *this; }
-  insert_iterator<_Container>& operator++(int) { return *this; }
-};
-
-template <class _Key, class _Tp, class _HashFn,  class _EqKey, class _Alloc>
-class insert_iterator<hash_multimap<_Key, _Tp, _HashFn, _EqKey, _Alloc> > {
-protected:
-  typedef hash_multimap<_Key, _Tp, _HashFn, _EqKey, _Alloc> _Container;
-  _Container* container;
-  typename _Container::iterator iter;
-public:
-  typedef _Container          container_type;
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  insert_iterator(_Container& __x) : container(&__x) {}
-  insert_iterator(_Container& __x, typename _Container::iterator)
-    : container(&__x) {}
-  insert_iterator<_Container>&
-  operator=(const typename _Container::value_type& __value) { 
-    container->insert(__value);
-    return *this;
-  }
-  insert_iterator<_Container>& operator*() { return *this; }
-  insert_iterator<_Container>& operator++() { return *this; }
-  insert_iterator<_Container>& operator++(int) { return *this; }
-};
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_HASH_MAP_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_hash_set.h b/lib/include/stl/stl_hash_set.h
deleted file mode 100644
index 4313431..0000000
--- a/lib/include/stl/stl_hash_set.h
+++ /dev/null
@@ -1,514 +0,0 @@
-/*
- * Copyright (c) 1996
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_HASH_SET_H
-#define __SGI_STL_INTERNAL_HASH_SET_H
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-// Forward declaration of equality operator; needed for friend declaration.
-
-template <class _Value,
-          class _HashFcn  __STL_DEPENDENT_DEFAULT_TMPL(hash<_Value>),
-          class _EqualKey __STL_DEPENDENT_DEFAULT_TMPL(equal_to<_Value>),
-          class _Alloc =  __STL_DEFAULT_ALLOCATOR(_Value) >
-class hash_set;
-
-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
-inline bool 
-operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,
-           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2);
-
-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
-class hash_set
-{
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Value, _Assignable);
-  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Value);
-  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Value, _Value);
-
-private:
-  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, 
-                    _EqualKey, _Alloc> _Ht;
-  _Ht _M_ht;
-
-public:
-  typedef typename _Ht::key_type key_type;
-  typedef typename _Ht::value_type value_type;
-  typedef typename _Ht::hasher hasher;
-  typedef typename _Ht::key_equal key_equal;
-
-  typedef typename _Ht::size_type size_type;
-  typedef typename _Ht::difference_type difference_type;
-  typedef typename _Ht::const_pointer pointer;
-  typedef typename _Ht::const_pointer const_pointer;
-  typedef typename _Ht::const_reference reference;
-  typedef typename _Ht::const_reference const_reference;
-
-  typedef typename _Ht::const_iterator iterator;
-  typedef typename _Ht::const_iterator const_iterator;
-
-  typedef typename _Ht::allocator_type allocator_type;
-
-  hasher hash_funct() const { return _M_ht.hash_funct(); }
-  key_equal key_eq() const { return _M_ht.key_eq(); }
-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }
-
-public:
-  hash_set()
-    : _M_ht(100, hasher(), key_equal(), allocator_type()) {}
-  explicit hash_set(size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}
-  hash_set(size_type __n, const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}
-  hash_set(size_type __n, const hasher& __hf, const key_equal& __eql,
-           const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a) {}
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  hash_set(_InputIterator __f, _InputIterator __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  template <class _InputIterator>
-  hash_set(_InputIterator __f, _InputIterator __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  template <class _InputIterator>
-  hash_set(_InputIterator __f, _InputIterator __l, size_type __n,
-           const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  template <class _InputIterator>
-  hash_set(_InputIterator __f, _InputIterator __l, size_type __n,
-           const hasher& __hf, const key_equal& __eql,
-           const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_unique(__f, __l); }
-#else
-
-  hash_set(const value_type* __f, const value_type* __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_set(const value_type* __f, const value_type* __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_set(const value_type* __f, const value_type* __l, size_type __n,
-           const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_set(const value_type* __f, const value_type* __l, size_type __n,
-           const hasher& __hf, const key_equal& __eql,
-           const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_unique(__f, __l); }
-
-  hash_set(const_iterator __f, const_iterator __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_set(const_iterator __f, const_iterator __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_set(const_iterator __f, const_iterator __l, size_type __n,
-           const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_unique(__f, __l); }
-  hash_set(const_iterator __f, const_iterator __l, size_type __n,
-           const hasher& __hf, const key_equal& __eql,
-           const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_unique(__f, __l); }
-#endif /*__STL_MEMBER_TEMPLATES */
-
-public:
-  size_type size() const { return _M_ht.size(); }
-  size_type max_size() const { return _M_ht.max_size(); }
-  bool empty() const { return _M_ht.empty(); }
-  void swap(hash_set& __hs) { _M_ht.swap(__hs._M_ht); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _Val, class _HF, class _EqK, class _Al>  
-  friend bool operator== (const hash_set<_Val, _HF, _EqK, _Al>&,
-                          const hash_set<_Val, _HF, _EqK, _Al>&);
-#else /* __STL_MEMBER_TEMPLATES */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const hash_set&, const hash_set&);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  iterator begin() const { return _M_ht.begin(); }
-  iterator end() const { return _M_ht.end(); }
-
-public:
-  pair<iterator, bool> insert(const value_type& __obj)
-    {
-      pair<typename _Ht::iterator, bool> __p = _M_ht.insert_unique(__obj);
-      return pair<iterator,bool>(__p.first, __p.second);
-    }
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  void insert(_InputIterator __f, _InputIterator __l) 
-    { _M_ht.insert_unique(__f,__l); }
-#else
-  void insert(const value_type* __f, const value_type* __l) {
-    _M_ht.insert_unique(__f,__l);
-  }
-  void insert(const_iterator __f, const_iterator __l) 
-    {_M_ht.insert_unique(__f, __l); }
-#endif /*__STL_MEMBER_TEMPLATES */
-  pair<iterator, bool> insert_noresize(const value_type& __obj)
-  {
-    pair<typename _Ht::iterator, bool> __p = 
-      _M_ht.insert_unique_noresize(__obj);
-    return pair<iterator, bool>(__p.first, __p.second);
-  }
-
-  iterator find(const key_type& __key) const { return _M_ht.find(__key); }
-
-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }
-  
-  pair<iterator, iterator> equal_range(const key_type& __key) const
-    { return _M_ht.equal_range(__key); }
-
-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }
-  void erase(iterator __it) { _M_ht.erase(__it); }
-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }
-  void clear() { _M_ht.clear(); }
-
-public:
-  void resize(size_type __hint) { _M_ht.resize(__hint); }
-  size_type bucket_count() const { return _M_ht.bucket_count(); }
-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }
-  size_type elems_in_bucket(size_type __n) const
-    { return _M_ht.elems_in_bucket(__n); }
-};
-
-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
-inline bool 
-operator==(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,
-           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2)
-{
-  return __hs1._M_ht == __hs2._M_ht;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
-inline bool 
-operator!=(const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs1,
-           const hash_set<_Value,_HashFcn,_EqualKey,_Alloc>& __hs2) {
-  return !(__hs1 == __hs2);
-}
-
-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>
-inline void 
-swap(hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,
-     hash_set<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)
-{
-  __hs1.swap(__hs2);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-
-template <class _Value,
-          class _HashFcn  __STL_DEPENDENT_DEFAULT_TMPL(hash<_Value>),
-          class _EqualKey __STL_DEPENDENT_DEFAULT_TMPL(equal_to<_Value>),
-          class _Alloc =  __STL_DEFAULT_ALLOCATOR(_Value) >
-class hash_multiset;
-
-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>
-inline bool 
-operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,
-           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2);
-
-
-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
-class hash_multiset
-{
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Value, _Assignable);
-  __STL_CLASS_UNARY_FUNCTION_CHECK(_HashFcn, size_t, _Value);
-  __STL_CLASS_BINARY_FUNCTION_CHECK(_EqualKey, bool, _Value, _Value);
-
-private:
-  typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, 
-                    _EqualKey, _Alloc> _Ht;
-  _Ht _M_ht;
-
-public:
-  typedef typename _Ht::key_type key_type;
-  typedef typename _Ht::value_type value_type;
-  typedef typename _Ht::hasher hasher;
-  typedef typename _Ht::key_equal key_equal;
-
-  typedef typename _Ht::size_type size_type;
-  typedef typename _Ht::difference_type difference_type;
-  typedef typename _Ht::const_pointer pointer;
-  typedef typename _Ht::const_pointer const_pointer;
-  typedef typename _Ht::const_reference reference;
-  typedef typename _Ht::const_reference const_reference;
-
-  typedef typename _Ht::const_iterator iterator;
-  typedef typename _Ht::const_iterator const_iterator;
-
-  typedef typename _Ht::allocator_type allocator_type;
-
-  hasher hash_funct() const { return _M_ht.hash_funct(); }
-  key_equal key_eq() const { return _M_ht.key_eq(); }
-  allocator_type get_allocator() const { return _M_ht.get_allocator(); }
-
-public:
-  hash_multiset()
-    : _M_ht(100, hasher(), key_equal(), allocator_type()) {}
-  explicit hash_multiset(size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type()) {}
-  hash_multiset(size_type __n, const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type()) {}
-  hash_multiset(size_type __n, const hasher& __hf, const key_equal& __eql,
-                const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a) {}
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  hash_multiset(_InputIterator __f, _InputIterator __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  template <class _InputIterator>
-  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  template <class _InputIterator>
-  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,
-                const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  template <class _InputIterator>
-  hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,
-                const hasher& __hf, const key_equal& __eql,
-                const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_equal(__f, __l); }
-#else
-
-  hash_multiset(const value_type* __f, const value_type* __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multiset(const value_type* __f, const value_type* __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multiset(const value_type* __f, const value_type* __l, size_type __n,
-                const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multiset(const value_type* __f, const value_type* __l, size_type __n,
-                const hasher& __hf, const key_equal& __eql,
-                const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_equal(__f, __l); }
-
-  hash_multiset(const_iterator __f, const_iterator __l)
-    : _M_ht(100, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multiset(const_iterator __f, const_iterator __l, size_type __n)
-    : _M_ht(__n, hasher(), key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multiset(const_iterator __f, const_iterator __l, size_type __n,
-                const hasher& __hf)
-    : _M_ht(__n, __hf, key_equal(), allocator_type())
-    { _M_ht.insert_equal(__f, __l); }
-  hash_multiset(const_iterator __f, const_iterator __l, size_type __n,
-                const hasher& __hf, const key_equal& __eql,
-                const allocator_type& __a = allocator_type())
-    : _M_ht(__n, __hf, __eql, __a)
-    { _M_ht.insert_equal(__f, __l); }
-#endif /*__STL_MEMBER_TEMPLATES */
-
-public:
-  size_type size() const { return _M_ht.size(); }
-  size_type max_size() const { return _M_ht.max_size(); }
-  bool empty() const { return _M_ht.empty(); }
-  void swap(hash_multiset& hs) { _M_ht.swap(hs._M_ht); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _Val, class _HF, class _EqK, class _Al>  
-  friend bool operator== (const hash_multiset<_Val, _HF, _EqK, _Al>&,
-                          const hash_multiset<_Val, _HF, _EqK, _Al>&);
-#else /* __STL_MEMBER_TEMPLATES */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const hash_multiset&,const hash_multiset&);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  iterator begin() const { return _M_ht.begin(); }
-  iterator end() const { return _M_ht.end(); }
-
-public:
-  iterator insert(const value_type& __obj)
-    { return _M_ht.insert_equal(__obj); }
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  void insert(_InputIterator __f, _InputIterator __l) 
-    { _M_ht.insert_equal(__f,__l); }
-#else
-  void insert(const value_type* __f, const value_type* __l) {
-    _M_ht.insert_equal(__f,__l);
-  }
-  void insert(const_iterator __f, const_iterator __l) 
-    { _M_ht.insert_equal(__f, __l); }
-#endif /*__STL_MEMBER_TEMPLATES */
-  iterator insert_noresize(const value_type& __obj)
-    { return _M_ht.insert_equal_noresize(__obj); }    
-
-  iterator find(const key_type& __key) const { return _M_ht.find(__key); }
-
-  size_type count(const key_type& __key) const { return _M_ht.count(__key); }
-  
-  pair<iterator, iterator> equal_range(const key_type& __key) const
-    { return _M_ht.equal_range(__key); }
-
-  size_type erase(const key_type& __key) {return _M_ht.erase(__key); }
-  void erase(iterator __it) { _M_ht.erase(__it); }
-  void erase(iterator __f, iterator __l) { _M_ht.erase(__f, __l); }
-  void clear() { _M_ht.clear(); }
-
-public:
-  void resize(size_type __hint) { _M_ht.resize(__hint); }
-  size_type bucket_count() const { return _M_ht.bucket_count(); }
-  size_type max_bucket_count() const { return _M_ht.max_bucket_count(); }
-  size_type elems_in_bucket(size_type __n) const
-    { return _M_ht.elems_in_bucket(__n); }
-};
-
-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>
-inline bool 
-operator==(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,
-           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2)
-{
-  return __hs1._M_ht == __hs2._M_ht;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>
-inline bool 
-operator!=(const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,
-           const hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2) {
-  return !(__hs1 == __hs2);
-}
-
-template <class _Val, class _HashFcn, class _EqualKey, class _Alloc>
-inline void 
-swap(hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs1,
-     hash_multiset<_Val,_HashFcn,_EqualKey,_Alloc>& __hs2) {
-  __hs1.swap(__hs2);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-// Specialization of insert_iterator so that it will work for hash_set
-// and hash_multiset.
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
-class insert_iterator<hash_set<_Value, _HashFcn, _EqualKey, _Alloc> > {
-protected:
-  typedef hash_set<_Value, _HashFcn, _EqualKey, _Alloc> _Container;
-  _Container* container;
-public:
-  typedef _Container          container_type;
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  insert_iterator(_Container& __x) : container(&__x) {}
-  insert_iterator(_Container& __x, typename _Container::iterator)
-    : container(&__x) {}
-  insert_iterator<_Container>&
-  operator=(const typename _Container::value_type& __value) { 
-    container->insert(__value);
-    return *this;
-  }
-  insert_iterator<_Container>& operator*() { return *this; }
-  insert_iterator<_Container>& operator++() { return *this; }
-  insert_iterator<_Container>& operator++(int) { return *this; }
-};
-
-template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>
-class insert_iterator<hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc> > {
-protected:
-  typedef hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc> _Container;
-  _Container* container;
-  typename _Container::iterator iter;
-public:
-  typedef _Container          container_type;
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  insert_iterator(_Container& __x) : container(&__x) {}
-  insert_iterator(_Container& __x, typename _Container::iterator)
-    : container(&__x) {}
-  insert_iterator<_Container>&
-  operator=(const typename _Container::value_type& __value) { 
-    container->insert(__value);
-    return *this;
-  }
-  insert_iterator<_Container>& operator*() { return *this; }
-  insert_iterator<_Container>& operator++() { return *this; }
-  insert_iterator<_Container>& operator++(int) { return *this; }
-};
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_HASH_SET_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_hashtable.h b/lib/include/stl/stl_hashtable.h
deleted file mode 100644
index 7904f52..0000000
--- a/lib/include/stl/stl_hashtable.h
+++ /dev/null
@@ -1,1080 +0,0 @@
-/*
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_HASHTABLE_H
-#define __SGI_STL_INTERNAL_HASHTABLE_H
-
-// Hashtable class, used to implement the hashed associative containers
-// hash_set, hash_map, hash_multiset, and hash_multimap.
-
-#include <stl_algobase.h>
-#include <stl_alloc.h>
-#include <stl_construct.h>
-#include <stl_tempbuf.h>
-#include <stl_algo.h>
-#include <stl_uninitialized.h>
-#include <stl_function.h>
-#include <stl_vector.h>
-#include <stl_hash_fun.h>
-
-__STL_BEGIN_NAMESPACE
-
-template <class _Val>
-struct _Hashtable_node
-{
-  _Hashtable_node* _M_next;
-  _Val _M_val;
-};  
-
-template <class _Val, class _Key, class _HashFcn,
-          class _ExtractKey, class _EqualKey, class _Alloc = alloc>
-class hashtable;
-
-template <class _Val, class _Key, class _HashFcn,
-          class _ExtractKey, class _EqualKey, class _Alloc>
-struct _Hashtable_iterator;
-
-template <class _Val, class _Key, class _HashFcn,
-          class _ExtractKey, class _EqualKey, class _Alloc>
-struct _Hashtable_const_iterator;
-
-template <class _Val, class _Key, class _HashFcn,
-          class _ExtractKey, class _EqualKey, class _Alloc>
-struct _Hashtable_iterator {
-  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>
-          _Hashtable;
-  typedef _Hashtable_iterator<_Val, _Key, _HashFcn, 
-                              _ExtractKey, _EqualKey, _Alloc>
-          iterator;
-  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, 
-                                    _ExtractKey, _EqualKey, _Alloc>
-          const_iterator;
-  typedef _Hashtable_node<_Val> _Node;
-
-  typedef forward_iterator_tag iterator_category;
-  typedef _Val value_type;
-  typedef ptrdiff_t difference_type;
-  typedef size_t size_type;
-  typedef _Val& reference;
-  typedef _Val* pointer;
-
-  _Node* _M_cur;
-  _Hashtable* _M_ht;
-
-  _Hashtable_iterator(_Node* __n, _Hashtable* __tab) 
-    : _M_cur(__n), _M_ht(__tab) {}
-  _Hashtable_iterator() {}
-  reference operator*() const { return _M_cur->_M_val; }
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return &(operator*()); }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-  iterator& operator++();
-  iterator operator++(int);
-  bool operator==(const iterator& __it) const
-    { return _M_cur == __it._M_cur; }
-  bool operator!=(const iterator& __it) const
-    { return _M_cur != __it._M_cur; }
-};
-
-
-template <class _Val, class _Key, class _HashFcn,
-          class _ExtractKey, class _EqualKey, class _Alloc>
-struct _Hashtable_const_iterator {
-  typedef hashtable<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>
-          _Hashtable;
-  typedef _Hashtable_iterator<_Val,_Key,_HashFcn, 
-                              _ExtractKey,_EqualKey,_Alloc>
-          iterator;
-  typedef _Hashtable_const_iterator<_Val, _Key, _HashFcn, 
-                                    _ExtractKey, _EqualKey, _Alloc>
-          const_iterator;
-  typedef _Hashtable_node<_Val> _Node;
-
-  typedef forward_iterator_tag iterator_category;
-  typedef _Val value_type;
-  typedef ptrdiff_t difference_type;
-  typedef size_t size_type;
-  typedef const _Val& reference;
-  typedef const _Val* pointer;
-
-  const _Node* _M_cur;
-  const _Hashtable* _M_ht;
-
-  _Hashtable_const_iterator(const _Node* __n, const _Hashtable* __tab)
-    : _M_cur(__n), _M_ht(__tab) {}
-  _Hashtable_const_iterator() {}
-  _Hashtable_const_iterator(const iterator& __it) 
-    : _M_cur(__it._M_cur), _M_ht(__it._M_ht) {}
-  reference operator*() const { return _M_cur->_M_val; }
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return &(operator*()); }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-  const_iterator& operator++();
-  const_iterator operator++(int);
-  bool operator==(const const_iterator& __it) const 
-    { return _M_cur == __it._M_cur; }
-  bool operator!=(const const_iterator& __it) const 
-    { return _M_cur != __it._M_cur; }
-};
-
-#ifdef STM32PLUS_BUILD
-
-enum { __stl_num_primes = 30 };
-
-// downsize the prime set to be more appropriate for a
-// device with low RAM and store this table in flash
-
-static const unsigned char __stl_prime_list[__stl_num_primes] =
-{
-  3,     5,   7,  11,  13,  17,  19,  23,  29,  31,
-  37,   41,  43,  47,  53,  59,  61,  67,  71,  73,
-  79,   83,  89,  97, 101, 103, 107, 109, 113, 127
-};
-
-inline unsigned long __stl_next_prime(unsigned long __n)
-{
-  const unsigned char * __first = __stl_prime_list;
-  const unsigned char * __last = __stl_prime_list + (int)__stl_num_primes;
-  const unsigned char * pos = lower_bound(__first, __last, (unsigned char)__n);
-
-  return pos == __last ? *(__last - 1) : *pos;
-}
-
-#else
-
-// Note: assumes long is at least 32 bits.
-enum { __stl_num_primes = 28 };
-
-static const unsigned long __stl_prime_list[__stl_num_primes] =
-{
-  53ul,         97ul,         193ul,       389ul,       769ul,
-  1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
-  49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
-  1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
-  50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul, 
-  1610612741ul, 3221225473ul, 4294967291ul
-};
-
-inline unsigned long __stl_next_prime(unsigned long __n)
-{
-  const unsigned long* __first = __stl_prime_list;
-  const unsigned long* __last = __stl_prime_list + (int)__stl_num_primes;
-  const unsigned long* pos = lower_bound(__first, __last, __n);
-  return pos == __last ? *(__last - 1) : *pos;
-}
-#endif
-
-// Forward declaration of operator==.
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-class hashtable;
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,
-                const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2);
-
-
-// Hashtables handle allocators a bit differently than other containers
-//  do.  If we're using standard-conforming allocators, then a hashtable
-//  unconditionally has a member variable to hold its allocator, even if
-//  it so happens that all instances of the allocator type are identical.
-// This is because, for hashtables, this extra storage is negligible.  
-//  Additionally, a base class wouldn't serve any other purposes; it 
-//  wouldn't, for example, simplify the exception-handling code.
-
-template <class _Val, class _Key, class _HashFcn,
-          class _ExtractKey, class _EqualKey, class _Alloc>
-class hashtable {
-public:
-  typedef _Key key_type;
-  typedef _Val value_type;
-  typedef _HashFcn hasher;
-  typedef _EqualKey key_equal;
-
-  typedef size_t            size_type;
-  typedef ptrdiff_t         difference_type;
-  typedef value_type*       pointer;
-  typedef const value_type* const_pointer;
-  typedef value_type&       reference;
-  typedef const value_type& const_reference;
-
-  hasher hash_funct() const { return _M_hash; }
-  key_equal key_eq() const { return _M_equals; }
-
-private:
-  typedef _Hashtable_node<_Val> _Node;
-
-#ifdef __STL_USE_STD_ALLOCATORS
-public:
-  typedef typename _Alloc_traits<_Val,_Alloc>::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _M_node_allocator; }
-private:
-  typename _Alloc_traits<_Node, _Alloc>::allocator_type _M_node_allocator;
-  _Node* _M_get_node() { return _M_node_allocator.allocate(1); }
-  void _M_put_node(_Node* __p) { _M_node_allocator.deallocate(__p, 1); }
-# define __HASH_ALLOC_INIT(__a) _M_node_allocator(__a), 
-#else /* __STL_USE_STD_ALLOCATORS */
-public:
-  typedef _Alloc allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-private:
-  typedef simple_alloc<_Node, _Alloc> _M_node_allocator_type;
-  _Node* _M_get_node() { return _M_node_allocator_type::allocate(1); }
-  void _M_put_node(_Node* __p) { _M_node_allocator_type::deallocate(__p, 1); }
-# define __HASH_ALLOC_INIT(__a)
-#endif /* __STL_USE_STD_ALLOCATORS */
-
-private:
-  hasher                _M_hash;
-  key_equal             _M_equals;
-  _ExtractKey           _M_get_key;
-  vector<_Node*,_Alloc> _M_buckets;
-  size_type             _M_num_elements;
-
-public:
-  typedef _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>
-          iterator;
-  typedef _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,
-                                    _Alloc>
-          const_iterator;
-
-  friend struct
-  _Hashtable_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;
-  friend struct
-  _Hashtable_const_iterator<_Val,_Key,_HashFcn,_ExtractKey,_EqualKey,_Alloc>;
-
-public:
-  hashtable(size_type __n,
-            const _HashFcn&    __hf,
-            const _EqualKey&   __eql,
-            const _ExtractKey& __ext,
-            const allocator_type& __a = allocator_type())
-    : __HASH_ALLOC_INIT(__a)
-      _M_hash(__hf),
-      _M_equals(__eql),
-      _M_get_key(__ext),
-      _M_buckets(__a),
-      _M_num_elements(0)
-  {
-    _M_initialize_buckets(__n);
-  }
-
-  hashtable(size_type __n,
-            const _HashFcn&    __hf,
-            const _EqualKey&   __eql,
-            const allocator_type& __a = allocator_type())
-    : __HASH_ALLOC_INIT(__a)
-      _M_hash(__hf),
-      _M_equals(__eql),
-      _M_get_key(_ExtractKey()),
-      _M_buckets(__a),
-      _M_num_elements(0)
-  {
-    _M_initialize_buckets(__n);
-  }
-
-  hashtable(const hashtable& __ht)
-    : __HASH_ALLOC_INIT(__ht.get_allocator())
-      _M_hash(__ht._M_hash),
-      _M_equals(__ht._M_equals),
-      _M_get_key(__ht._M_get_key),
-      _M_buckets(__ht.get_allocator()),
-      _M_num_elements(0)
-  {
-    _M_copy_from(__ht);
-  }
-
-#undef __HASH_ALLOC_INIT
-
-  hashtable& operator= (const hashtable& __ht)
-  {
-    if (&__ht != this) {
-      clear();
-      _M_hash = __ht._M_hash;
-      _M_equals = __ht._M_equals;
-      _M_get_key = __ht._M_get_key;
-      _M_copy_from(__ht);
-    }
-    return *this;
-  }
-
-  ~hashtable() { clear(); }
-
-  size_type size() const { return _M_num_elements; }
-  size_type max_size() const { return size_type(-1); }
-  bool empty() const { return size() == 0; }
-
-  void swap(hashtable& __ht)
-  {
-    __STD::swap(_M_hash, __ht._M_hash);
-    __STD::swap(_M_equals, __ht._M_equals);
-    __STD::swap(_M_get_key, __ht._M_get_key);
-    _M_buckets.swap(__ht._M_buckets);
-    __STD::swap(_M_num_elements, __ht._M_num_elements);
-  }
-
-  iterator begin()
-  { 
-    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)
-      if (_M_buckets[__n])
-        return iterator(_M_buckets[__n], this);
-    return end();
-  }
-
-  iterator end() { return iterator(0, this); }
-
-  const_iterator begin() const
-  {
-    for (size_type __n = 0; __n < _M_buckets.size(); ++__n)
-      if (_M_buckets[__n])
-        return const_iterator(_M_buckets[__n], this);
-    return end();
-  }
-
-  const_iterator end() const { return const_iterator(0, this); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _Vl, class _Ky, class _HF, class _Ex, class _Eq, class _Al>
-  friend bool operator== (const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&,
-                          const hashtable<_Vl, _Ky, _HF, _Ex, _Eq, _Al>&);
-#else /* __STL_MEMBER_TEMPLATES */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const hashtable&, const hashtable&);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:
-
-  size_type bucket_count() const { return _M_buckets.size(); }
-
-  size_type max_bucket_count() const
-    { return __stl_prime_list[(int)__stl_num_primes - 1]; } 
-
-  size_type elems_in_bucket(size_type __bucket) const
-  {
-    size_type __result = 0;
-    for (_Node* __cur = _M_buckets[__bucket]; __cur; __cur = __cur->_M_next)
-      __result += 1;
-    return __result;
-  }
-
-  pair<iterator, bool> insert_unique(const value_type& __obj)
-  {
-    resize(_M_num_elements + 1);
-    return insert_unique_noresize(__obj);
-  }
-
-  iterator insert_equal(const value_type& __obj)
-  {
-    resize(_M_num_elements + 1);
-    return insert_equal_noresize(__obj);
-  }
-
-  pair<iterator, bool> insert_unique_noresize(const value_type& __obj);
-  iterator insert_equal_noresize(const value_type& __obj);
- 
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  void insert_unique(_InputIterator __f, _InputIterator __l)
-  {
-    insert_unique(__f, __l, __ITERATOR_CATEGORY(__f));
-  }
-
-  template <class _InputIterator>
-  void insert_equal(_InputIterator __f, _InputIterator __l)
-  {
-    insert_equal(__f, __l, __ITERATOR_CATEGORY(__f));
-  }
-
-  template <class _InputIterator>
-  void insert_unique(_InputIterator __f, _InputIterator __l,
-                     input_iterator_tag)
-  {
-    for ( ; __f != __l; ++__f)
-      insert_unique(*__f);
-  }
-
-  template <class _InputIterator>
-  void insert_equal(_InputIterator __f, _InputIterator __l,
-                    input_iterator_tag)
-  {
-    for ( ; __f != __l; ++__f)
-      insert_equal(*__f);
-  }
-
-  template <class _ForwardIterator>
-  void insert_unique(_ForwardIterator __f, _ForwardIterator __l,
-                     forward_iterator_tag)
-  {
-    size_type __n = 0;
-    distance(__f, __l, __n);
-    resize(_M_num_elements + __n);
-    for ( ; __n > 0; --__n, ++__f)
-      insert_unique_noresize(*__f);
-  }
-
-  template <class _ForwardIterator>
-  void insert_equal(_ForwardIterator __f, _ForwardIterator __l,
-                    forward_iterator_tag)
-  {
-    size_type __n = 0;
-    distance(__f, __l, __n);
-    resize(_M_num_elements + __n);
-    for ( ; __n > 0; --__n, ++__f)
-      insert_equal_noresize(*__f);
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-  void insert_unique(const value_type* __f, const value_type* __l)
-  {
-    size_type __n = __l - __f;
-    resize(_M_num_elements + __n);
-    for ( ; __n > 0; --__n, ++__f)
-      insert_unique_noresize(*__f);
-  }
-
-  void insert_equal(const value_type* __f, const value_type* __l)
-  {
-    size_type __n = __l - __f;
-    resize(_M_num_elements + __n);
-    for ( ; __n > 0; --__n, ++__f)
-      insert_equal_noresize(*__f);
-  }
-
-  void insert_unique(const_iterator __f, const_iterator __l)
-  {
-    size_type __n = 0;
-    distance(__f, __l, __n);
-    resize(_M_num_elements + __n);
-    for ( ; __n > 0; --__n, ++__f)
-      insert_unique_noresize(*__f);
-  }
-
-  void insert_equal(const_iterator __f, const_iterator __l)
-  {
-    size_type __n = 0;
-    distance(__f, __l, __n);
-    resize(_M_num_elements + __n);
-    for ( ; __n > 0; --__n, ++__f)
-      insert_equal_noresize(*__f);
-  }
-#endif /*__STL_MEMBER_TEMPLATES */
-
-  reference find_or_insert(const value_type& __obj);
-
-  iterator find(const key_type& __key) 
-  {
-    size_type __n = _M_bkt_num_key(__key);
-    _Node* __first;
-    for ( __first = _M_buckets[__n];
-          __first && !_M_equals(_M_get_key(__first->_M_val), __key);
-          __first = __first->_M_next)
-      {}
-    return iterator(__first, this);
-  } 
-
-  const_iterator find(const key_type& __key) const
-  {
-    size_type __n = _M_bkt_num_key(__key);
-    const _Node* __first;
-    for ( __first = _M_buckets[__n];
-          __first && !_M_equals(_M_get_key(__first->_M_val), __key);
-          __first = __first->_M_next)
-      {}
-    return const_iterator(__first, this);
-  } 
-
-  size_type count(const key_type& __key) const
-  {
-    const size_type __n = _M_bkt_num_key(__key);
-    size_type __result = 0;
-
-    for (const _Node* __cur = _M_buckets[__n]; __cur; __cur = __cur->_M_next)
-      if (_M_equals(_M_get_key(__cur->_M_val), __key))
-        ++__result;
-    return __result;
-  }
-
-  pair<iterator, iterator> 
-  equal_range(const key_type& __key);
-
-  pair<const_iterator, const_iterator> 
-  equal_range(const key_type& __key) const;
-
-  size_type erase(const key_type& __key);
-  void erase(const iterator& __it);
-  void erase(iterator __first, iterator __last);
-
-  void erase(const const_iterator& __it);
-  void erase(const_iterator __first, const_iterator __last);
-
-  void resize(size_type __num_elements_hint);
-  void clear();
-
-private:
-  size_type _M_next_size(size_type __n) const
-    { return __stl_next_prime(__n); }
-
-  void _M_initialize_buckets(size_type __n)
-  {
-    const size_type __n_buckets = _M_next_size(__n);
-    _M_buckets.reserve(__n_buckets);
-    _M_buckets.insert(_M_buckets.end(), __n_buckets, (_Node*) 0);
-    _M_num_elements = 0;
-  }
-
-  size_type _M_bkt_num_key(const key_type& __key) const
-  {
-    return _M_bkt_num_key(__key, _M_buckets.size());
-  }
-
-  size_type _M_bkt_num(const value_type& __obj) const
-  {
-    return _M_bkt_num_key(_M_get_key(__obj));
-  }
-
-  size_type _M_bkt_num_key(const key_type& __key, size_t __n) const
-  {
-    return _M_hash(__key) % __n;
-  }
-
-  size_type _M_bkt_num(const value_type& __obj, size_t __n) const
-  {
-    return _M_bkt_num_key(_M_get_key(__obj), __n);
-  }
-
-  _Node* _M_new_node(const value_type& __obj)
-  {
-    _Node* __n = _M_get_node();
-    __n->_M_next = 0;
-    __STL_TRY {
-      construct(&__n->_M_val, __obj);
-      return __n;
-    }
-    __STL_UNWIND(_M_put_node(__n));
-  }
-  
-  void _M_delete_node(_Node* __n)
-  {
-    destroy(&__n->_M_val);
-    _M_put_node(__n);
-  }
-
-  void _M_erase_bucket(const size_type __n, _Node* __first, _Node* __last);
-  void _M_erase_bucket(const size_type __n, _Node* __last);
-
-  void _M_copy_from(const hashtable& __ht);
-
-};
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&
-_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()
-{
-  const _Node* __old = _M_cur;
-  _M_cur = _M_cur->_M_next;
-  if (!_M_cur) {
-    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);
-    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())
-      _M_cur = _M_ht->_M_buckets[__bucket];
-  }
-  return *this;
-}
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-inline _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>
-_Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)
-{
-  iterator __tmp = *this;
-  ++*this;
-  return __tmp;
-}
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&
-_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++()
-{
-  const _Node* __old = _M_cur;
-  _M_cur = _M_cur->_M_next;
-  if (!_M_cur) {
-    size_type __bucket = _M_ht->_M_bkt_num(__old->_M_val);
-    while (!_M_cur && ++__bucket < _M_ht->_M_buckets.size())
-      _M_cur = _M_ht->_M_buckets[__bucket];
-  }
-  return *this;
-}
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-inline _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>
-_Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>::operator++(int)
-{
-  const_iterator __tmp = *this;
-  ++*this;
-  return __tmp;
-}
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-inline forward_iterator_tag
-iterator_category(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)
-{
-  return forward_iterator_tag();
-}
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-inline _Val* 
-value_type(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)
-{
-  return (_Val*) 0;
-}
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-inline hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*
-distance_type(const _Hashtable_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)
-{
-  return (hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*) 0;
-}
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-inline forward_iterator_tag
-iterator_category(const _Hashtable_const_iterator<_Val,_Key,_HF,
-                                                  _ExK,_EqK,_All>&)
-{
-  return forward_iterator_tag();
-}
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-inline _Val* 
-value_type(const _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)
-{
-  return (_Val*) 0;
-}
-
-template <class _Val, class _Key, class _HF, class _ExK, class _EqK, 
-          class _All>
-inline hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*
-distance_type(const _Hashtable_const_iterator<_Val,_Key,_HF,_ExK,_EqK,_All>&)
-{
-  return (hashtable<_Val,_Key,_HF,_ExK,_EqK,_All>::difference_type*) 0;
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-bool operator==(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,
-                const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2)
-{
-  typedef typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::_Node _Node;
-  if (__ht1._M_buckets.size() != __ht2._M_buckets.size())
-    return false;
-  for (int __n = 0; __n < __ht1._M_buckets.size(); ++__n) {
-    _Node* __cur1 = __ht1._M_buckets[__n];
-    _Node* __cur2 = __ht2._M_buckets[__n];
-    for ( ; __cur1 && __cur2 && __cur1->_M_val == __cur2->_M_val;
-          __cur1 = __cur1->_M_next, __cur2 = __cur2->_M_next)
-      {}
-    if (__cur1 || __cur2)
-      return false;
-  }
-  return true;
-}  
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-inline bool operator!=(const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht1,
-                       const hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>& __ht2) {
-  return !(__ht1 == __ht2);
-}
-
-template <class _Val, class _Key, class _HF, class _Extract, class _EqKey, 
-          class _All>
-inline void swap(hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht1,
-                 hashtable<_Val, _Key, _HF, _Extract, _EqKey, _All>& __ht2) {
-  __ht1.swap(__ht2);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator, bool> 
-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
-  ::insert_unique_noresize(const value_type& __obj)
-{
-  const size_type __n = _M_bkt_num(__obj);
-  _Node* __first = _M_buckets[__n];
-
-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) 
-    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))
-      return pair<iterator, bool>(iterator(__cur, this), false);
-
-  _Node* __tmp = _M_new_node(__obj);
-  __tmp->_M_next = __first;
-  _M_buckets[__n] = __tmp;
-  ++_M_num_elements;
-  return pair<iterator, bool>(iterator(__tmp, this), true);
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator 
-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
-  ::insert_equal_noresize(const value_type& __obj)
-{
-  const size_type __n = _M_bkt_num(__obj);
-  _Node* __first = _M_buckets[__n];
-
-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next) 
-    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj))) {
-      _Node* __tmp = _M_new_node(__obj);
-      __tmp->_M_next = __cur->_M_next;
-      __cur->_M_next = __tmp;
-      ++_M_num_elements;
-      return iterator(__tmp, this);
-    }
-
-  _Node* __tmp = _M_new_node(__obj);
-  __tmp->_M_next = __first;
-  _M_buckets[__n] = __tmp;
-  ++_M_num_elements;
-  return iterator(__tmp, this);
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::reference 
-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::find_or_insert(const value_type& __obj)
-{
-  resize(_M_num_elements + 1);
-
-  size_type __n = _M_bkt_num(__obj);
-  _Node* __first = _M_buckets[__n];
-
-  for (_Node* __cur = __first; __cur; __cur = __cur->_M_next)
-    if (_M_equals(_M_get_key(__cur->_M_val), _M_get_key(__obj)))
-      return __cur->_M_val;
-
-  _Node* __tmp = _M_new_node(__obj);
-  __tmp->_M_next = __first;
-  _M_buckets[__n] = __tmp;
-  ++_M_num_elements;
-  return __tmp->_M_val;
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator,
-     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::iterator> 
-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::equal_range(const key_type& __key)
-{
-  typedef pair<iterator, iterator> _Pii;
-  const size_type __n = _M_bkt_num_key(__key);
-
-  for (_Node* __first = _M_buckets[__n]; __first; __first = __first->_M_next)
-    if (_M_equals(_M_get_key(__first->_M_val), __key)) {
-      for (_Node* __cur = __first->_M_next; __cur; __cur = __cur->_M_next)
-        if (!_M_equals(_M_get_key(__cur->_M_val), __key))
-          return _Pii(iterator(__first, this), iterator(__cur, this));
-      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)
-        if (_M_buckets[__m])
-          return _Pii(iterator(__first, this),
-                     iterator(_M_buckets[__m], this));
-      return _Pii(iterator(__first, this), end());
-    }
-  return _Pii(end(), end());
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-pair<typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator, 
-     typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::const_iterator> 
-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
-  ::equal_range(const key_type& __key) const
-{
-  typedef pair<const_iterator, const_iterator> _Pii;
-  const size_type __n = _M_bkt_num_key(__key);
-
-  for (const _Node* __first = _M_buckets[__n] ;
-       __first; 
-       __first = __first->_M_next) {
-    if (_M_equals(_M_get_key(__first->_M_val), __key)) {
-      for (const _Node* __cur = __first->_M_next;
-           __cur;
-           __cur = __cur->_M_next)
-        if (!_M_equals(_M_get_key(__cur->_M_val), __key))
-          return _Pii(const_iterator(__first, this),
-                      const_iterator(__cur, this));
-      for (size_type __m = __n + 1; __m < _M_buckets.size(); ++__m)
-        if (_M_buckets[__m])
-          return _Pii(const_iterator(__first, this),
-                      const_iterator(_M_buckets[__m], this));
-      return _Pii(const_iterator(__first, this), end());
-    }
-  }
-  return _Pii(end(), end());
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-typename hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::size_type 
-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const key_type& __key)
-{
-  const size_type __n = _M_bkt_num_key(__key);
-  _Node* __first = _M_buckets[__n];
-  size_type __erased = 0;
-
-  if (__first) {
-    _Node* __cur = __first;
-    _Node* __next = __cur->_M_next;
-    while (__next) {
-      if (_M_equals(_M_get_key(__next->_M_val), __key)) {
-        __cur->_M_next = __next->_M_next;
-        _M_delete_node(__next);
-        __next = __cur->_M_next;
-        ++__erased;
-        --_M_num_elements;
-      }
-      else {
-        __cur = __next;
-        __next = __cur->_M_next;
-      }
-    }
-    if (_M_equals(_M_get_key(__first->_M_val), __key)) {
-      _M_buckets[__n] = __first->_M_next;
-      _M_delete_node(__first);
-      ++__erased;
-      --_M_num_elements;
-    }
-  }
-  return __erased;
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const iterator& __it)
-{
-  _Node* __p = __it._M_cur;
-  if (__p) {
-    const size_type __n = _M_bkt_num(__p->_M_val);
-    _Node* __cur = _M_buckets[__n];
-
-    if (__cur == __p) {
-      _M_buckets[__n] = __cur->_M_next;
-      _M_delete_node(__cur);
-      --_M_num_elements;
-    }
-    else {
-      _Node* __next = __cur->_M_next;
-      while (__next) {
-        if (__next == __p) {
-          __cur->_M_next = __next->_M_next;
-          _M_delete_node(__next);
-          --_M_num_elements;
-          break;
-        }
-        else {
-          __cur = __next;
-          __next = __cur->_M_next;
-        }
-      }
-    }
-  }
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
-  ::erase(iterator __first, iterator __last)
-{
-  size_type __f_bucket = __first._M_cur ? 
-    _M_bkt_num(__first._M_cur->_M_val) : _M_buckets.size();
-  size_type __l_bucket = __last._M_cur ? 
-    _M_bkt_num(__last._M_cur->_M_val) : _M_buckets.size();
-
-  if (__first._M_cur == __last._M_cur)
-    return;
-  else if (__f_bucket == __l_bucket)
-    _M_erase_bucket(__f_bucket, __first._M_cur, __last._M_cur);
-  else {
-    _M_erase_bucket(__f_bucket, __first._M_cur, 0);
-    for (size_type __n = __f_bucket + 1; __n < __l_bucket; ++__n)
-      _M_erase_bucket(__n, 0);
-    if (__l_bucket != _M_buckets.size())
-      _M_erase_bucket(__l_bucket, __last._M_cur);
-  }
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-inline void
-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const_iterator __first,
-                                             const_iterator __last)
-{
-  erase(iterator(const_cast<_Node*>(__first._M_cur),
-                 const_cast<hashtable*>(__first._M_ht)),
-        iterator(const_cast<_Node*>(__last._M_cur),
-                 const_cast<hashtable*>(__last._M_ht)));
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-inline void
-hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::erase(const const_iterator& __it)
-{
-  erase(iterator(const_cast<_Node*>(__it._M_cur),
-                 const_cast<hashtable*>(__it._M_ht)));
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
-  ::resize(size_type __num_elements_hint)
-{
-  const size_type __old_n = _M_buckets.size();
-  if (__num_elements_hint > __old_n) {
-    const size_type __n = _M_next_size(__num_elements_hint);
-    if (__n > __old_n) {
-      vector<_Node*, _All> __tmp(__n, (_Node*)(0),
-                                 _M_buckets.get_allocator());
-      __STL_TRY {
-        for (size_type __bucket = 0; __bucket < __old_n; ++__bucket) {
-          _Node* __first = _M_buckets[__bucket];
-          while (__first) {
-            size_type __new_bucket = _M_bkt_num(__first->_M_val, __n);
-            _M_buckets[__bucket] = __first->_M_next;
-            __first->_M_next = __tmp[__new_bucket];
-            __tmp[__new_bucket] = __first;
-            __first = _M_buckets[__bucket];          
-          }
-        }
-        _M_buckets.swap(__tmp);
-      }
-#         ifdef __STL_USE_EXCEPTIONS
-      catch(...) {
-        for (size_type __bucket = 0; __bucket < __tmp.size(); ++__bucket) {
-          while (__tmp[__bucket]) {
-            _Node* __next = __tmp[__bucket]->_M_next;
-            _M_delete_node(__tmp[__bucket]);
-            __tmp[__bucket] = __next;
-          }
-        }
-        throw;
-      }
-#         endif /* __STL_USE_EXCEPTIONS */
-    }
-  }
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
-  ::_M_erase_bucket(const size_type __n, _Node* __first, _Node* __last)
-{
-  _Node* __cur = _M_buckets[__n];
-  if (__cur == __first)
-    _M_erase_bucket(__n, __last);
-  else {
-    _Node* __next;
-    for (__next = __cur->_M_next; 
-         __next != __first; 
-         __cur = __next, __next = __cur->_M_next)
-      ;
-    while (__next != __last) {
-      __cur->_M_next = __next->_M_next;
-      _M_delete_node(__next);
-      __next = __cur->_M_next;
-      --_M_num_elements;
-    }
-  }
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
-  ::_M_erase_bucket(const size_type __n, _Node* __last)
-{
-  _Node* __cur = _M_buckets[__n];
-  while (__cur != __last) {
-    _Node* __next = __cur->_M_next;
-    _M_delete_node(__cur);
-    __cur = __next;
-    _M_buckets[__n] = __cur;
-    --_M_num_elements;
-  }
-}
-
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>::clear()
-{
-  for (size_type __i = 0; __i < _M_buckets.size(); ++__i) {
-    _Node* __cur = _M_buckets[__i];
-    while (__cur != 0) {
-      _Node* __next = __cur->_M_next;
-      _M_delete_node(__cur);
-      __cur = __next;
-    }
-    _M_buckets[__i] = 0;
-  }
-  _M_num_elements = 0;
-}
-
-    
-template <class _Val, class _Key, class _HF, class _Ex, class _Eq, class _All>
-void hashtable<_Val,_Key,_HF,_Ex,_Eq,_All>
-  ::_M_copy_from(const hashtable& __ht)
-{
-  _M_buckets.clear();
-  _M_buckets.reserve(__ht._M_buckets.size());
-  _M_buckets.insert(_M_buckets.end(), __ht._M_buckets.size(), (_Node*) 0);
-  __STL_TRY {
-    for (size_type __i = 0; __i < __ht._M_buckets.size(); ++__i) {
-      const _Node* __cur = __ht._M_buckets[__i];
-      if (__cur) {
-        _Node* __copy = _M_new_node(__cur->_M_val);
-        _M_buckets[__i] = __copy;
-
-        for (_Node* __next = __cur->_M_next; 
-             __next; 
-             __cur = __next, __next = __cur->_M_next) {
-          __copy->_M_next = _M_new_node(__next->_M_val);
-          __copy = __copy->_M_next;
-        }
-      }
-    }
-    _M_num_elements = __ht._M_num_elements;
-  }
-  __STL_UNWIND(clear());
-}
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_HASHTABLE_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_heap.h b/lib/include/stl/stl_heap.h
deleted file mode 100644
index 651d21a..0000000
--- a/lib/include/stl/stl_heap.h
+++ /dev/null
@@ -1,297 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_HEAP_H
-#define __SGI_STL_INTERNAL_HEAP_H
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1209
-#endif
-
-// Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap.
-
-template <class _RandomAccessIterator, class _Distance, class _Tp>
-void 
-__push_heap(_RandomAccessIterator __first,
-            _Distance __holeIndex, _Distance __topIndex, _Tp __value)
-{
-  _Distance __parent = (__holeIndex - 1) / 2;
-  while (__holeIndex > __topIndex && *(__first + __parent) < __value) {
-    *(__first + __holeIndex) = *(__first + __parent);
-    __holeIndex = __parent;
-    __parent = (__holeIndex - 1) / 2;
-  }    
-  *(__first + __holeIndex) = __value;
-}
-
-template <class _RandomAccessIterator, class _Distance, class _Tp>
-inline void 
-__push_heap_aux(_RandomAccessIterator __first,
-                _RandomAccessIterator __last, _Distance*, _Tp*)
-{
-  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), 
-              _Tp(*(__last - 1)));
-}
-
-template <class _RandomAccessIterator>
-inline void 
-push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
-{
-  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIterator>::value_type,
-                 _LessThanComparable);
-  __push_heap_aux(__first, __last,
-                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));
-}
-
-template <class _RandomAccessIterator, class _Distance, class _Tp, 
-          class _Compare>
-void
-__push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
-            _Distance __topIndex, _Tp __value, _Compare __comp)
-{
-  _Distance __parent = (__holeIndex - 1) / 2;
-  while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value)) {
-    *(__first + __holeIndex) = *(__first + __parent);
-    __holeIndex = __parent;
-    __parent = (__holeIndex - 1) / 2;
-  }
-  *(__first + __holeIndex) = __value;
-}
-
-template <class _RandomAccessIterator, class _Compare,
-          class _Distance, class _Tp>
-inline void 
-__push_heap_aux(_RandomAccessIterator __first,
-                _RandomAccessIterator __last, _Compare __comp,
-                _Distance*, _Tp*) 
-{
-  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), 
-              _Tp(*(__last - 1)), __comp);
-}
-
-template <class _RandomAccessIterator, class _Compare>
-inline void 
-push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
-          _Compare __comp)
-{
-  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
-  __push_heap_aux(__first, __last, __comp,
-                  __DISTANCE_TYPE(__first), __VALUE_TYPE(__first));
-}
-
-template <class _RandomAccessIterator, class _Distance, class _Tp>
-void 
-__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
-              _Distance __len, _Tp __value)
-{
-  _Distance __topIndex = __holeIndex;
-  _Distance __secondChild = 2 * __holeIndex + 2;
-  while (__secondChild < __len) {
-    if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
-      __secondChild--;
-    *(__first + __holeIndex) = *(__first + __secondChild);
-    __holeIndex = __secondChild;
-    __secondChild = 2 * (__secondChild + 1);
-  }
-  if (__secondChild == __len) {
-    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
-    __holeIndex = __secondChild - 1;
-  }
-  __push_heap(__first, __holeIndex, __topIndex, __value);
-}
-
-template <class _RandomAccessIterator, class _Tp, class _Distance>
-inline void 
-__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
-           _RandomAccessIterator __result, _Tp __value, _Distance*)
-{
-  *__result = *__first;
-  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);
-}
-
-template <class _RandomAccessIterator, class _Tp>
-inline void 
-__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,
-               _Tp*)
-{
-  __pop_heap(__first, __last - 1, __last - 1, 
-             _Tp(*(__last - 1)), __DISTANCE_TYPE(__first));
-}
-
-template <class _RandomAccessIterator>
-inline void pop_heap(_RandomAccessIterator __first, 
-                     _RandomAccessIterator __last)
-{
-  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIterator>::value_type,
-                 _LessThanComparable);
-  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));
-}
-
-template <class _RandomAccessIterator, class _Distance,
-          class _Tp, class _Compare>
-void
-__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
-              _Distance __len, _Tp __value, _Compare __comp)
-{
-  _Distance __topIndex = __holeIndex;
-  _Distance __secondChild = 2 * __holeIndex + 2;
-  while (__secondChild < __len) {
-    if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))
-      __secondChild--;
-    *(__first + __holeIndex) = *(__first + __secondChild);
-    __holeIndex = __secondChild;
-    __secondChild = 2 * (__secondChild + 1);
-  }
-  if (__secondChild == __len) {
-    *(__first + __holeIndex) = *(__first + (__secondChild - 1));
-    __holeIndex = __secondChild - 1;
-  }
-  __push_heap(__first, __holeIndex, __topIndex, __value, __comp);
-}
-
-template <class _RandomAccessIterator, class _Tp, class _Compare, 
-          class _Distance>
-inline void 
-__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
-           _RandomAccessIterator __result, _Tp __value, _Compare __comp,
-           _Distance*)
-{
-  *__result = *__first;
-  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), 
-                __value, __comp);
-}
-
-template <class _RandomAccessIterator, class _Tp, class _Compare>
-inline void 
-__pop_heap_aux(_RandomAccessIterator __first,
-               _RandomAccessIterator __last, _Tp*, _Compare __comp)
-{
-  __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __comp,
-             __DISTANCE_TYPE(__first));
-}
-
-template <class _RandomAccessIterator, class _Compare>
-inline void 
-pop_heap(_RandomAccessIterator __first,
-         _RandomAccessIterator __last, _Compare __comp)
-{
-  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
-  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first), __comp);
-}
-
-template <class _RandomAccessIterator, class _Tp, class _Distance>
-void 
-__make_heap(_RandomAccessIterator __first,
-            _RandomAccessIterator __last, _Tp*, _Distance*)
-{
-  if (__last - __first < 2) return;
-  _Distance __len = __last - __first;
-  _Distance __parent = (__len - 2)/2;
-    
-  while (true) {
-    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));
-    if (__parent == 0) return;
-    __parent--;
-  }
-}
-
-template <class _RandomAccessIterator>
-inline void 
-make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
-{
-  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIterator>::value_type,
-                 _LessThanComparable);
-  __make_heap(__first, __last,
-              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));
-}
-
-template <class _RandomAccessIterator, class _Compare,
-          class _Tp, class _Distance>
-void
-__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
-            _Compare __comp, _Tp*, _Distance*)
-{
-  if (__last - __first < 2) return;
-  _Distance __len = __last - __first;
-  _Distance __parent = (__len - 2)/2;
-    
-  while (true) {
-    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)),
-                  __comp);
-    if (__parent == 0) return;
-    __parent--;
-  }
-}
-
-template <class _RandomAccessIterator, class _Compare>
-inline void 
-make_heap(_RandomAccessIterator __first, 
-          _RandomAccessIterator __last, _Compare __comp)
-{
-  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
-  __make_heap(__first, __last, __comp,
-              __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));
-}
-
-template <class _RandomAccessIterator>
-void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
-{
-  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
-  __STL_REQUIRES(typename iterator_traits<_RandomAccessIterator>::value_type,
-                 _LessThanComparable);
-  while (__last - __first > 1)
-    pop_heap(__first, __last--);
-}
-
-template <class _RandomAccessIterator, class _Compare>
-void 
-sort_heap(_RandomAccessIterator __first,
-          _RandomAccessIterator __last, _Compare __comp)
-{
-  __STL_REQUIRES(_RandomAccessIterator, _Mutable_RandomAccessIterator);
-  while (__last - __first > 1)
-    pop_heap(__first, __last--, __comp);
-}
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1209
-#endif
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_HEAP_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_iterator.h b/lib/include/stl/stl_iterator.h
deleted file mode 100644
index cb62575..0000000
--- a/lib/include/stl/stl_iterator.h
+++ /dev/null
@@ -1,965 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996-1998
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_ITERATOR_H
-#define __SGI_STL_INTERNAL_ITERATOR_H
-
-__STL_BEGIN_NAMESPACE
-
-
-template <class _Container>
-class back_insert_iterator {
-protected:
-  _Container* container;
-public:
-  typedef _Container          container_type;
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  explicit back_insert_iterator(_Container& __x) : container(&__x) {}
-  back_insert_iterator<_Container>&
-  operator=(const typename _Container::value_type& __value) { 
-    container->push_back(__value);
-    return *this;
-  }
-  back_insert_iterator<_Container>& operator*() { return *this; }
-  back_insert_iterator<_Container>& operator++() { return *this; }
-  back_insert_iterator<_Container>& operator++(int) { return *this; }
-};
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Container>
-inline output_iterator_tag
-iterator_category(const back_insert_iterator<_Container>&)
-{
-  return output_iterator_tag();
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _Container>
-inline back_insert_iterator<_Container> back_inserter(_Container& __x) {
-  return back_insert_iterator<_Container>(__x);
-}
-
-template <class _Container>
-class front_insert_iterator {
-protected:
-  _Container* container;
-public:
-  typedef _Container          container_type;
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  explicit front_insert_iterator(_Container& __x) : container(&__x) {}
-  front_insert_iterator<_Container>&
-  operator=(const typename _Container::value_type& __value) { 
-    container->push_front(__value);
-    return *this;
-  }
-  front_insert_iterator<_Container>& operator*() { return *this; }
-  front_insert_iterator<_Container>& operator++() { return *this; }
-  front_insert_iterator<_Container>& operator++(int) { return *this; }
-};
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Container>
-inline output_iterator_tag
-iterator_category(const front_insert_iterator<_Container>&)
-{
-  return output_iterator_tag();
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _Container>
-inline front_insert_iterator<_Container> front_inserter(_Container& __x) {
-  return front_insert_iterator<_Container>(__x);
-}
-
-template <class _Container>
-class insert_iterator {
-protected:
-  _Container* container;
-  typename _Container::iterator iter;
-public:
-  typedef _Container          container_type;
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  insert_iterator(_Container& __x, typename _Container::iterator __i) 
-    : container(&__x), iter(__i) {}
-  insert_iterator<_Container>&
-  operator=(const typename _Container::value_type& __value) { 
-    iter = container->insert(iter, __value);
-    ++iter;
-    return *this;
-  }
-  insert_iterator<_Container>& operator*() { return *this; }
-  insert_iterator<_Container>& operator++() { return *this; }
-  insert_iterator<_Container>& operator++(int) { return *this; }
-};
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Container>
-inline output_iterator_tag
-iterator_category(const insert_iterator<_Container>&)
-{
-  return output_iterator_tag();
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _Container, class _Iterator>
-inline 
-insert_iterator<_Container> inserter(_Container& __x, _Iterator __i)
-{
-  typedef typename _Container::iterator __iter;
-  return insert_iterator<_Container>(__x, __iter(__i));
-}
-
-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES
-template <class _BidirectionalIterator, class _Tp, class _Reference = _Tp&, 
-          class _Distance = ptrdiff_t> 
-#else
-template <class _BidirectionalIterator, class _Tp, class _Reference, 
-          class _Distance> 
-#endif
-class reverse_bidirectional_iterator {
-  typedef reverse_bidirectional_iterator<_BidirectionalIterator, _Tp, 
-                                         _Reference, _Distance>  _Self;
-protected:
-  _BidirectionalIterator current;
-public:
-  typedef bidirectional_iterator_tag iterator_category;
-  typedef _Tp                        value_type;
-  typedef _Distance                  difference_type;
-  typedef _Tp*                       pointer;
-  typedef _Reference                 reference;
-
-  reverse_bidirectional_iterator() {}
-  explicit reverse_bidirectional_iterator(_BidirectionalIterator __x)
-    : current(__x) {}
-  _BidirectionalIterator base() const { return current; }
-  _Reference operator*() const {
-    _BidirectionalIterator __tmp = current;
-    return *--__tmp;
-  }
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return &(operator*()); }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-  _Self& operator++() {
-    --current;
-    return *this;
-  }
-  _Self operator++(int) {
-    _Self __tmp = *this;
-    --current;
-    return __tmp;
-  }
-  _Self& operator--() {
-    ++current;
-    return *this;
-  }
-  _Self operator--(int) {
-    _Self __tmp = *this;
-    ++current;
-    return __tmp;
-  }
-};
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _BidirectionalIterator, class _Tp, class _Reference, 
-          class _Distance>
-inline bidirectional_iterator_tag
-iterator_category(const reverse_bidirectional_iterator<_BidirectionalIterator,
-                                                       _Tp, _Reference, 
-                                                       _Distance>&) 
-{
-  return bidirectional_iterator_tag();
-}
-
-template <class _BidirectionalIterator, class _Tp, class _Reference, 
-          class _Distance>
-inline _Tp*
-value_type(const reverse_bidirectional_iterator<_BidirectionalIterator, _Tp,
-                                               _Reference, _Distance>&)
-{
-  return (_Tp*) 0;
-}
-
-template <class _BidirectionalIterator, class _Tp, class _Reference, 
-          class _Distance>
-inline _Distance*
-distance_type(const reverse_bidirectional_iterator<_BidirectionalIterator, 
-                                                   _Tp,
-                                                   _Reference, _Distance>&)
-{
-  return (_Distance*) 0;
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _BiIter, class _Tp, class _Ref, class _Distance>
-inline bool operator==(
-    const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __x, 
-    const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __y)
-{
-  return __x.base() == __y.base();
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _BiIter, class _Tp, class _Ref, class _Distance>
-inline bool operator!=(
-    const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __x, 
-    const reverse_bidirectional_iterator<_BiIter, _Tp, _Ref, _Distance>& __y)
-{
-  return !(__x == __y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-// This is the new version of reverse_iterator, as defined in the
-//  draft C++ standard.  It relies on the iterator_traits template,
-//  which in turn relies on partial specialization.  The class
-//  reverse_bidirectional_iterator is no longer part of the draft
-//  standard, but it is retained for backward compatibility.
-
-template <class _Iterator>
-class reverse_iterator 
-{
-protected:
-  _Iterator current;
-public:
-  typedef typename iterator_traits<_Iterator>::iterator_category
-          iterator_category;
-  typedef typename iterator_traits<_Iterator>::value_type
-          value_type;
-  typedef typename iterator_traits<_Iterator>::difference_type
-          difference_type;
-  typedef typename iterator_traits<_Iterator>::pointer
-          pointer;
-  typedef typename iterator_traits<_Iterator>::reference
-          reference;
-
-  typedef _Iterator iterator_type;
-  typedef reverse_iterator<_Iterator> _Self;
-
-public:
-  reverse_iterator() {}
-  explicit reverse_iterator(iterator_type __x) : current(__x) {}
-
-  reverse_iterator(const _Self& __x) : current(__x.current) {}
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _Iter>
-  reverse_iterator(const reverse_iterator<_Iter>& __x)
-    : current(__x.base()) {}
-#endif /* __STL_MEMBER_TEMPLATES */
-    
-  iterator_type base() const { return current; }
-  reference operator*() const {
-    _Iterator __tmp = current;
-    return *--__tmp;
-  }
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return &(operator*()); }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-
-  _Self& operator++() {
-    --current;
-    return *this;
-  }
-  _Self operator++(int) {
-    _Self __tmp = *this;
-    --current;
-    return __tmp;
-  }
-  _Self& operator--() {
-    ++current;
-    return *this;
-  }
-  _Self operator--(int) {
-    _Self __tmp = *this;
-    ++current;
-    return __tmp;
-  }
-
-  _Self operator+(difference_type __n) const {
-    return _Self(current - __n);
-  }
-  _Self& operator+=(difference_type __n) {
-    current -= __n;
-    return *this;
-  }
-  _Self operator-(difference_type __n) const {
-    return _Self(current + __n);
-  }
-  _Self& operator-=(difference_type __n) {
-    current += __n;
-    return *this;
-  }
-  reference operator[](difference_type __n) const { return *(*this + __n); }  
-}; 
- 
-template <class _Iterator>
-inline bool operator==(const reverse_iterator<_Iterator>& __x, 
-                       const reverse_iterator<_Iterator>& __y) {
-  return __x.base() == __y.base();
-}
-
-template <class _Iterator>
-inline bool operator<(const reverse_iterator<_Iterator>& __x, 
-                      const reverse_iterator<_Iterator>& __y) {
-  return __y.base() < __x.base();
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Iterator>
-inline bool operator!=(const reverse_iterator<_Iterator>& __x, 
-                       const reverse_iterator<_Iterator>& __y) {
-  return !(__x == __y);
-}
-
-template <class _Iterator>
-inline bool operator>(const reverse_iterator<_Iterator>& __x, 
-                      const reverse_iterator<_Iterator>& __y) {
-  return __y < __x;
-}
-
-template <class _Iterator>
-inline bool operator<=(const reverse_iterator<_Iterator>& __x, 
-                       const reverse_iterator<_Iterator>& __y) {
-  return !(__y < __x);
-}
-
-template <class _Iterator>
-inline bool operator>=(const reverse_iterator<_Iterator>& __x, 
-                      const reverse_iterator<_Iterator>& __y) {
-  return !(__x < __y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-template <class _Iterator>
-inline typename reverse_iterator<_Iterator>::difference_type
-operator-(const reverse_iterator<_Iterator>& __x, 
-          const reverse_iterator<_Iterator>& __y) {
-  return __y.base() - __x.base();
-}
-
-template <class _Iterator>
-inline reverse_iterator<_Iterator> 
-operator+(typename reverse_iterator<_Iterator>::difference_type __n,
-          const reverse_iterator<_Iterator>& __x) {
-  return reverse_iterator<_Iterator>(__x.base() - __n);
-}
-
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-// This is the old version of reverse_iterator, as found in the original
-//  HP STL.  It does not use partial specialization.
-
-#ifndef __STL_LIMITED_DEFAULT_TEMPLATES
-template <class _RandomAccessIterator, class _Tp, class _Reference = _Tp&,
-          class _Distance = ptrdiff_t> 
-#else
-template <class _RandomAccessIterator, class _Tp, class _Reference,
-          class _Distance> 
-#endif
-class reverse_iterator {
-  typedef reverse_iterator<_RandomAccessIterator, _Tp, _Reference, _Distance>
-        _Self;
-protected:
-  _RandomAccessIterator current;
-public:
-  typedef random_access_iterator_tag iterator_category;
-  typedef _Tp                        value_type;
-  typedef _Distance                  difference_type;
-  typedef _Tp*                       pointer;
-  typedef _Reference                 reference;
-
-  reverse_iterator() {}
-  explicit reverse_iterator(_RandomAccessIterator __x) : current(__x) {}
-  _RandomAccessIterator base() const { return current; }
-  _Reference operator*() const { return *(current - 1); }
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return &(operator*()); }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-  _Self& operator++() {
-    --current;
-    return *this;
-  }
-  _Self operator++(int) {
-    _Self __tmp = *this;
-    --current;
-    return __tmp;
-  }
-  _Self& operator--() {
-    ++current;
-    return *this;
-  }
-  _Self operator--(int) {
-    _Self __tmp = *this;
-    ++current;
-    return __tmp;
-  }
-  _Self operator+(_Distance __n) const {
-    return _Self(current - __n);
-  }
-  _Self& operator+=(_Distance __n) {
-    current -= __n;
-    return *this;
-  }
-  _Self operator-(_Distance __n) const {
-    return _Self(current + __n);
-  }
-  _Self& operator-=(_Distance __n) {
-    current += __n;
-    return *this;
-  }
-  _Reference operator[](_Distance __n) const { return *(*this + __n); }
-};
-
-template <class _RandomAccessIterator, class _Tp, 
-          class _Reference, class _Distance>
-inline random_access_iterator_tag
-iterator_category(const reverse_iterator<_RandomAccessIterator, _Tp,
-                                         _Reference, _Distance>&)
-{
-  return random_access_iterator_tag();
-}
-
-template <class _RandomAccessIterator, class _Tp,
-          class _Reference, class _Distance>
-inline _Tp* value_type(const reverse_iterator<_RandomAccessIterator, _Tp,
-                                              _Reference, _Distance>&)
-{
-  return (_Tp*) 0;
-}
-
-template <class _RandomAccessIterator, class _Tp,
-          class _Reference, class _Distance>
-inline _Distance* 
-distance_type(const reverse_iterator<_RandomAccessIterator, 
-                                     _Tp, _Reference, _Distance>&)
-{
-  return (_Distance*) 0;
-}
-
-
-template <class _RandomAccessIterator, class _Tp,
-          class _Reference, class _Distance>
-inline bool 
-operator==(const reverse_iterator<_RandomAccessIterator, _Tp,
-                                  _Reference, _Distance>& __x, 
-           const reverse_iterator<_RandomAccessIterator, _Tp,
-                                  _Reference, _Distance>& __y)
-{
-  return __x.base() == __y.base();
-}
-
-template <class _RandomAccessIterator, class _Tp,
-          class _Reference, class _Distance>
-inline bool 
-operator<(const reverse_iterator<_RandomAccessIterator, _Tp,
-                                 _Reference, _Distance>& __x, 
-          const reverse_iterator<_RandomAccessIterator, _Tp,
-                                 _Reference, _Distance>& __y)
-{
-  return __y.base() < __x.base();
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _RandomAccessIterator, class _Tp,
-          class _Reference, class _Distance>
-inline bool 
-operator!=(const reverse_iterator<_RandomAccessIterator, _Tp,
-                                  _Reference, _Distance>& __x, 
-           const reverse_iterator<_RandomAccessIterator, _Tp,
-                                  _Reference, _Distance>& __y) {
-  return !(__x == __y);
-}
-
-template <class _RandomAccessIterator, class _Tp,
-          class _Reference, class _Distance>
-inline bool 
-operator>(const reverse_iterator<_RandomAccessIterator, _Tp,
-                                 _Reference, _Distance>& __x, 
-          const reverse_iterator<_RandomAccessIterator, _Tp,
-                                 _Reference, _Distance>& __y) {
-  return __y < __x;
-}
-
-template <class _RandomAccessIterator, class _Tp,
-          class _Reference, class _Distance>
-inline bool 
-operator<=(const reverse_iterator<_RandomAccessIterator, _Tp,
-                                  _Reference, _Distance>& __x, 
-           const reverse_iterator<_RandomAccessIterator, _Tp,
-                                  _Reference, _Distance>& __y) {
-  return !(__y < __x);
-}
-
-template <class _RandomAccessIterator, class _Tp,
-          class _Reference, class _Distance>
-inline bool 
-operator>=(const reverse_iterator<_RandomAccessIterator, _Tp,
-                                  _Reference, _Distance>& __x, 
-           const reverse_iterator<_RandomAccessIterator, _Tp,
-                                  _Reference, _Distance>& __y) {
-  return !(__x < __y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-template <class _RandomAccessIterator, class _Tp,
-          class _Reference, class _Distance>
-inline _Distance 
-operator-(const reverse_iterator<_RandomAccessIterator, _Tp,
-                                 _Reference, _Distance>& __x, 
-          const reverse_iterator<_RandomAccessIterator, _Tp,
-                                 _Reference, _Distance>& __y)
-{
-  return __y.base() - __x.base();
-}
-
-template <class _RandAccIter, class _Tp, class _Ref, class _Dist>
-inline reverse_iterator<_RandAccIter, _Tp, _Ref, _Dist> 
-operator+(_Dist __n,
-          const reverse_iterator<_RandAccIter, _Tp, _Ref, _Dist>& __x)
-{
-  return reverse_iterator<_RandAccIter, _Tp, _Ref, _Dist>(__x.base() - __n);
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-// istream_iterator and ostream_iterator look very different if we're
-// using new, templatized iostreams than if we're using the old cfront
-// version.
-
-#ifdef __STL_USE_NEW_IOSTREAMS
-
-template <class _Tp, 
-          class _CharT = char, class _Traits = char_traits<_CharT>,
-          class _Dist = ptrdiff_t> 
-class istream_iterator {
-public:
-  typedef _CharT                         char_type;
-  typedef _Traits                        traits_type;
-  typedef basic_istream<_CharT, _Traits> istream_type;
-
-  typedef input_iterator_tag             iterator_category;
-  typedef _Tp                            value_type;
-  typedef _Dist                          difference_type;
-  typedef const _Tp*                     pointer;
-  typedef const _Tp&                     reference;
-
-  istream_iterator() : _M_stream(0), _M_ok(false) {}
-  istream_iterator(istream_type& __s) : _M_stream(&__s) { _M_read(); }
-
-  reference operator*() const { return _M_value; }
-  pointer operator->() const { return &(operator*()); }
-
-  istream_iterator& operator++() { 
-    _M_read(); 
-    return *this;
-  }
-  istream_iterator operator++(int)  {
-    istream_iterator __tmp = *this;
-    _M_read();
-    return __tmp;
-  }
-
-  bool _M_equal(const istream_iterator& __x) const
-    { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }
-
-private:
-  istream_type* _M_stream;
-  _Tp _M_value;
-  bool _M_ok;
-
-  void _M_read() {
-    _M_ok = (_M_stream && *_M_stream) ? true : false;
-    if (_M_ok) {
-      *_M_stream >> _M_value;
-      _M_ok = *_M_stream ? true : false;
-    }
-  }
-};
-
-template <class _Tp, class _CharT, class _Traits, class _Dist>
-inline bool 
-operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
-           const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y) {
-  return __x._M_equal(__y);
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Tp, class _CharT, class _Traits, class _Dist>
-inline bool 
-operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
-           const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y) {
-  return !__x._M_equal(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-template <class _Tp,
-          class _CharT = char, class _Traits = char_traits<_CharT> >
-class ostream_iterator {
-public:
-  typedef _CharT                         char_type;
-  typedef _Traits                        traits_type;
-  typedef basic_ostream<_CharT, _Traits> ostream_type;
-
-  typedef output_iterator_tag            iterator_category;
-  typedef void                           value_type;
-  typedef void                           difference_type;
-  typedef void                           pointer;
-  typedef void                           reference;
-
-  ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
-  ostream_iterator(ostream_type& __s, const _CharT* __c) 
-    : _M_stream(&__s), _M_string(__c)  {}
-  ostream_iterator<_Tp>& operator=(const _Tp& __value) { 
-    *_M_stream << __value;
-    if (_M_string) *_M_stream << _M_string;
-    return *this;
-  }
-  ostream_iterator<_Tp>& operator*() { return *this; }
-  ostream_iterator<_Tp>& operator++() { return *this; } 
-  ostream_iterator<_Tp>& operator++(int) { return *this; } 
-private:
-  ostream_type* _M_stream;
-  const _CharT* _M_string;
-};
-
-// The default template argument is declared in iosfwd
-
-// We do not read any characters until operator* is called.  The first
-// time operator* is called, it calls getc.  Subsequent calls to getc 
-// return a cached character, and calls to operator++ use snextc.  Before
-// operator* or operator++ has been called, _M_is_initialized is false.
-template<class _CharT, class _Traits>
-class istreambuf_iterator
-  : public iterator<input_iterator_tag, _CharT,
-                    typename _Traits::off_type, _CharT*, _CharT&>
-{
-public:
-  typedef _CharT                           char_type;
-  typedef _Traits                          traits_type;
-  typedef typename _Traits::int_type       int_type;
-  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
-  typedef basic_istream<_CharT, _Traits>   istream_type;
-
-public:
-  istreambuf_iterator(streambuf_type* __p = 0) { this->_M_init(__p); }
-  istreambuf_iterator(istream_type& __is) { this->_M_init(__is.rdbuf()); }
-
-  char_type operator*() const 
-    { return _M_is_initialized ? _M_c : _M_dereference_aux(); }
-
-  istreambuf_iterator& operator++() { this->_M_nextc(); return *this; }
-  istreambuf_iterator  operator++(int) {
-    if (!_M_is_initialized)
-      _M_postincr_aux();
-    istreambuf_iterator __tmp = *this;
-    this->_M_nextc();
-    return __tmp;
-  }
-
-  bool equal(const istreambuf_iterator& __i) const {
-    return this->_M_is_initialized && __i._M_is_initialized
-      ? this->_M_eof == __i._M_eof
-      : this->_M_equal_aux(__i);
-  }
-
-private:
-  void _M_init(streambuf_type* __p) {
-    _M_buf = __p;
-    _M_eof = !__p;
-    _M_is_initialized = _M_eof;
-  }
-
-  char_type _M_dereference_aux() const;
-  bool _M_equal_aux(const istreambuf_iterator&) const;
-  void _M_postincr_aux();
-
-  void _M_nextc() {
-    int_type __c = _M_buf->snextc();
-    _M_c = traits_type::to_char_type(__c);    
-    _M_eof = traits_type::eq_int_type(__c, traits_type::eof());
-    _M_is_initialized = true;
-  }
-
-  void _M_getc() const {
-    int_type __c = _M_buf->sgetc();
-    _M_c = traits_type::to_char_type(__c);
-    _M_eof = traits_type::eq_int_type(__c, traits_type::eof());
-    _M_is_initialized = true;
-  }
-
-private:
-  streambuf_type* _M_buf;
-  mutable _CharT _M_c;
-  mutable bool _M_eof : 1;
-  mutable bool _M_is_initialized : 1;
-};
-
-template<class _CharT, class _Traits>
-_CharT istreambuf_iterator<_CharT, _Traits>::_M_dereference_aux() const
-{
-  this->_M_getc();
-  return _M_c;
-}
-
-template<class _CharT, class _Traits>
-bool istreambuf_iterator<_CharT, _Traits>
-  ::_M_equal_aux(const istreambuf_iterator& __i) const
-{
-  if (!this->_M_is_initialized)
-    this->_M_getc();
-  if (!__i._M_is_initialized)
-    __i._M_getc();
-
-  return this->_M_eof == __i._M_eof;
-}
-
-template<class _CharT, class _Traits>
-void istreambuf_iterator<_CharT, _Traits>::_M_postincr_aux()
-{
-  this->_M_getc();
-}
-
-template<class _CharT, class _Traits>
-inline bool operator==(const istreambuf_iterator<_CharT, _Traits>& __x,
-                       const istreambuf_iterator<_CharT, _Traits>& __y) {
-  return __x.equal(__y);
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template<class _CharT, class _Traits>
-inline bool operator!=(const istreambuf_iterator<_CharT, _Traits>& __x,
-                       const istreambuf_iterator<_CharT, _Traits>& __y) {
-  return !__x.equal(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-// The default template argument is declared in iosfwd
-template<class _CharT, class _Traits>
-class ostreambuf_iterator
-  : public iterator<output_iterator_tag, void, void, void, void>
-{
-public:
-  typedef _CharT                           char_type;
-  typedef _Traits                          traits_type;
-  typedef typename _Traits::int_type       int_type;
-  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
-  typedef basic_ostream<_CharT, _Traits>   ostream_type;
-
-public:
-  ostreambuf_iterator(streambuf_type* __buf) : _M_buf(__buf), _M_ok(__buf) {}
-  ostreambuf_iterator(ostream_type& __o)
-    : _M_buf(__o.rdbuf()), _M_ok(__o.rdbuf() != 0) {}
-
-  ostreambuf_iterator& operator=(char_type __c) {
-    _M_ok = _M_ok && !traits_type::eq_int_type(_M_buf->sputc(__c),
-                                               traits_type::eof());
-    return *this;
-  }    
-  
-  ostreambuf_iterator& operator*()     { return *this; }
-  ostreambuf_iterator& operator++()    { return *this; }
-  ostreambuf_iterator& operator++(int) { return *this; }
-
-  bool failed() const { return !_M_ok; }
-
-private:
-  streambuf_type* _M_buf;
-  bool _M_ok;
-};
-
-#else /* __STL_USE_NEW_IOSTREAMS */
-
-template <class _Tp, class _Dist = ptrdiff_t> class istream_iterator;
-
-template <class _Tp, class _Dist>
-inline bool operator==(const istream_iterator<_Tp, _Dist>&,
-                       const istream_iterator<_Tp, _Dist>&);
-
-template <class _Tp, class _Dist>
-class istream_iterator {
-#ifdef __STL_TEMPLATE_FRIENDS
-  template <class _T1, class _D1>
-  friend bool operator==(const istream_iterator<_T1, _D1>&,
-                         const istream_iterator<_T1, _D1>&);
-#else /* __STL_TEMPLATE_FRIENDS */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const istream_iterator&,
-                                   const istream_iterator&);
-#endif /* __STL_TEMPLATE_FRIENDS */
-
-protected:
-  istream* _M_stream;
-  _Tp _M_value;
-  bool _M_end_marker;
-  void _M_read() {
-    _M_end_marker = (*_M_stream) ? true : false;
-    if (_M_end_marker) *_M_stream >> _M_value;
-    _M_end_marker = (*_M_stream) ? true : false;
-  }
-public:
-  typedef input_iterator_tag  iterator_category;
-  typedef _Tp                 value_type;
-  typedef _Dist               difference_type;
-  typedef const _Tp*          pointer;
-  typedef const _Tp&          reference;
-
-  istream_iterator() : _M_stream(&cin), _M_end_marker(false) {}
-  istream_iterator(istream& __s) : _M_stream(&__s) { _M_read(); }
-  reference operator*() const { return _M_value; }
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return &(operator*()); }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-  istream_iterator<_Tp, _Dist>& operator++() { 
-    _M_read(); 
-    return *this;
-  }
-  istream_iterator<_Tp, _Dist> operator++(int)  {
-    istream_iterator<_Tp, _Dist> __tmp = *this;
-    _M_read();
-    return __tmp;
-  }
-};
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Tp, class _Dist>
-inline input_iterator_tag 
-iterator_category(const istream_iterator<_Tp, _Dist>&)
-{
-  return input_iterator_tag();
-}
-
-template <class _Tp, class _Dist>
-inline _Tp* 
-value_type(const istream_iterator<_Tp, _Dist>&) { return (_Tp*) 0; }
-
-template <class _Tp, class _Dist>
-inline _Dist* 
-distance_type(const istream_iterator<_Tp, _Dist>&) { return (_Dist*)0; }
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _Tp, class _Distance>
-inline bool operator==(const istream_iterator<_Tp, _Distance>& __x,
-                       const istream_iterator<_Tp, _Distance>& __y) {
-  return (__x._M_stream == __y._M_stream &&
-          __x._M_end_marker == __y._M_end_marker) ||
-         __x._M_end_marker == false && __y._M_end_marker == false;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Tp, class _Distance>
-inline bool operator!=(const istream_iterator<_Tp, _Distance>& __x,
-                       const istream_iterator<_Tp, _Distance>& __y) {
-  return !(__x == __y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-template <class _Tp>
-class ostream_iterator {
-protected:
-  ostream* _M_stream;
-  const char* _M_string;
-public:
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  ostream_iterator(ostream& __s) : _M_stream(&__s), _M_string(0) {}
-  ostream_iterator(ostream& __s, const char* __c) 
-    : _M_stream(&__s), _M_string(__c)  {}
-  ostream_iterator<_Tp>& operator=(const _Tp& __value) { 
-    *_M_stream << __value;
-    if (_M_string) *_M_stream << _M_string;
-    return *this;
-  }
-  ostream_iterator<_Tp>& operator*() { return *this; }
-  ostream_iterator<_Tp>& operator++() { return *this; } 
-  ostream_iterator<_Tp>& operator++(int) { return *this; } 
-};
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Tp>
-inline output_iterator_tag 
-iterator_category(const ostream_iterator<_Tp>&) {
-  return output_iterator_tag();
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-#endif /* __STL_USE_NEW_IOSTREAMS */
-
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_ITERATOR_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_iterator_base.h b/lib/include/stl/stl_iterator_base.h
deleted file mode 100644
index 9c54225..0000000
--- a/lib/include/stl/stl_iterator_base.h
+++ /dev/null
@@ -1,367 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996-1998
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_ITERATOR_BASE_H
-#define __SGI_STL_INTERNAL_ITERATOR_BASE_H
-
-// This file contains all of the general iterator-related utilities.
-// The internal file stl_iterator.h contains predefined iterators, 
-// such as front_insert_iterator and istream_iterator.
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE
-
-struct input_iterator_tag {};
-struct output_iterator_tag {};
-struct forward_iterator_tag : public input_iterator_tag {};
-struct bidirectional_iterator_tag : public forward_iterator_tag {};
-struct random_access_iterator_tag : public bidirectional_iterator_tag {};
-
-// The base classes input_iterator, output_iterator, forward_iterator,
-// bidirectional_iterator, and random_access_iterator are not part of
-// the C++ standard.  (They have been replaced by struct iterator.)
-// They are included for backward compatibility with the HP STL.
-
-template <class _Tp, class _Distance> struct input_iterator {
-  typedef input_iterator_tag iterator_category;
-  typedef _Tp                value_type;
-  typedef _Distance          difference_type;
-  typedef _Tp*               pointer;
-  typedef _Tp&               reference;
-};
-
-struct output_iterator {
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-};
-
-template <class _Tp, class _Distance> struct forward_iterator {
-  typedef forward_iterator_tag iterator_category;
-  typedef _Tp                  value_type;
-  typedef _Distance            difference_type;
-  typedef _Tp*                 pointer;
-  typedef _Tp&                 reference;
-};
-
-
-template <class _Tp, class _Distance> struct bidirectional_iterator {
-  typedef bidirectional_iterator_tag iterator_category;
-  typedef _Tp                        value_type;
-  typedef _Distance                  difference_type;
-  typedef _Tp*                       pointer;
-  typedef _Tp&                       reference;
-};
-
-template <class _Tp, class _Distance> struct random_access_iterator {
-  typedef random_access_iterator_tag iterator_category;
-  typedef _Tp                        value_type;
-  typedef _Distance                  difference_type;
-  typedef _Tp*                       pointer;
-  typedef _Tp&                       reference;
-};
-
-#ifdef __STL_USE_NAMESPACES
-template <class _Category, class _Tp, class _Distance = ptrdiff_t,
-          class _Pointer = _Tp*, class _Reference = _Tp&>
-struct iterator {
-  typedef _Category  iterator_category;
-  typedef _Tp        value_type;
-  typedef _Distance  difference_type;
-  typedef _Pointer   pointer;
-  typedef _Reference reference;
-};
-#endif /* __STL_USE_NAMESPACES */
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Iterator>
-struct iterator_traits {
-  typedef typename _Iterator::iterator_category iterator_category;
-  typedef typename _Iterator::value_type        value_type;
-  typedef typename _Iterator::difference_type   difference_type;
-  typedef typename _Iterator::pointer           pointer;
-  typedef typename _Iterator::reference         reference;
-};
-
-template <class _Tp>
-struct iterator_traits<_Tp*> {
-  typedef random_access_iterator_tag iterator_category;
-  typedef _Tp                         value_type;
-  typedef ptrdiff_t                   difference_type;
-  typedef _Tp*                        pointer;
-  typedef _Tp&                        reference;
-};
-
-template <class _Tp>
-struct iterator_traits<const _Tp*> {
-  typedef random_access_iterator_tag iterator_category;
-  typedef _Tp                         value_type;
-  typedef ptrdiff_t                   difference_type;
-  typedef const _Tp*                  pointer;
-  typedef const _Tp&                  reference;
-};
-
-// The overloaded functions iterator_category, distance_type, and
-// value_type are not part of the C++ standard.  (They have been
-// replaced by struct iterator_traits.)  They are included for
-// backward compatibility with the HP STL.
-
-// We introduce internal names for these functions.
-
-template <class _Iter>
-inline typename iterator_traits<_Iter>::iterator_category
-__iterator_category(const _Iter&)
-{
-  typedef typename iterator_traits<_Iter>::iterator_category _Category;
-  return _Category();
-}
-
-template <class _Iter>
-inline typename iterator_traits<_Iter>::difference_type*
-__distance_type(const _Iter&)
-{
-  return static_cast<typename iterator_traits<_Iter>::difference_type*>(0);
-}
-
-template <class _Iter>
-inline typename iterator_traits<_Iter>::value_type*
-__value_type(const _Iter&)
-{
-  return static_cast<typename iterator_traits<_Iter>::value_type*>(0);
-}
-
-template <class _Iter>
-inline typename iterator_traits<_Iter>::iterator_category
-iterator_category(const _Iter& __i) { return __iterator_category(__i); }
-
-
-template <class _Iter>
-inline typename iterator_traits<_Iter>::difference_type*
-distance_type(const _Iter& __i) { return __distance_type(__i); }
-
-template <class _Iter>
-inline typename iterator_traits<_Iter>::value_type*
-value_type(const _Iter& __i) { return __value_type(__i); }
-
-#define __ITERATOR_CATEGORY(__i) __iterator_category(__i)
-#define __DISTANCE_TYPE(__i)     __distance_type(__i)
-#define __VALUE_TYPE(__i)        __value_type(__i)
-
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _Tp, class _Distance> 
-inline input_iterator_tag 
-iterator_category(const input_iterator<_Tp, _Distance>&)
-  { return input_iterator_tag(); }
-
-inline output_iterator_tag iterator_category(const output_iterator&)
-  { return output_iterator_tag(); }
-
-template <class _Tp, class _Distance> 
-inline forward_iterator_tag
-iterator_category(const forward_iterator<_Tp, _Distance>&)
-  { return forward_iterator_tag(); }
-
-template <class _Tp, class _Distance> 
-inline bidirectional_iterator_tag
-iterator_category(const bidirectional_iterator<_Tp, _Distance>&)
-  { return bidirectional_iterator_tag(); }
-
-template <class _Tp, class _Distance> 
-inline random_access_iterator_tag
-iterator_category(const random_access_iterator<_Tp, _Distance>&)
-  { return random_access_iterator_tag(); }
-
-template <class _Tp>
-inline random_access_iterator_tag iterator_category(const _Tp*)
-  { return random_access_iterator_tag(); }
-
-template <class _Tp, class _Distance> 
-inline _Tp* value_type(const input_iterator<_Tp, _Distance>&)
-  { return (_Tp*)(0); }
-
-template <class _Tp, class _Distance> 
-inline _Tp* value_type(const forward_iterator<_Tp, _Distance>&)
-  { return (_Tp*)(0); }
-
-template <class _Tp, class _Distance> 
-inline _Tp* value_type(const bidirectional_iterator<_Tp, _Distance>&)
-  { return (_Tp*)(0); }
-
-template <class _Tp, class _Distance> 
-inline _Tp* value_type(const random_access_iterator<_Tp, _Distance>&)
-  { return (_Tp*)(0); }
-
-template <class _Tp>
-inline _Tp* value_type(const _Tp*) { return (_Tp*)(0); }
-
-template <class _Tp, class _Distance> 
-inline _Distance* distance_type(const input_iterator<_Tp, _Distance>&)
-{
-  return (_Distance*)(0);
-}
-
-template <class _Tp, class _Distance> 
-inline _Distance* distance_type(const forward_iterator<_Tp, _Distance>&)
-{
-  return (_Distance*)(0);
-}
-
-template <class _Tp, class _Distance> 
-inline _Distance* 
-distance_type(const bidirectional_iterator<_Tp, _Distance>&)
-{
-  return (_Distance*)(0);
-}
-
-template <class _Tp, class _Distance> 
-inline _Distance* 
-distance_type(const random_access_iterator<_Tp, _Distance>&)
-{
-  return (_Distance*)(0);
-}
-
-template <class _Tp>
-inline ptrdiff_t* distance_type(const _Tp*) { return (ptrdiff_t*)(0); }
-
-// Without partial specialization we can't use iterator_traits, so
-// we must keep the old iterator query functions around.  
-
-#define __ITERATOR_CATEGORY(__i) iterator_category(__i)
-#define __DISTANCE_TYPE(__i)     distance_type(__i)
-#define __VALUE_TYPE(__i)        value_type(__i)
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _InputIterator, class _Distance>
-inline void __distance(_InputIterator __first, _InputIterator __last,
-                       _Distance& __n, input_iterator_tag)
-{
-  while (__first != __last) { ++__first; ++__n; }
-}
-
-template <class _RandomAccessIterator, class _Distance>
-inline void __distance(_RandomAccessIterator __first, 
-                       _RandomAccessIterator __last, 
-                       _Distance& __n, random_access_iterator_tag)
-{
-  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);
-  __n += __last - __first;
-}
-
-template <class _InputIterator, class _Distance>
-inline void distance(_InputIterator __first, 
-                     _InputIterator __last, _Distance& __n)
-{
-  __STL_REQUIRES(_InputIterator, _InputIterator);
-  __distance(__first, __last, __n, iterator_category(__first));
-}
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _InputIterator>
-inline typename iterator_traits<_InputIterator>::difference_type
-__distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)
-{
-  typename iterator_traits<_InputIterator>::difference_type __n = 0;
-  while (__first != __last) {
-    ++__first; ++__n;
-  }
-  return __n;
-}
-
-template <class _RandomAccessIterator>
-inline typename iterator_traits<_RandomAccessIterator>::difference_type
-__distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
-           random_access_iterator_tag) {
-  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);
-  return __last - __first;
-}
-
-template <class _InputIterator>
-inline typename iterator_traits<_InputIterator>::difference_type
-distance(_InputIterator __first, _InputIterator __last) {
-  typedef typename iterator_traits<_InputIterator>::iterator_category 
-    _Category;
-  __STL_REQUIRES(_InputIterator, _InputIterator);
-  return __distance(__first, __last, _Category());
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-template <class _InputIter, class _Distance>
-inline void __advance(_InputIter& __i, _Distance __n, input_iterator_tag) {
-  while (__n--) ++__i;
-}
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1183
-#endif
-
-template <class _BidirectionalIterator, class _Distance>
-inline void __advance(_BidirectionalIterator& __i, _Distance __n, 
-                      bidirectional_iterator_tag) {
-  __STL_REQUIRES(_BidirectionalIterator, _BidirectionalIterator);
-  if (__n >= 0)
-    while (__n--) ++__i;
-  else
-    while (__n++) --__i;
-}
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1183
-#endif
-
-template <class _RandomAccessIterator, class _Distance>
-inline void __advance(_RandomAccessIterator& __i, _Distance __n, 
-                      random_access_iterator_tag) {
-  __STL_REQUIRES(_RandomAccessIterator, _RandomAccessIterator);
-  __i += __n;
-}
-
-template <class _InputIterator, class _Distance>
-inline void advance(_InputIterator& __i, _Distance __n) {
-  __STL_REQUIRES(_InputIterator, _InputIterator);
-  __advance(__i, __n, iterator_category(__i));
-}
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_ITERATOR_BASE_H */
-
-
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_list.h b/lib/include/stl/stl_list.h
deleted file mode 100644
index c8ae5b9..0000000
--- a/lib/include/stl/stl_list.h
+++ /dev/null
@@ -1,885 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_LIST_H
-#define __SGI_STL_INTERNAL_LIST_H
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-struct _List_node_base {
-  _List_node_base* _M_next;
-  _List_node_base* _M_prev;
-};
-
-template <class _Tp>
-struct _List_node : public _List_node_base {
-  _Tp _M_data;
-};
-
-struct _List_iterator_base {
-  typedef size_t                     size_type;
-  typedef ptrdiff_t                  difference_type;
-  typedef bidirectional_iterator_tag iterator_category;
-
-  _List_node_base* _M_node;
-
-  _List_iterator_base(_List_node_base* __x) : _M_node(__x) {}
-  _List_iterator_base() {}
-
-  void _M_incr() { _M_node = _M_node->_M_next; }
-  void _M_decr() { _M_node = _M_node->_M_prev; }
-
-  bool operator==(const _List_iterator_base& __x) const {
-    return _M_node == __x._M_node;
-  }
-  bool operator!=(const _List_iterator_base& __x) const {
-    return _M_node != __x._M_node;
-  }
-};  
-
-template<class _Tp, class _Ref, class _Ptr>
-struct _List_iterator : public _List_iterator_base {
-  typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;
-  typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;
-  typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;
-
-  typedef _Tp value_type;
-  typedef _Ptr pointer;
-  typedef _Ref reference;
-  typedef _List_node<_Tp> _Node;
-
-  _List_iterator(_Node* __x) : _List_iterator_base(__x) {}
-  _List_iterator() {}
-  _List_iterator(const iterator& __x) : _List_iterator_base(__x._M_node) {}
-
-  reference operator*() const { return ((_Node*) _M_node)->_M_data; }
-
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return &(operator*()); }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-
-  _Self& operator++() { 
-    this->_M_incr();
-    return *this;
-  }
-  _Self operator++(int) { 
-    _Self __tmp = *this;
-    this->_M_incr();
-    return __tmp;
-  }
-  _Self& operator--() { 
-    this->_M_decr();
-    return *this;
-  }
-  _Self operator--(int) { 
-    _Self __tmp = *this;
-    this->_M_decr();
-    return __tmp;
-  }
-};
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-inline bidirectional_iterator_tag
-iterator_category(const _List_iterator_base&)
-{
-  return bidirectional_iterator_tag();
-}
-
-template <class _Tp, class _Ref, class _Ptr>
-inline _Tp*
-value_type(const _List_iterator<_Tp, _Ref, _Ptr>&)
-{
-  return 0;
-}
-
-inline ptrdiff_t*
-distance_type(const _List_iterator_base&)
-{
-  return 0;
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-
-// Base class that encapsulates details of allocators.  Three cases:
-// an ordinary standard-conforming allocator, a standard-conforming
-// allocator with no non-static data, and an SGI-style allocator.
-// This complexity is necessary only because we're worrying about backward
-// compatibility and because we want to avoid wasting storage on an 
-// allocator instance if it isn't necessary.
-
-#ifdef __STL_USE_STD_ALLOCATORS
-
-// Base for general standard-conforming allocators.
-template <class _Tp, class _Allocator, bool _IsStatic>
-class _List_alloc_base {
-public:
-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
-          allocator_type;
-  allocator_type get_allocator() const { return _Node_allocator; }
-
-  _List_alloc_base(const allocator_type& __a) : _Node_allocator(__a) {}
-
-protected:
-  _List_node<_Tp>* _M_get_node()
-   { return _Node_allocator.allocate(1); }
-  void _M_put_node(_List_node<_Tp>* __p)
-    { _Node_allocator.deallocate(__p, 1); }
-
-protected:
-  typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type
-           _Node_allocator;
-  _List_node<_Tp>* _M_node;
-};
-
-// Specialization for instanceless allocators.
-
-template <class _Tp, class _Allocator>
-class _List_alloc_base<_Tp, _Allocator, true> {
-public:
-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
-          allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _List_alloc_base(const allocator_type&) {}
-
-protected:
-  typedef typename _Alloc_traits<_List_node<_Tp>, _Allocator>::_Alloc_type
-          _Alloc_type;
-  _List_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }
-  void _M_put_node(_List_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }
-
-protected:
-  _List_node<_Tp>* _M_node;
-};
-
-template <class _Tp, class _Alloc>
-class _List_base 
-  : public _List_alloc_base<_Tp, _Alloc,
-                            _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-{
-public:
-  typedef _List_alloc_base<_Tp, _Alloc,
-                           _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-          _Base; 
-  typedef typename _Base::allocator_type allocator_type;
-
-  _List_base(const allocator_type& __a) : _Base(__a) {
-    _Base::_M_node = _Base::_M_get_node();
-    _Base::_M_node->_M_next = _Base::_M_node;
-    _Base::_M_node->_M_prev = _Base::_M_node;
-  }
-  ~_List_base() {
-    clear();
-    this->_M_put_node(_Base::_M_node);
-  }
-
-  void clear();
-};
-
-#else /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Tp, class _Alloc>
-class _List_base 
-{
-public:
-  typedef _Alloc allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _List_base(const allocator_type&) {
-    _M_node = _M_get_node();
-    _M_node->_M_next = _M_node;
-    _M_node->_M_prev = _M_node;
-  }
-  ~_List_base() {
-    clear();
-    this->_M_put_node(_M_node);
-  }
-
-  void clear();
-
-protected:
-  typedef simple_alloc<_List_node<_Tp>, _Alloc> _Alloc_type;
-  _List_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }
-  void _M_put_node(_List_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); } 
-
-protected:
-  _List_node<_Tp>* _M_node;
-};
-
-#endif /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Tp, class _Alloc>
-void 
-_List_base<_Tp,_Alloc>::clear() 
-{
-  _List_node<_Tp>* __cur = (_List_node<_Tp>*) _Base::_M_node->_M_next;
-  while (__cur != _Base::_M_node) {
-    _List_node<_Tp>* __tmp = __cur;
-    __cur = (_List_node<_Tp>*) __cur->_M_next;
-    _Destroy(&__tmp->_M_data);
-    this->_M_put_node(__tmp);
-  }
-  _Base::_M_node->_M_next = _Base::_M_node;
-  _Base::_M_node->_M_prev = _Base::_M_node;
-}
-
-template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >
-class list : protected _List_base<_Tp, _Alloc> {
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-
-  typedef _List_base<_Tp, _Alloc> _Base;
-protected:
-  typedef void* _Void_pointer;
-
-public:      
-  typedef _Tp value_type;
-  typedef value_type* pointer;
-  typedef const value_type* const_pointer;
-  typedef value_type& reference;
-  typedef const value_type& const_reference;
-  typedef _List_node<_Tp> _Node;
-  typedef size_t size_type;
-  typedef ptrdiff_t difference_type;
-
-  typedef typename _Base::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _Base::get_allocator(); }
-
-public:
-  typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;
-  typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
-  typedef std::reverse_iterator<iterator>       reverse_iterator;
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-  typedef std::reverse_bidirectional_iterator<const_iterator,value_type,
-                                         const_reference,difference_type>
-          const_reverse_iterator;
-  typedef std::reverse_bidirectional_iterator<iterator,value_type,reference,
-                                         difference_type>
-          reverse_iterator; 
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-protected:
-#ifdef __STL_HAS_NAMESPACES
-  using _Base::_M_node;
-  using _Base::_M_put_node;
-  using _Base::_M_get_node;
-#endif /* __STL_HAS_NAMESPACES */
-
-protected:
-  _Node* _M_create_node(const _Tp& __x)
-  {
-    _Node* __p = _M_get_node();
-    __STL_TRY {
-      _Construct(&__p->_M_data, __x);
-    }
-    __STL_UNWIND(_M_put_node(__p));
-    return __p;
-  }
-
-  _Node* _M_create_node()
-  {
-    _Node* __p = _M_get_node();
-    __STL_TRY {
-      _Construct(&__p->_M_data);
-    }
-    __STL_UNWIND(_M_put_node(__p));
-    return __p;
-  }
-
-public:
-  explicit list(const allocator_type& __a = allocator_type()) : _Base(__a) {}
-
-  iterator begin()             { return (_Node*)(_M_node->_M_next); }
-  const_iterator begin() const { return (_Node*)(_M_node->_M_next); }
-
-  iterator end()             { return _M_node; }
-  const_iterator end() const { return _M_node; }
-
-  reverse_iterator rbegin() 
-    { return reverse_iterator(end()); }
-  const_reverse_iterator rbegin() const 
-    { return const_reverse_iterator(end()); }
-
-  reverse_iterator rend()
-    { return reverse_iterator(begin()); }
-  const_reverse_iterator rend() const
-    { return const_reverse_iterator(begin()); }
-
-  bool empty() const { return _M_node->_M_next == _M_node; }
-  size_type size() const {
-    size_type __result = 0;
-    distance(begin(), end(), __result);
-    return __result;
-  }
-  size_type max_size() const { return size_type(-1); }
-
-  reference front() { return *begin(); }
-  const_reference front() const { return *begin(); }
-  reference back() { return *(--end()); }
-  const_reference back() const { return *(--end()); }
-
-  void swap(list<_Tp, _Alloc>& __x) { __STD::swap(_M_node, __x._M_node); }
-
-  iterator insert(iterator __position, const _Tp& __x) {
-    _Node* __tmp = _M_create_node(__x);
-    __tmp->_M_next = __position._M_node;
-    __tmp->_M_prev = __position._M_node->_M_prev;
-    __position._M_node->_M_prev->_M_next = __tmp;
-    __position._M_node->_M_prev = __tmp;
-    return __tmp;
-  }
-  iterator insert(iterator __position) { return insert(__position, _Tp()); }
-#ifdef __STL_MEMBER_TEMPLATES
-  // Check whether it's an integral type.  If so, it's not an iterator.
-
-  template<class _Integer>
-  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
-                          __true_type) {
-    _M_fill_insert(__pos, (size_type) __n, (_Tp) __x);
-  }
-
-  template <class _InputIterator>
-  void _M_insert_dispatch(iterator __pos,
-                          _InputIterator __first, _InputIterator __last,
-                          __false_type);
-
-  template <class _InputIterator>
-  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_insert_dispatch(__pos, __first, __last, _Integral());
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-  void insert(iterator __position, const _Tp* __first, const _Tp* __last);
-  void insert(iterator __position,
-              const_iterator __first, const_iterator __last);
-#endif /* __STL_MEMBER_TEMPLATES */
-  void insert(iterator __pos, size_type __n, const _Tp& __x)
-    { _M_fill_insert(__pos, __n, __x); }
-  void _M_fill_insert(iterator __pos, size_type __n, const _Tp& __x); 
-
-  void push_front(const _Tp& __x) { insert(begin(), __x); }
-  void push_front() {insert(begin());}
-  void push_back(const _Tp& __x) { insert(end(), __x); }
-  void push_back() {insert(end());}
-
-  iterator erase(iterator __position) {
-    _List_node_base* __next_node = __position._M_node->_M_next;
-    _List_node_base* __prev_node = __position._M_node->_M_prev;
-    _Node* __n = (_Node*) __position._M_node;
-    __prev_node->_M_next = __next_node;
-    __next_node->_M_prev = __prev_node;
-    _Destroy(&__n->_M_data);
-    _M_put_node(__n);
-    return iterator((_Node*) __next_node);
-  }
-  iterator erase(iterator __first, iterator __last);
-  void clear() { _Base::clear(); }
-
-  void resize(size_type __new_size, const _Tp& __x);
-  void resize(size_type __new_size) { this->resize(__new_size, _Tp()); }
-
-  void pop_front() { erase(begin()); }
-  void pop_back() { 
-    iterator __tmp = end();
-    erase(--__tmp);
-  }
-  list(size_type __n, const _Tp& __value,
-       const allocator_type& __a = allocator_type())
-    : _Base(__a)
-    { insert(begin(), __n, __value); }
-  explicit list(size_type __n)
-    : _Base(allocator_type())
-    { insert(begin(), __n, _Tp()); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  // We don't need any dispatching tricks here, because insert does all of
-  // that anyway.  
-  template <class _InputIterator>
-  list(_InputIterator __first, _InputIterator __last,
-       const allocator_type& __a = allocator_type())
-    : _Base(__a)
-    { insert(begin(), __first, __last); }
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-  list(const _Tp* __first, const _Tp* __last,
-       const allocator_type& __a = allocator_type())
-    : _Base(__a)
-    { this->insert(begin(), __first, __last); }
-  list(const_iterator __first, const_iterator __last,
-       const allocator_type& __a = allocator_type())
-    : _Base(__a)
-    { this->insert(begin(), __first, __last); }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-  list(const list<_Tp, _Alloc>& __x) : _Base(__x.get_allocator())
-    { insert(begin(), __x.begin(), __x.end()); }
-
-  ~list() { }
-
-  list<_Tp, _Alloc>& operator=(const list<_Tp, _Alloc>& __x);
-
-public:
-  // assign(), a generalized assignment member function.  Two
-  // versions: one that takes a count, and one that takes a range.
-  // The range version is a member template, so we dispatch on whether
-  // or not the type is an integer.
-
-  void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }
-
-  void _M_fill_assign(size_type __n, const _Tp& __val);
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  template <class _InputIterator>
-  void assign(_InputIterator __first, _InputIterator __last) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_assign_dispatch(__first, __last, _Integral());
-  }
-
-  template <class _Integer>
-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
-    { _M_fill_assign((size_type) __n, (_Tp) __val); }
-
-  template <class _InputIterator>
-  void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
-                          __false_type);
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-protected:
-  void transfer(iterator __position, iterator __first, iterator __last) {
-    if (__position != __last) {
-      // Remove [first, last) from its old position.
-      __last._M_node->_M_prev->_M_next     = __position._M_node;
-      __first._M_node->_M_prev->_M_next    = __last._M_node;
-      __position._M_node->_M_prev->_M_next = __first._M_node; 
-
-      // Splice [first, last) into its new position.
-      _List_node_base* __tmp      = __position._M_node->_M_prev;
-      __position._M_node->_M_prev = __last._M_node->_M_prev;
-      __last._M_node->_M_prev     = __first._M_node->_M_prev; 
-      __first._M_node->_M_prev    = __tmp;
-    }
-  }
-
-public:
-  void splice(iterator __position, list& __x) {
-    if (!__x.empty()) 
-      this->transfer(__position, __x.begin(), __x.end());
-  }
-  void splice(iterator __position, list&, iterator __i) {
-    iterator __j = __i;
-    ++__j;
-    if (__position == __i || __position == __j) return;
-    this->transfer(__position, __i, __j);
-  }
-  void splice(iterator __position, list&, iterator __first, iterator __last) {
-    if (__first != __last) 
-      this->transfer(__position, __first, __last);
-  }
-  void remove(const _Tp& __value);
-  void unique();
-  void merge(list& __x);
-  void reverse();
-  void sort();
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _Predicate> void remove_if(_Predicate);
-  template <class _BinaryPredicate> void unique(_BinaryPredicate);
-  template <class _StrictWeakOrdering> void merge(list&, _StrictWeakOrdering);
-  template <class _StrictWeakOrdering> void sort(_StrictWeakOrdering);
-#endif /* __STL_MEMBER_TEMPLATES */
-};
-
-template <class _Tp, class _Alloc>
-inline bool 
-operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)
-{
-  typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;
-  const_iterator __end1 = __x.end();
-  const_iterator __end2 = __y.end();
-
-  const_iterator __i1 = __x.begin();
-  const_iterator __i2 = __y.begin();
-  while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {
-    ++__i1;
-    ++__i2;
-  }
-  return __i1 == __end1 && __i2 == __end2;
-}
-
-template <class _Tp, class _Alloc>
-inline bool operator<(const list<_Tp,_Alloc>& __x,
-                      const list<_Tp,_Alloc>& __y)
-{
-  return lexicographical_compare(__x.begin(), __x.end(),
-                                 __y.begin(), __y.end());
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Tp, class _Alloc>
-inline bool operator!=(const list<_Tp,_Alloc>& __x,
-                       const list<_Tp,_Alloc>& __y) {
-  return !(__x == __y);
-}
-
-template <class _Tp, class _Alloc>
-inline bool operator>(const list<_Tp,_Alloc>& __x,
-                      const list<_Tp,_Alloc>& __y) {
-  return __y < __x;
-}
-
-template <class _Tp, class _Alloc>
-inline bool operator<=(const list<_Tp,_Alloc>& __x,
-                       const list<_Tp,_Alloc>& __y) {
-  return !(__y < __x);
-}
-
-template <class _Tp, class _Alloc>
-inline bool operator>=(const list<_Tp,_Alloc>& __x,
-                       const list<_Tp,_Alloc>& __y) {
-  return !(__x < __y);
-}
-
-template <class _Tp, class _Alloc>
-inline void 
-swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
-{
-  __x.swap(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Alloc> template <class _InputIter>
-void 
-list<_Tp, _Alloc>::_M_insert_dispatch(iterator __position,
-                                      _InputIter __first, _InputIter __last,
-                                      __false_type)
-{
-  for ( ; __first != __last; ++__first)
-    insert(__position, *__first);
-}
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-void 
-list<_Tp, _Alloc>::insert(iterator __position, 
-                          const _Tp* __first, const _Tp* __last)
-{
-  for ( ; __first != __last; ++__first)
-    insert(__position, *__first);
-}
-
-template <class _Tp, class _Alloc>
-void 
-list<_Tp, _Alloc>::insert(iterator __position,
-                         const_iterator __first, const_iterator __last)
-{
-  for ( ; __first != __last; ++__first)
-    insert(__position, *__first);
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-void 
-list<_Tp, _Alloc>::_M_fill_insert(iterator __position,
-                                  size_type __n, const _Tp& __x)
-{
-  for ( ; __n > 0; --__n)
-    insert(__position, __x);
-}
-
-template <class _Tp, class _Alloc>
-typename list<_Tp,_Alloc>::iterator list<_Tp, _Alloc>::erase(iterator __first, 
-                                                             iterator __last)
-{
-  while (__first != __last)
-    erase(__first++);
-  return __last;
-}
-
-template <class _Tp, class _Alloc>
-void list<_Tp, _Alloc>::resize(size_type __new_size, const _Tp& __x)
-{
-  iterator __i = begin();
-  size_type __len = 0;
-  for ( ; __i != end() && __len < __new_size; ++__i, ++__len)
-    ;
-  if (__len == __new_size)
-    erase(__i, end());
-  else                          // __i == end()
-    insert(end(), __new_size - __len, __x);
-}
-
-template <class _Tp, class _Alloc>
-list<_Tp, _Alloc>& list<_Tp, _Alloc>::operator=(const list<_Tp, _Alloc>& __x)
-{
-  if (this != &__x) {
-    iterator __first1 = begin();
-    iterator __last1 = end();
-    const_iterator __first2 = __x.begin();
-    const_iterator __last2 = __x.end();
-    while (__first1 != __last1 && __first2 != __last2) 
-      *__first1++ = *__first2++;
-    if (__first2 == __last2)
-      erase(__first1, __last1);
-    else
-      insert(__last1, __first2, __last2);
-  }
-  return *this;
-}
-
-template <class _Tp, class _Alloc>
-void list<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {
-  iterator __i = begin();
-  for ( ; __i != end() && __n > 0; ++__i, --__n)
-    *__i = __val;
-  if (__n > 0)
-    insert(end(), __n, __val);
-  else
-    erase(__i, end());
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Alloc> template <class _InputIter>
-void
-list<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first2, _InputIter __last2,
-                                      __false_type)
-{
-  iterator __first1 = begin();
-  iterator __last1 = end();
-  for ( ; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)
-    *__first1 = *__first2;
-  if (__first2 == __last2)
-    erase(__first1, __last1);
-  else
-    insert(__last1, __first2, __last2);
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-void list<_Tp, _Alloc>::remove(const _Tp& __value)
-{
-  iterator __first = begin();
-  iterator __last = end();
-  while (__first != __last) {
-    iterator __next = __first;
-    ++__next;
-    if (*__first == __value) erase(__first);
-    __first = __next;
-  }
-}
-
-template <class _Tp, class _Alloc>
-void list<_Tp, _Alloc>::unique()
-{
-  iterator __first = begin();
-  iterator __last = end();
-  if (__first == __last) return;
-  iterator __next = __first;
-  while (++__next != __last) {
-    if (*__first == *__next)
-      erase(__next);
-    else
-      __first = __next;
-    __next = __first;
-  }
-}
-
-template <class _Tp, class _Alloc>
-void list<_Tp, _Alloc>::merge(list<_Tp, _Alloc>& __x)
-{
-  iterator __first1 = begin();
-  iterator __last1 = end();
-  iterator __first2 = __x.begin();
-  iterator __last2 = __x.end();
-  while (__first1 != __last1 && __first2 != __last2)
-    if (*__first2 < *__first1) {
-      iterator __next = __first2;
-      transfer(__first1, __first2, ++__next);
-      __first2 = __next;
-    }
-    else
-      ++__first1;
-  if (__first2 != __last2) transfer(__last1, __first2, __last2);
-}
-
-inline void __List_base_reverse(_List_node_base* __p)
-{
-  _List_node_base* __tmp = __p;
-  do {
-    __STD::swap(__tmp->_M_next, __tmp->_M_prev);
-    __tmp = __tmp->_M_prev;     // Old next node is now prev.
-  } while (__tmp != __p);
-}
-
-template <class _Tp, class _Alloc>
-inline void list<_Tp, _Alloc>::reverse() 
-{
-  __List_base_reverse(this->_M_node);
-}    
-
-template <class _Tp, class _Alloc>
-void list<_Tp, _Alloc>::sort()
-{
-  // Do nothing if the list has length 0 or 1.
-  if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {
-    list<_Tp, _Alloc> __carry;
-    list<_Tp, _Alloc> __counter[64];
-    int __fill = 0;
-    while (!empty()) {
-      __carry.splice(__carry.begin(), *this, begin());
-      int __i = 0;
-      while(__i < __fill && !__counter[__i].empty()) {
-        __counter[__i].merge(__carry);
-        __carry.swap(__counter[__i++]);
-      }
-      __carry.swap(__counter[__i]);         
-      if (__i == __fill) ++__fill;
-    } 
-
-    for (int __i = 1; __i < __fill; ++__i)
-      __counter[__i].merge(__counter[__i-1]);
-    swap(__counter[__fill-1]);
-  }
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Alloc> template <class _Predicate>
-void list<_Tp, _Alloc>::remove_if(_Predicate __pred)
-{
-  iterator __first = begin();
-  iterator __last = end();
-  while (__first != __last) {
-    iterator __next = __first;
-    ++__next;
-    if (__pred(*__first)) erase(__first);
-    __first = __next;
-  }
-}
-
-template <class _Tp, class _Alloc> template <class _BinaryPredicate>
-void list<_Tp, _Alloc>::unique(_BinaryPredicate __binary_pred)
-{
-  iterator __first = begin();
-  iterator __last = end();
-  if (__first == __last) return;
-  iterator __next = __first;
-  while (++__next != __last) {
-    if (__binary_pred(*__first, *__next))
-      erase(__next);
-    else
-      __first = __next;
-    __next = __first;
-  }
-}
-
-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>
-void list<_Tp, _Alloc>::merge(list<_Tp, _Alloc>& __x,
-                              _StrictWeakOrdering __comp)
-{
-  iterator __first1 = begin();
-  iterator __last1 = end();
-  iterator __first2 = __x.begin();
-  iterator __last2 = __x.end();
-  while (__first1 != __last1 && __first2 != __last2)
-    if (__comp(*__first2, *__first1)) {
-      iterator __next = __first2;
-      transfer(__first1, __first2, ++__next);
-      __first2 = __next;
-    }
-    else
-      ++__first1;
-  if (__first2 != __last2) transfer(__last1, __first2, __last2);
-}
-
-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>
-void list<_Tp, _Alloc>::sort(_StrictWeakOrdering __comp)
-{
-  // Do nothing if the list has length 0 or 1.
-  if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node) {
-    list<_Tp, _Alloc> __carry;
-    list<_Tp, _Alloc> __counter[64];
-    int __fill = 0;
-    while (!empty()) {
-      __carry.splice(__carry.begin(), *this, begin());
-      int __i = 0;
-      while(__i < __fill && !__counter[__i].empty()) {
-        __counter[__i].merge(__carry, __comp);
-        __carry.swap(__counter[__i++]);
-      }
-      __carry.swap(__counter[__i]);         
-      if (__i == __fill) ++__fill;
-    } 
-
-    for (int __i = 1; __i < __fill; ++__i) 
-      __counter[__i].merge(__counter[__i-1], __comp);
-    swap(__counter[__fill-1]);
-  }
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE 
-
-#endif /* __SGI_STL_INTERNAL_LIST_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_map.h b/lib/include/stl/stl_map.h
deleted file mode 100644
index 7a7f8d5..0000000
--- a/lib/include/stl/stl_map.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_MAP_H
-#define __SGI_STL_INTERNAL_MAP_H
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-// Forward declarations of operators == and <, needed for friend declarations.
-template <class _Key, class _Tp, 
-          class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less<_Key>),
-          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >
-class map;
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const map<_Key,_Tp,_Compare,_Alloc>& __y);
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x, 
-                      const map<_Key,_Tp,_Compare,_Alloc>& __y);
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-class map {
-public:
-
-// requirements:
-
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Key, _Key);
-
-// typedefs:
-
-  typedef _Key                  key_type;
-  typedef _Tp                   data_type;
-  typedef _Tp                   mapped_type;
-  typedef pair<const _Key, _Tp> value_type;
-  typedef _Compare              key_compare;
-    
-  class value_compare
-    : public binary_function<value_type, value_type, bool> {
-  friend class map<_Key,_Tp,_Compare,_Alloc>;
-  protected :
-    _Compare comp;
-    value_compare(_Compare __c) : comp(__c) {}
-  public:
-    bool operator()(const value_type& __x, const value_type& __y) const {
-      return comp(__x.first, __y.first);
-    }
-  };
-
-private:
-  typedef _Rb_tree<key_type, value_type, 
-                   _Select1st<value_type>, key_compare, _Alloc> _Rep_type;
-  _Rep_type _M_t;  // red-black tree representing map
-public:
-  typedef typename _Rep_type::pointer pointer;
-  typedef typename _Rep_type::const_pointer const_pointer;
-  typedef typename _Rep_type::reference reference;
-  typedef typename _Rep_type::const_reference const_reference;
-  typedef typename _Rep_type::iterator iterator;
-  typedef typename _Rep_type::const_iterator const_iterator;
-  typedef typename _Rep_type::reverse_iterator reverse_iterator;
-  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
-  typedef typename _Rep_type::size_type size_type;
-  typedef typename _Rep_type::difference_type difference_type;
-  typedef typename _Rep_type::allocator_type allocator_type;
-
-  // allocation/deallocation
-
-  map() : _M_t(_Compare(), allocator_type()) {}
-  explicit map(const _Compare& __comp,
-               const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) {}
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  map(_InputIterator __first, _InputIterator __last)
-    : _M_t(_Compare(), allocator_type())
-    { _M_t.insert_unique(__first, __last); }
-
-  template <class _InputIterator>
-  map(_InputIterator __first, _InputIterator __last, const _Compare& __comp,
-      const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }
-#else
-  map(const value_type* __first, const value_type* __last)
-    : _M_t(_Compare(), allocator_type())
-    { _M_t.insert_unique(__first, __last); }
-
-  map(const value_type* __first,
-      const value_type* __last, const _Compare& __comp,
-      const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }
-
-  map(const_iterator __first, const_iterator __last)
-    : _M_t(_Compare(), allocator_type()) 
-    { _M_t.insert_unique(__first, __last); }
-
-  map(const_iterator __first, const_iterator __last, const _Compare& __comp,
-      const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  map(const map<_Key,_Tp,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}
-  map<_Key,_Tp,_Compare,_Alloc>&
-  operator=(const map<_Key, _Tp, _Compare, _Alloc>& __x)
-  {
-    _M_t = __x._M_t;
-    return *this; 
-  }
-
-  // accessors:
-
-  key_compare key_comp() const { return _M_t.key_comp(); }
-  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }
-  allocator_type get_allocator() const { return _M_t.get_allocator(); }
-
-  iterator begin() { return _M_t.begin(); }
-  const_iterator begin() const { return _M_t.begin(); }
-  iterator end() { return _M_t.end(); }
-  const_iterator end() const { return _M_t.end(); }
-  reverse_iterator rbegin() { return _M_t.rbegin(); }
-  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }
-  reverse_iterator rend() { return _M_t.rend(); }
-  const_reverse_iterator rend() const { return _M_t.rend(); }
-  bool empty() const { return _M_t.empty(); }
-  size_type size() const { return _M_t.size(); }
-  size_type max_size() const { return _M_t.max_size(); }
-  _Tp& operator[](const key_type& __k) {
-    iterator __i = lower_bound(__k);
-    // __i->first is greater than or equivalent to __k.
-    if (__i == end() || key_comp()(__k, (*__i).first))
-      __i = insert(__i, value_type(__k, _Tp()));
-    return (*__i).second;
-  }
-  void swap(map<_Key,_Tp,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }
-
-  // insert/erase
-
-  pair<iterator,bool> insert(const value_type& __x) 
-    { return _M_t.insert_unique(__x); }
-  iterator insert(iterator position, const value_type& __x)
-    { return _M_t.insert_unique(position, __x); }
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  void insert(_InputIterator __first, _InputIterator __last) {
-    _M_t.insert_unique(__first, __last);
-  }
-#else
-  void insert(const value_type* __first, const value_type* __last) {
-    _M_t.insert_unique(__first, __last);
-  }
-  void insert(const_iterator __first, const_iterator __last) {
-    _M_t.insert_unique(__first, __last);
-  }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  void erase(iterator __position) { _M_t.erase(__position); }
-  size_type erase(const key_type& __x) { return _M_t.erase(__x); }
-  void erase(iterator __first, iterator __last)
-    { _M_t.erase(__first, __last); }
-  void clear() { _M_t.clear(); }
-
-  // map operations:
-
-  iterator find(const key_type& __x) { return _M_t.find(__x); }
-  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }
-  size_type count(const key_type& __x) const {
-    return _M_t.find(__x) == _M_t.end() ? 0 : 1; 
-  }
-  iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }
-  const_iterator lower_bound(const key_type& __x) const {
-    return _M_t.lower_bound(__x); 
-  }
-  iterator upper_bound(const key_type& __x) {return _M_t.upper_bound(__x); }
-  const_iterator upper_bound(const key_type& __x) const {
-    return _M_t.upper_bound(__x); 
-  }
-  
-  pair<iterator,iterator> equal_range(const key_type& __x) {
-    return _M_t.equal_range(__x);
-  }
-  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {
-    return _M_t.equal_range(__x);
-  }
-
-#ifdef __STL_TEMPLATE_FRIENDS 
-  template <class _K1, class _T1, class _C1, class _A1>
-  friend bool operator== (const map<_K1, _T1, _C1, _A1>&,
-                          const map<_K1, _T1, _C1, _A1>&);
-  template <class _K1, class _T1, class _C1, class _A1>
-  friend bool operator< (const map<_K1, _T1, _C1, _A1>&,
-                         const map<_K1, _T1, _C1, _A1>&);
-#else /* __STL_TEMPLATE_FRIENDS */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const map&, const map&);
-  friend bool __STD_QUALIFIER
-  operator< __STL_nullptr_TMPL_ARGS (const map&, const map&);
-#endif /* __STL_TEMPLATE_FRIENDS */
-};
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator==(const map<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return __x._M_t == __y._M_t;
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator<(const map<_Key,_Tp,_Compare,_Alloc>& __x, 
-                      const map<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return __x._M_t < __y._M_t;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator!=(const map<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return !(__x == __y);
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator>(const map<_Key,_Tp,_Compare,_Alloc>& __x, 
-                      const map<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return __y < __x;
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator<=(const map<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return !(__y < __x);
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator>=(const map<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const map<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return !(__x < __y);
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline void swap(map<_Key,_Tp,_Compare,_Alloc>& __x, 
-                 map<_Key,_Tp,_Compare,_Alloc>& __y) {
-  __x.swap(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_MAP_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_multimap.h b/lib/include/stl/stl_multimap.h
deleted file mode 100644
index 4f0cc90..0000000
--- a/lib/include/stl/stl_multimap.h
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_MULTIMAP_H
-#define __SGI_STL_INTERNAL_MULTIMAP_H
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-// Forward declaration of operators < and ==, needed for friend declaration.
-
-template <class _Key, class _Tp, 
-          class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less<_Key>),
-          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >
-class multimap;
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y);
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, 
-                      const multimap<_Key,_Tp,_Compare,_Alloc>& __y);
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-class multimap {
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Key, _Key);
-
-public:
-
-// typedefs:
-
-  typedef _Key                  key_type;
-  typedef _Tp                   data_type;
-  typedef _Tp                   mapped_type;
-  typedef pair<const _Key, _Tp> value_type;
-  typedef _Compare              key_compare;
-
-  class value_compare : public binary_function<value_type, value_type, bool> {
-  friend class multimap<_Key,_Tp,_Compare,_Alloc>;
-  protected:
-    _Compare comp;
-    value_compare(_Compare __c) : comp(__c) {}
-  public:
-    bool operator()(const value_type& __x, const value_type& __y) const {
-      return comp(__x.first, __y.first);
-    }
-  };
-
-private:
-  typedef _Rb_tree<key_type, value_type, 
-                  _Select1st<value_type>, key_compare, _Alloc> _Rep_type;
-  _Rep_type _M_t;  // red-black tree representing multimap
-public:
-  typedef typename _Rep_type::pointer pointer;
-  typedef typename _Rep_type::const_pointer const_pointer;
-  typedef typename _Rep_type::reference reference;
-  typedef typename _Rep_type::const_reference const_reference;
-  typedef typename _Rep_type::iterator iterator;
-  typedef typename _Rep_type::const_iterator const_iterator; 
-  typedef typename _Rep_type::reverse_iterator reverse_iterator;
-  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
-  typedef typename _Rep_type::size_type size_type;
-  typedef typename _Rep_type::difference_type difference_type;
-  typedef typename _Rep_type::allocator_type allocator_type;
-
-// allocation/deallocation
-
-  multimap() : _M_t(_Compare(), allocator_type()) { }
-  explicit multimap(const _Compare& __comp,
-                    const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { }
-
-#ifdef __STL_MEMBER_TEMPLATES  
-  template <class _InputIterator>
-  multimap(_InputIterator __first, _InputIterator __last)
-    : _M_t(_Compare(), allocator_type())
-    { _M_t.insert_equal(__first, __last); }
-
-  template <class _InputIterator>
-  multimap(_InputIterator __first, _InputIterator __last,
-           const _Compare& __comp,
-           const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }
-#else
-  multimap(const value_type* __first, const value_type* __last)
-    : _M_t(_Compare(), allocator_type())
-    { _M_t.insert_equal(__first, __last); }
-  multimap(const value_type* __first, const value_type* __last,
-           const _Compare& __comp,
-           const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }
-
-  multimap(const_iterator __first, const_iterator __last)
-    : _M_t(_Compare(), allocator_type())
-    { _M_t.insert_equal(__first, __last); }
-  multimap(const_iterator __first, const_iterator __last,
-           const _Compare& __comp,
-           const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  multimap(const multimap<_Key,_Tp,_Compare,_Alloc>& __x) : _M_t(__x._M_t) { }
-  multimap<_Key,_Tp,_Compare,_Alloc>&
-  operator=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x) {
-    _M_t = __x._M_t;
-    return *this; 
-  }
-
-  // accessors:
-
-  key_compare key_comp() const { return _M_t.key_comp(); }
-  value_compare value_comp() const { return value_compare(_M_t.key_comp()); }
-  allocator_type get_allocator() const { return _M_t.get_allocator(); }
-
-  iterator begin() { return _M_t.begin(); }
-  const_iterator begin() const { return _M_t.begin(); }
-  iterator end() { return _M_t.end(); }
-  const_iterator end() const { return _M_t.end(); }
-  reverse_iterator rbegin() { return _M_t.rbegin(); }
-  const_reverse_iterator rbegin() const { return _M_t.rbegin(); }
-  reverse_iterator rend() { return _M_t.rend(); }
-  const_reverse_iterator rend() const { return _M_t.rend(); }
-  bool empty() const { return _M_t.empty(); }
-  size_type size() const { return _M_t.size(); }
-  size_type max_size() const { return _M_t.max_size(); }
-  void swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }
-
-  // insert/erase
-
-  iterator insert(const value_type& __x) { return _M_t.insert_equal(__x); }
-  iterator insert(iterator __position, const value_type& __x) {
-    return _M_t.insert_equal(__position, __x);
-  }
-#ifdef __STL_MEMBER_TEMPLATES  
-  template <class _InputIterator>
-  void insert(_InputIterator __first, _InputIterator __last) {
-    _M_t.insert_equal(__first, __last);
-  }
-#else
-  void insert(const value_type* __first, const value_type* __last) {
-    _M_t.insert_equal(__first, __last);
-  }
-  void insert(const_iterator __first, const_iterator __last) {
-    _M_t.insert_equal(__first, __last);
-  }
-#endif /* __STL_MEMBER_TEMPLATES */
-  void erase(iterator __position) { _M_t.erase(__position); }
-  size_type erase(const key_type& __x) { return _M_t.erase(__x); }
-  void erase(iterator __first, iterator __last)
-    { _M_t.erase(__first, __last); }
-  void clear() { _M_t.clear(); }
-
-  // multimap operations:
-
-  iterator find(const key_type& __x) { return _M_t.find(__x); }
-  const_iterator find(const key_type& __x) const { return _M_t.find(__x); }
-  size_type count(const key_type& __x) const { return _M_t.count(__x); }
-  iterator lower_bound(const key_type& __x) {return _M_t.lower_bound(__x); }
-  const_iterator lower_bound(const key_type& __x) const {
-    return _M_t.lower_bound(__x); 
-  }
-  iterator upper_bound(const key_type& __x) {return _M_t.upper_bound(__x); }
-  const_iterator upper_bound(const key_type& __x) const {
-    return _M_t.upper_bound(__x); 
-  }
-   pair<iterator,iterator> equal_range(const key_type& __x) {
-    return _M_t.equal_range(__x);
-  }
-  pair<const_iterator,const_iterator> equal_range(const key_type& __x) const {
-    return _M_t.equal_range(__x);
-  }
-
-#ifdef __STL_TEMPLATE_FRIENDS 
-  template <class _K1, class _T1, class _C1, class _A1>
-  friend bool operator== (const multimap<_K1, _T1, _C1, _A1>&,
-                          const multimap<_K1, _T1, _C1, _A1>&);
-  template <class _K1, class _T1, class _C1, class _A1>
-  friend bool operator< (const multimap<_K1, _T1, _C1, _A1>&,
-                         const multimap<_K1, _T1, _C1, _A1>&);
-#else /* __STL_TEMPLATE_FRIENDS */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const multimap&, const multimap&);
-  friend bool __STD_QUALIFIER
-  operator< __STL_nullptr_TMPL_ARGS (const multimap&, const multimap&);
-#endif /* __STL_TEMPLATE_FRIENDS */
-};
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator==(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return __x._M_t == __y._M_t;
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator<(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, 
-                      const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return __x._M_t < __y._M_t;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator!=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return !(__x == __y);
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator>(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, 
-                      const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return __y < __x;
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator<=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return !(__y < __x);
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline bool operator>=(const multimap<_Key,_Tp,_Compare,_Alloc>& __x, 
-                       const multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
-  return !(__x < __y);
-}
-
-template <class _Key, class _Tp, class _Compare, class _Alloc>
-inline void swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x, 
-                 multimap<_Key,_Tp,_Compare,_Alloc>& __y) {
-  __x.swap(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_MULTIMAP_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_multiset.h b/lib/include/stl/stl_multiset.h
deleted file mode 100644
index 9d5f98e..0000000
--- a/lib/include/stl/stl_multiset.h
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_MULTISET_H
-#define __SGI_STL_INTERNAL_MULTISET_H
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-// Forward declaration of operators < and ==, needed for friend declaration.
-
-template <class _Key, class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less<_Key>),
-          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Key) >
-class multiset;
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator==(const multiset<_Key,_Compare,_Alloc>& __x, 
-                       const multiset<_Key,_Compare,_Alloc>& __y);
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x, 
-                      const multiset<_Key,_Compare,_Alloc>& __y);
-
-template <class _Key, class _Compare, class _Alloc>
-class multiset {
-  // requirements:
-  
-  __STL_CLASS_REQUIRES(_Key, _Assignable);
-  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Key, _Key);
-
-public:
-
-  // typedefs:
-
-  typedef _Key     key_type;
-  typedef _Key     value_type;
-  typedef _Compare key_compare;
-  typedef _Compare value_compare;
-private:
-  typedef _Rb_tree<key_type, value_type, 
-                  _Identity<value_type>, key_compare, _Alloc> _Rep_type;
-  _Rep_type _M_t;  // red-black tree representing multiset
-public:
-  typedef typename _Rep_type::const_pointer pointer;
-  typedef typename _Rep_type::const_pointer const_pointer;
-  typedef typename _Rep_type::const_reference reference;
-  typedef typename _Rep_type::const_reference const_reference;
-  typedef typename _Rep_type::const_iterator iterator;
-  typedef typename _Rep_type::const_iterator const_iterator;
-  typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
-  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
-  typedef typename _Rep_type::size_type size_type;
-  typedef typename _Rep_type::difference_type difference_type;
-  typedef typename _Rep_type::allocator_type allocator_type;
-
-  // allocation/deallocation
-
-  multiset() : _M_t(_Compare(), allocator_type()) {}
-  explicit multiset(const _Compare& __comp,
-                    const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) {}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  template <class _InputIterator>
-  multiset(_InputIterator __first, _InputIterator __last)
-    : _M_t(_Compare(), allocator_type())
-    { _M_t.insert_equal(__first, __last); }
-
-  template <class _InputIterator>
-  multiset(_InputIterator __first, _InputIterator __last,
-           const _Compare& __comp,
-           const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }
-
-#else
-
-  multiset(const value_type* __first, const value_type* __last)
-    : _M_t(_Compare(), allocator_type())
-    { _M_t.insert_equal(__first, __last); }
-
-  multiset(const value_type* __first, const value_type* __last,
-           const _Compare& __comp,
-           const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }
-
-  multiset(const_iterator __first, const_iterator __last)
-    : _M_t(_Compare(), allocator_type())
-    { _M_t.insert_equal(__first, __last); }
-
-  multiset(const_iterator __first, const_iterator __last,
-           const _Compare& __comp,
-           const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_equal(__first, __last); }
-   
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  multiset(const multiset<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}
-  multiset<_Key,_Compare,_Alloc>&
-  operator=(const multiset<_Key,_Compare,_Alloc>& __x) {
-    _M_t = __x._M_t; 
-    return *this;
-  }
-
-  // accessors:
-
-  key_compare key_comp() const { return _M_t.key_comp(); }
-  value_compare value_comp() const { return _M_t.key_comp(); }
-  allocator_type get_allocator() const { return _M_t.get_allocator(); }
-
-  iterator begin() const { return _M_t.begin(); }
-  iterator end() const { return _M_t.end(); }
-  reverse_iterator rbegin() const { return _M_t.rbegin(); } 
-  reverse_iterator rend() const { return _M_t.rend(); }
-  bool empty() const { return _M_t.empty(); }
-  size_type size() const { return _M_t.size(); }
-  size_type max_size() const { return _M_t.max_size(); }
-  void swap(multiset<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }
-
-  // insert/erase
-  iterator insert(const value_type& __x) { 
-    return _M_t.insert_equal(__x);
-  }
-  iterator insert(iterator __position, const value_type& __x) {
-    typedef typename _Rep_type::iterator _Rep_iterator;
-    return _M_t.insert_equal((_Rep_iterator&)__position, __x);
-  }
-
-#ifdef __STL_MEMBER_TEMPLATES  
-  template <class _InputIterator>
-  void insert(_InputIterator __first, _InputIterator __last) {
-    _M_t.insert_equal(__first, __last);
-  }
-#else
-  void insert(const value_type* __first, const value_type* __last) {
-    _M_t.insert_equal(__first, __last);
-  }
-  void insert(const_iterator __first, const_iterator __last) {
-    _M_t.insert_equal(__first, __last);
-  }
-#endif /* __STL_MEMBER_TEMPLATES */
-  void erase(iterator __position) { 
-    typedef typename _Rep_type::iterator _Rep_iterator;
-    _M_t.erase((_Rep_iterator&)__position); 
-  }
-  size_type erase(const key_type& __x) { 
-    return _M_t.erase(__x); 
-  }
-  void erase(iterator __first, iterator __last) { 
-    typedef typename _Rep_type::iterator _Rep_iterator;
-    _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); 
-  }
-  void clear() { _M_t.clear(); }
-
-  // multiset operations:
-
-  iterator find(const key_type& __x) const { return _M_t.find(__x); }
-  size_type count(const key_type& __x) const { return _M_t.count(__x); }
-  iterator lower_bound(const key_type& __x) const {
-    return _M_t.lower_bound(__x);
-  }
-  iterator upper_bound(const key_type& __x) const {
-    return _M_t.upper_bound(__x); 
-  }
-  pair<iterator,iterator> equal_range(const key_type& __x) const {
-    return _M_t.equal_range(__x);
-  }
-
-#ifdef __STL_TEMPLATE_FRIENDS
-  template <class _K1, class _C1, class _A1>
-  friend bool operator== (const multiset<_K1,_C1,_A1>&,
-                          const multiset<_K1,_C1,_A1>&);
-  template <class _K1, class _C1, class _A1>
-  friend bool operator< (const multiset<_K1,_C1,_A1>&,
-                         const multiset<_K1,_C1,_A1>&);
-#else /* __STL_TEMPLATE_FRIENDS */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const multiset&, const multiset&);
-  friend bool __STD_QUALIFIER
-  operator< __STL_nullptr_TMPL_ARGS (const multiset&, const multiset&);
-#endif /* __STL_TEMPLATE_FRIENDS */
-};
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator==(const multiset<_Key,_Compare,_Alloc>& __x, 
-                       const multiset<_Key,_Compare,_Alloc>& __y) {
-  return __x._M_t == __y._M_t;
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator<(const multiset<_Key,_Compare,_Alloc>& __x, 
-                      const multiset<_Key,_Compare,_Alloc>& __y) {
-  return __x._M_t < __y._M_t;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator!=(const multiset<_Key,_Compare,_Alloc>& __x, 
-                       const multiset<_Key,_Compare,_Alloc>& __y) {
-  return !(__x == __y);
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator>(const multiset<_Key,_Compare,_Alloc>& __x, 
-                      const multiset<_Key,_Compare,_Alloc>& __y) {
-  return __y < __x;
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator<=(const multiset<_Key,_Compare,_Alloc>& __x, 
-                       const multiset<_Key,_Compare,_Alloc>& __y) {
-  return !(__y < __x);
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator>=(const multiset<_Key,_Compare,_Alloc>& __x, 
-                       const multiset<_Key,_Compare,_Alloc>& __y) {
-  return !(__x < __y);
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline void swap(multiset<_Key,_Compare,_Alloc>& __x, 
-                 multiset<_Key,_Compare,_Alloc>& __y) {
-  __x.swap(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_MULTISET_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_numeric.h b/lib/include/stl/stl_numeric.h
deleted file mode 100644
index f8e9594..0000000
--- a/lib/include/stl/stl_numeric.h
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-
-#ifndef __SGI_STL_INTERNAL_NUMERIC_H
-#define __SGI_STL_INTERNAL_NUMERIC_H
-
-__STL_BEGIN_NAMESPACE
-
-template <class _InputIterator, class _Tp>
-_Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
-{
-  __STL_REQUIRES(_InputIterator, _InputIterator);
-  for ( ; __first != __last; ++__first)
-    __init = __init + *__first;
-  return __init;
-}
-
-template <class _InputIterator, class _Tp, class _BinaryOperation>
-_Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
-               _BinaryOperation __binary_op)
-{
-  __STL_REQUIRES(_InputIterator, _InputIterator);
-  for ( ; __first != __last; ++__first)
-    __init = __binary_op(__init, *__first);
-  return __init;
-}
-
-template <class _InputIterator1, class _InputIterator2, class _Tp>
-_Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
-                  _InputIterator2 __first2, _Tp __init)
-{
-  __STL_REQUIRES(_InputIterator2, _InputIterator);
-  __STL_REQUIRES(_InputIterator2, _InputIterator);
-  for ( ; __first1 != __last1; ++__first1, ++__first2)
-    __init = __init + (*__first1 * *__first2);
-  return __init;
-}
-
-template <class _InputIterator1, class _InputIterator2, class _Tp,
-          class _BinaryOperation1, class _BinaryOperation2>
-_Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
-                  _InputIterator2 __first2, _Tp __init, 
-                  _BinaryOperation1 __binary_op1,
-                  _BinaryOperation2 __binary_op2)
-{
-  __STL_REQUIRES(_InputIterator2, _InputIterator);
-  __STL_REQUIRES(_InputIterator2, _InputIterator);
-  for ( ; __first1 != __last1; ++__first1, ++__first2)
-    __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
-  return __init;
-}
-
-template <class _InputIterator, class _OutputIterator, class _Tp>
-_OutputIterator 
-__partial_sum(_InputIterator __first, _InputIterator __last,
-              _OutputIterator __result, _Tp*)
-{
-  _Tp __value = *__first;
-  while (++__first != __last) {
-    __value = __value + *__first;
-    *++__result = __value;
-  }
-  return ++__result;
-}
-
-template <class _InputIterator, class _OutputIterator>
-_OutputIterator 
-partial_sum(_InputIterator __first, _InputIterator __last,
-            _OutputIterator __result)
-{
-  __STL_REQUIRES(_InputIterator, _InputIterator);
-  __STL_REQUIRES(_OutputIterator, _OutputIterator);
-  if (__first == __last) return __result;
-  *__result = *__first;
-  return __partial_sum(__first, __last, __result, __VALUE_TYPE(__first));
-}
-
-template <class _InputIterator, class _OutputIterator, class _Tp,
-          class _BinaryOperation>
-_OutputIterator 
-__partial_sum(_InputIterator __first, _InputIterator __last, 
-              _OutputIterator __result, _Tp*, _BinaryOperation __binary_op)
-{
-  _Tp __value = *__first;
-  while (++__first != __last) {
-    __value = __binary_op(__value, *__first);
-    *++__result = __value;
-  }
-  return ++__result;
-}
-
-template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
-_OutputIterator 
-partial_sum(_InputIterator __first, _InputIterator __last,
-            _OutputIterator __result, _BinaryOperation __binary_op)
-{
-  __STL_REQUIRES(_InputIterator, _InputIterator);
-  __STL_REQUIRES(_OutputIterator, _OutputIterator);
-  if (__first == __last) return __result;
-  *__result = *__first;
-  return __partial_sum(__first, __last, __result, __VALUE_TYPE(__first), 
-                       __binary_op);
-}
-
-template <class _InputIterator, class _OutputIterator, class _Tp>
-_OutputIterator 
-__adjacent_difference(_InputIterator __first, _InputIterator __last,
-                      _OutputIterator __result, _Tp*)
-{
-  _Tp __value = *__first;
-  while (++__first != __last) {
-    _Tp __tmp = *__first;
-    *++__result = __tmp - __value;
-    __value = __tmp;
-  }
-  return ++__result;
-}
-
-template <class _InputIterator, class _OutputIterator>
-_OutputIterator
-adjacent_difference(_InputIterator __first,
-                    _InputIterator __last, _OutputIterator __result)
-{
-  __STL_REQUIRES(_InputIterator, _InputIterator);
-  __STL_REQUIRES(_OutputIterator, _OutputIterator);
-  if (__first == __last) return __result;
-  *__result = *__first;
-  return __adjacent_difference(__first, __last, __result,
-                               __VALUE_TYPE(__first));
-}
-
-template <class _InputIterator, class _OutputIterator, class _Tp, 
-          class _BinaryOperation>
-_OutputIterator
-__adjacent_difference(_InputIterator __first, _InputIterator __last, 
-                      _OutputIterator __result, _Tp*,
-                      _BinaryOperation __binary_op) {
-  _Tp __value = *__first;
-  while (++__first != __last) {
-    _Tp __tmp = *__first;
-    *++__result = __binary_op(__tmp, __value);
-    __value = __tmp;
-  }
-  return ++__result;
-}
-
-template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
-_OutputIterator 
-adjacent_difference(_InputIterator __first, _InputIterator __last,
-                    _OutputIterator __result, _BinaryOperation __binary_op)
-{
-  __STL_REQUIRES(_InputIterator, _InputIterator);
-  __STL_REQUIRES(_OutputIterator, _OutputIterator);
-  if (__first == __last) return __result;
-  *__result = *__first;
-  return __adjacent_difference(__first, __last, __result,
-                               __VALUE_TYPE(__first),
-                               __binary_op);
-}
-
-// Returns __x ** __n, where __n >= 0.  _Note that "multiplication"
-// is required to be associative, but not necessarily commutative.
-
- 
-template <class _Tp, class _Integer, class _MonoidOperation>
-_Tp __power(_Tp __x, _Integer __n, _MonoidOperation __opr)
-{
-  if (__n == 0)
-    return identity_element(__opr);
-  else {
-    while ((__n & 1) == 0) {
-      __n >>= 1;
-      __x = __opr(__x, __x);
-    }
-
-    _Tp __result = __x;
-    __n >>= 1;
-    while (__n != 0) {
-      __x = __opr(__x, __x);
-      if ((__n & 1) != 0)
-        __result = __opr(__result, __x);
-      __n >>= 1;
-    }
-    return __result;
-  }
-}
-
-template <class _Tp, class _Integer>
-inline _Tp __power(_Tp __x, _Integer __n)
-{
-  return __power(__x, __n, multiplies<_Tp>());
-}
-
-// Alias for the internal name __power.  Note that power is an extension,
-// not part of the C++ standard.
-
-template <class _Tp, class _Integer, class _MonoidOperation>
-inline _Tp power(_Tp __x, _Integer __n, _MonoidOperation __opr)
-{
-  return __power(__x, __n, __opr);
-}
-
-template <class _Tp, class _Integer>
-inline _Tp power(_Tp __x, _Integer __n)
-{
-  return __power(__x, __n);
-}
-
-// iota is not part of the C++ standard.  It is an extension.
-
-template <class _ForwardIter, class _Tp>
-void 
-iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)
-{
-  __STL_REQUIRES(_ForwardIter, _Mutable_ForwardIterator);
-  __STL_CONVERTIBLE(_Tp, typename iterator_traits<_ForwardIter>::value_type);
-  while (__first != __last)
-    *__first++ = __value++;
-}
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_NUMERIC_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_pair.h b/lib/include/stl/stl_pair.h
deleted file mode 100644
index a6155a6..0000000
--- a/lib/include/stl/stl_pair.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_PAIR_H
-#define __SGI_STL_INTERNAL_PAIR_H
-
-__STL_BEGIN_NAMESPACE
-
-template <class _T1, class _T2>
-struct pair {
-  typedef _T1 first_type;
-  typedef _T2 second_type;
-
-  _T1 first;
-  _T2 second;
-  pair() : first(_T1()), second(_T2()) {}
-  pair(const _T1& __a, const _T2& __b) : first(__a), second(__b) {}
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _U1, class _U2>
-  pair(const pair<_U1, _U2>& __p) : first(__p.first), second(__p.second) {}
-#endif
-};
-
-template <class _T1, class _T2>
-inline bool operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
-{ 
-  return __x.first == __y.first && __x.second == __y.second; 
-}
-
-template <class _T1, class _T2>
-inline bool operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
-{ 
-  return __x.first < __y.first || 
-         (!(__y.first < __x.first) && __x.second < __y.second); 
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _T1, class _T2>
-inline bool operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
-  return !(__x == __y);
-}
-
-template <class _T1, class _T2>
-inline bool operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
-  return __y < __x;
-}
-
-template <class _T1, class _T2>
-inline bool operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
-  return !(__y < __x);
-}
-
-template <class _T1, class _T2>
-inline bool operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y) {
-  return !(__x < __y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-template <class _T1, class _T2>
-inline pair<_T1, _T2> make_pair(const _T1& __x, const _T2& __y)
-{
-  return pair<_T1, _T2>(__x, __y);
-}
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_PAIR_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_queue.h b/lib/include/stl/stl_queue.h
deleted file mode 100644
index 02bc8e2..0000000
--- a/lib/include/stl/stl_queue.h
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_QUEUE_H
-#define __SGI_STL_INTERNAL_QUEUE_H
-
-#include <sequence_concepts.h>
-
-__STL_BEGIN_NAMESPACE
-
-// Forward declarations of operators < and ==, needed for friend declaration.
-
-template <class _Tp, 
-          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque<_Tp>) >
-class queue;
-
-template <class _Tp, class _Seq>
-inline bool operator==(const queue<_Tp, _Seq>&, const queue<_Tp, _Seq>&);
-
-template <class _Tp, class _Seq>
-inline bool operator<(const queue<_Tp, _Seq>&, const queue<_Tp, _Seq>&);
-
-
-template <class _Tp, class _Sequence>
-class queue {
-
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-  __STL_CLASS_REQUIRES(_Sequence, _FrontInsertionSequence);
-  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);
-  typedef typename _Sequence::value_type _Sequence_value_type;
-  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);
-
-
-#ifdef __STL_MEMBER_TEMPLATES 
-  template <class _Tp1, class _Seq1>
-  friend bool operator== (const queue<_Tp1, _Seq1>&,
-                          const queue<_Tp1, _Seq1>&);
-  template <class _Tp1, class _Seq1>
-  friend bool operator< (const queue<_Tp1, _Seq1>&,
-                         const queue<_Tp1, _Seq1>&);
-#else /* __STL_MEMBER_TEMPLATES */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const queue&, const queue&);
-  friend bool __STD_QUALIFIER
-  operator<  __STL_nullptr_TMPL_ARGS (const queue&, const queue&);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:
-  typedef typename _Sequence::value_type      value_type;
-  typedef typename _Sequence::size_type       size_type;
-  typedef          _Sequence                  container_type;
-
-  typedef typename _Sequence::reference       reference;
-  typedef typename _Sequence::const_reference const_reference;
-protected:
-  _Sequence c;
-public:
-  queue() : c() {}
-  explicit queue(const _Sequence& __c) : c(__c) {}
-
-  bool empty() const { return c.empty(); }
-  size_type size() const { return c.size(); }
-  reference front() { return c.front(); }
-  const_reference front() const { return c.front(); }
-  reference back() { return c.back(); }
-  const_reference back() const { return c.back(); }
-  void push(const value_type& __x) { c.push_back(__x); }
-  void pop() { c.pop_front(); }
-};
-
-template <class _Tp, class _Sequence>
-bool 
-operator==(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)
-{
-  return __x.c == __y.c;
-}
-
-template <class _Tp, class _Sequence>
-bool
-operator<(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)
-{
-  return __x.c < __y.c;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Tp, class _Sequence>
-bool
-operator!=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)
-{
-  return !(__x == __y);
-}
-
-template <class _Tp, class _Sequence>
-bool 
-operator>(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)
-{
-  return __y < __x;
-}
-
-template <class _Tp, class _Sequence>
-bool 
-operator<=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)
-{
-  return !(__y < __x);
-}
-
-template <class _Tp, class _Sequence>
-bool 
-operator>=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)
-{
-  return !(__x < __y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-template <class _Tp, 
-          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(vector<_Tp>),
-          class _Compare
-          __STL_DEPENDENT_DEFAULT_TMPL(less<typename _Sequence::value_type>) >
-class priority_queue {
-
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-  __STL_CLASS_REQUIRES(_Sequence, _Sequence);
-  __STL_CLASS_REQUIRES(_Sequence, _RandomAccessContainer);
-  typedef typename _Sequence::value_type _Sequence_value_type;
-  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);
-  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Tp, _Tp);
-
-public:
-  typedef typename _Sequence::value_type      value_type;
-  typedef typename _Sequence::size_type       size_type;
-  typedef          _Sequence                  container_type;
-
-  typedef typename _Sequence::reference       reference;
-  typedef typename _Sequence::const_reference const_reference;
-protected:
-  _Sequence c;
-  _Compare comp;
-public:
-  priority_queue() : c() {}
-  explicit priority_queue(const _Compare& __x) :  c(), comp(__x) {}
-  priority_queue(const _Compare& __x, const _Sequence& __s) 
-    : c(__s), comp(__x) 
-    { make_heap(c.begin(), c.end(), comp); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  priority_queue(_InputIterator __first, _InputIterator __last) 
-    : c(__first, __last) { make_heap(c.begin(), c.end(), comp); }
-
-  template <class _InputIterator>
-  priority_queue(_InputIterator __first, 
-                 _InputIterator __last, const _Compare& __x)
-    : c(__first, __last), comp(__x) 
-    { make_heap(c.begin(), c.end(), comp); }
-
-  template <class _InputIterator>
-  priority_queue(_InputIterator __first, _InputIterator __last,
-                 const _Compare& __x, const _Sequence& __s)
-  : c(__s), comp(__x)
-  { 
-    c.insert(c.end(), __first, __last);
-    make_heap(c.begin(), c.end(), comp);
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-  priority_queue(const value_type* __first, const value_type* __last) 
-    : c(__first, __last) { make_heap(c.begin(), c.end(), comp); }
-
-  priority_queue(const value_type* __first, const value_type* __last, 
-                 const _Compare& __x) 
-    : c(__first, __last), comp(__x)
-    { make_heap(c.begin(), c.end(), comp); }
-
-  priority_queue(const value_type* __first, const value_type* __last, 
-                 const _Compare& __x, const _Sequence& __c)
-    : c(__c), comp(__x) 
-  { 
-    c.insert(c.end(), __first, __last);
-    make_heap(c.begin(), c.end(), comp);
-  }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  bool empty() const { return c.empty(); }
-  size_type size() const { return c.size(); }
-  const_reference top() const { return c.front(); }
-  void push(const value_type& __x) {
-    __STL_TRY {
-      c.push_back(__x); 
-      push_heap(c.begin(), c.end(), comp);
-    }
-    __STL_UNWIND(c.clear());
-  }
-  void pop() {
-    __STL_TRY {
-      pop_heap(c.begin(), c.end(), comp);
-      c.pop_back();
-    }
-    __STL_UNWIND(c.clear());
-  }
-};
-
-// no equality is provided
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_QUEUE_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_range_errors.h b/lib/include/stl/stl_range_errors.h
deleted file mode 100644
index 3ddde6d..0000000
--- a/lib/include/stl/stl_range_errors.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (c) 1999
- * Silicon Graphics
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef __STL_RANGE_ERRORS_H
-#define __STL_RANGE_ERRORS_H
-
-// A few places in the STL throw range errors, using standard exception
-// classes defined in <stdexcept>.  This header file provides functions
-// to throw those exception objects.
-
-// __STL_DONT_THROW_RANGE_ERRORS is a hook so that users can disable
-// this exception throwing.
-
-#include <stl_config.h>
-
-#if defined(__STL_CAN_THROW_RANGE_ERRORS) && \
-    defined(__STL_USE_EXCEPTIONS) && \
-    !defined(__STL_DONT_THROW_RANGE_ERRORS)
-# define __STL_THROW_RANGE_ERRORS
-#endif
-
-// For the SGI 7.3 compiler, declare these functions here and define them
-// elsewhere.
-#if defined(__STL_THROW_RANGE_ERRORS) && \
-    defined(__sgi) && !defined(__GNUC__) && \
-    _COMPILER_VERSION >= 730 && defined(_STANDARD_C_PLUS_PLUS)
-
-__STL_BEGIN_NAMESPACE
-void __stl_throw_range_error(const char* __msg);
-void __stl_throw_length_error(const char* __msg);
-__STL_END_NAMESPACE
-
-// For other compilers where we're throwing range errors, include the
-// stdexcept header and throw the appropriate exceptions directly.
-#elif defined(__STL_THROW_RANGE_ERRORS)
-
-#include <stdexcept>
-
-__STL_BEGIN_NAMESPACE
-inline void __stl_throw_range_error(const char* __msg) 
-  { throw range_error(__msg); }
-inline void __stl_throw_length_error(const char* __msg)
-  { throw length_error(__msg); }
-__STL_END_NAMESPACE
-
-// Otherwise, define inline functions that do nothing.
-#else 
-
-__STL_BEGIN_NAMESPACE
-inline void __stl_throw_range_error(const char*) {}
-inline void __stl_throw_length_error(const char*) {}
-__STL_END_NAMESPACE
-
-#endif
-
-#endif /* __STL_RANGE_ERRORS_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_raw_storage_iter.h b/lib/include/stl/stl_raw_storage_iter.h
deleted file mode 100644
index 6f3951c..0000000
--- a/lib/include/stl/stl_raw_storage_iter.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- * You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H
-#define __SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H
-
-__STL_BEGIN_NAMESPACE
-
-template <class _ForwardIterator, class _Tp>
-class raw_storage_iterator {
-protected:
-  _ForwardIterator _M_iter;
-public:
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  explicit raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}
-  raw_storage_iterator& operator*() { return *this; }
-  raw_storage_iterator& operator=(const _Tp& __element) {
-    construct(&*_M_iter, __element);
-    return *this;
-  }        
-  raw_storage_iterator<_ForwardIterator, _Tp>& operator++() {
-    ++_M_iter;
-    return *this;
-  }
-  raw_storage_iterator<_ForwardIterator, _Tp> operator++(int) {
-    raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;
-    ++_M_iter;
-    return __tmp;
-  }
-};
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _ForwardIterator, class _Tp>
-inline output_iterator_tag
-iterator_category(const raw_storage_iterator<_ForwardIterator, _Tp>&)
-{
-  return output_iterator_tag();
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_relops.h b/lib/include/stl/stl_relops.h
deleted file mode 100644
index 16cad1b..0000000
--- a/lib/include/stl/stl_relops.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_RELOPS
-#define __SGI_STL_INTERNAL_RELOPS
-
-__STL_BEGIN_RELOPS_NAMESPACE
-
-template <class _Tp>
-inline bool operator!=(const _Tp& __x, const _Tp& __y) {
-  return !(__x == __y);
-}
-
-template <class _Tp>
-inline bool operator>(const _Tp& __x, const _Tp& __y) {
-  return __y < __x;
-}
-
-template <class _Tp>
-inline bool operator<=(const _Tp& __x, const _Tp& __y) {
-  return !(__y < __x);
-}
-
-template <class _Tp>
-inline bool operator>=(const _Tp& __x, const _Tp& __y) {
-  return !(__x < __y);
-}
-
-__STL_END_RELOPS_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_RELOPS */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_set.h b/lib/include/stl/stl_set.h
deleted file mode 100644
index a935b72..0000000
--- a/lib/include/stl/stl_set.h
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_SET_H
-#define __SGI_STL_INTERNAL_SET_H
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-// Forward declarations of operators < and ==, needed for friend declaration.
-
-template <class _Key, class _Compare __STL_DEPENDENT_DEFAULT_TMPL(less<_Key>),
-          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Key) >
-class set;
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator==(const set<_Key,_Compare,_Alloc>& __x, 
-                       const set<_Key,_Compare,_Alloc>& __y);
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator<(const set<_Key,_Compare,_Alloc>& __x, 
-                      const set<_Key,_Compare,_Alloc>& __y);
-
-
-template <class _Key, class _Compare, class _Alloc>
-class set {
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Key, _Assignable);
-  __STL_CLASS_BINARY_FUNCTION_CHECK(_Compare, bool, _Key, _Key);
-
-public:
-  // typedefs:
-
-  typedef _Key     key_type;
-  typedef _Key     value_type;
-  typedef _Compare key_compare;
-  typedef _Compare value_compare;
-private:
-  typedef _Rb_tree<key_type, value_type, 
-                  _Identity<value_type>, key_compare, _Alloc> _Rep_type;
-  _Rep_type _M_t;  // red-black tree representing set
-public:
-  typedef typename _Rep_type::const_pointer pointer;
-  typedef typename _Rep_type::const_pointer const_pointer;
-  typedef typename _Rep_type::const_reference reference;
-  typedef typename _Rep_type::const_reference const_reference;
-  typedef typename _Rep_type::const_iterator iterator;
-  typedef typename _Rep_type::const_iterator const_iterator;
-  typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
-  typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
-  typedef typename _Rep_type::size_type size_type;
-  typedef typename _Rep_type::difference_type difference_type;
-  typedef typename _Rep_type::allocator_type allocator_type;
-
-  // allocation/deallocation
-
-  set() : _M_t(_Compare(), allocator_type()) {}
-  explicit set(const _Compare& __comp,
-               const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) {}
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  set(_InputIterator __first, _InputIterator __last)
-    : _M_t(_Compare(), allocator_type())
-    { _M_t.insert_unique(__first, __last); }
-
-  template <class _InputIterator>
-  set(_InputIterator __first, _InputIterator __last, const _Compare& __comp,
-      const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }
-#else
-  set(const value_type* __first, const value_type* __last) 
-    : _M_t(_Compare(), allocator_type()) 
-    { _M_t.insert_unique(__first, __last); }
-
-  set(const value_type* __first, 
-      const value_type* __last, const _Compare& __comp,
-      const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }
-
-  set(const_iterator __first, const_iterator __last)
-    : _M_t(_Compare(), allocator_type()) 
-    { _M_t.insert_unique(__first, __last); }
-
-  set(const_iterator __first, const_iterator __last, const _Compare& __comp,
-      const allocator_type& __a = allocator_type())
-    : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  set(const set<_Key,_Compare,_Alloc>& __x) : _M_t(__x._M_t) {}
-  set<_Key,_Compare,_Alloc>& operator=(const set<_Key, _Compare, _Alloc>& __x)
-  { 
-    _M_t = __x._M_t; 
-    return *this;
-  }
-
-  // accessors:
-
-  key_compare key_comp() const { return _M_t.key_comp(); }
-  value_compare value_comp() const { return _M_t.key_comp(); }
-  allocator_type get_allocator() const { return _M_t.get_allocator(); }
-
-  iterator begin() const { return _M_t.begin(); }
-  iterator end() const { return _M_t.end(); }
-  reverse_iterator rbegin() const { return _M_t.rbegin(); } 
-  reverse_iterator rend() const { return _M_t.rend(); }
-  bool empty() const { return _M_t.empty(); }
-  size_type size() const { return _M_t.size(); }
-  size_type max_size() const { return _M_t.max_size(); }
-  void swap(set<_Key,_Compare,_Alloc>& __x) { _M_t.swap(__x._M_t); }
-
-  // insert/erase
-  pair<iterator,bool> insert(const value_type& __x) { 
-    pair<typename _Rep_type::iterator, bool> __p = _M_t.insert_unique(__x); 
-    return pair<iterator, bool>(__p.first, __p.second);
-  }
-  iterator insert(iterator __position, const value_type& __x) {
-    typedef typename _Rep_type::iterator _Rep_iterator;
-    return _M_t.insert_unique((_Rep_iterator&)__position, __x);
-  }
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  void insert(_InputIterator __first, _InputIterator __last) {
-    _M_t.insert_unique(__first, __last);
-  }
-#else
-  void insert(const_iterator __first, const_iterator __last) {
-    _M_t.insert_unique(__first, __last);
-  }
-  void insert(const value_type* __first, const value_type* __last) {
-    _M_t.insert_unique(__first, __last);
-  }
-#endif /* __STL_MEMBER_TEMPLATES */
-  void erase(iterator __position) { 
-    typedef typename _Rep_type::iterator _Rep_iterator;
-    _M_t.erase((_Rep_iterator&)__position); 
-  }
-  size_type erase(const key_type& __x) { 
-    return _M_t.erase(__x); 
-  }
-  void erase(iterator __first, iterator __last) { 
-    typedef typename _Rep_type::iterator _Rep_iterator;
-    _M_t.erase((_Rep_iterator&)__first, (_Rep_iterator&)__last); 
-  }
-  void clear() { _M_t.clear(); }
-
-  // set operations:
-
-  iterator find(const key_type& __x) const { return _M_t.find(__x); }
-  size_type count(const key_type& __x) const {
-    return _M_t.find(__x) == _M_t.end() ? 0 : 1;
-  }
-  iterator lower_bound(const key_type& __x) const {
-    return _M_t.lower_bound(__x);
-  }
-  iterator upper_bound(const key_type& __x) const {
-    return _M_t.upper_bound(__x); 
-  }
-  pair<iterator,iterator> equal_range(const key_type& __x) const {
-    return _M_t.equal_range(__x);
-  }
-
-#ifdef __STL_TEMPLATE_FRIENDS
-  template <class _K1, class _C1, class _A1>
-  friend bool operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);
-  template <class _K1, class _C1, class _A1>
-  friend bool operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);
-#else /* __STL_TEMPLATE_FRIENDS */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const set&, const set&);
-  friend bool __STD_QUALIFIER
-  operator<  __STL_nullptr_TMPL_ARGS (const set&, const set&);
-#endif /* __STL_TEMPLATE_FRIENDS */
-};
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator==(const set<_Key,_Compare,_Alloc>& __x, 
-                       const set<_Key,_Compare,_Alloc>& __y) {
-  return __x._M_t == __y._M_t;
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator<(const set<_Key,_Compare,_Alloc>& __x, 
-                      const set<_Key,_Compare,_Alloc>& __y) {
-  return __x._M_t < __y._M_t;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator!=(const set<_Key,_Compare,_Alloc>& __x, 
-                       const set<_Key,_Compare,_Alloc>& __y) {
-  return !(__x == __y);
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator>(const set<_Key,_Compare,_Alloc>& __x, 
-                      const set<_Key,_Compare,_Alloc>& __y) {
-  return __y < __x;
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator<=(const set<_Key,_Compare,_Alloc>& __x, 
-                       const set<_Key,_Compare,_Alloc>& __y) {
-  return !(__y < __x);
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline bool operator>=(const set<_Key,_Compare,_Alloc>& __x, 
-                       const set<_Key,_Compare,_Alloc>& __y) {
-  return !(__x < __y);
-}
-
-template <class _Key, class _Compare, class _Alloc>
-inline void swap(set<_Key,_Compare,_Alloc>& __x, 
-                 set<_Key,_Compare,_Alloc>& __y) {
-  __x.swap(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_SET_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_slist.h b/lib/include/stl/stl_slist.h
deleted file mode 100644
index aeec658..0000000
--- a/lib/include/stl/stl_slist.h
+++ /dev/null
@@ -1,1048 +0,0 @@
-/*
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_SLIST_H
-#define __SGI_STL_INTERNAL_SLIST_H
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE 
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-struct _Slist_node_base
-{
-  _Slist_node_base* _M_next;
-};
-
-inline _Slist_node_base*
-__slist_make_link(_Slist_node_base* __prev_node,
-                  _Slist_node_base* __new_node)
-{
-  __new_node->_M_next = __prev_node->_M_next;
-  __prev_node->_M_next = __new_node;
-  return __new_node;
-}
-
-inline _Slist_node_base* 
-__slist_previous(_Slist_node_base* __head,
-                 const _Slist_node_base* __node)
-{
-  while (__head && __head->_M_next != __node)
-    __head = __head->_M_next;
-  return __head;
-}
-
-inline const _Slist_node_base* 
-__slist_previous(const _Slist_node_base* __head,
-                 const _Slist_node_base* __node)
-{
-  while (__head && __head->_M_next != __node)
-    __head = __head->_M_next;
-  return __head;
-}
-
-inline void __slist_splice_after(_Slist_node_base* __pos,
-                                 _Slist_node_base* __before_first,
-                                 _Slist_node_base* __before_last)
-{
-  if (__pos != __before_first && __pos != __before_last) {
-    _Slist_node_base* __first = __before_first->_M_next;
-    _Slist_node_base* __after = __pos->_M_next;
-    __before_first->_M_next = __before_last->_M_next;
-    __pos->_M_next = __first;
-    __before_last->_M_next = __after;
-  }
-}
-
-inline void
-__slist_splice_after(_Slist_node_base* __pos, _Slist_node_base* __head)
-{
-  _Slist_node_base* __before_last = __slist_previous(__head, 0);
-  if (__before_last != __head) {
-    _Slist_node_base* __after = __pos->_M_next;
-    __pos->_M_next = __head->_M_next;
-    __head->_M_next = 0;
-    __before_last->_M_next = __after;
-  }
-}
-
-inline _Slist_node_base* __slist_reverse(_Slist_node_base* __node)
-{
-  _Slist_node_base* __result = __node;
-  __node = __node->_M_next;
-  __result->_M_next = 0;
-  while(__node) {
-    _Slist_node_base* __next = __node->_M_next;
-    __node->_M_next = __result;
-    __result = __node;
-    __node = __next;
-  }
-  return __result;
-}
-
-inline size_t __slist_size(_Slist_node_base* __node)
-{
-  size_t __result = 0;
-  for ( ; __node != 0; __node = __node->_M_next)
-    ++__result;
-  return __result;
-}
-
-template <class _Tp>
-struct _Slist_node : public _Slist_node_base
-{
-  _Tp _M_data;
-};
-
-struct _Slist_iterator_base
-{
-  typedef size_t               size_type;
-  typedef ptrdiff_t            difference_type;
-  typedef forward_iterator_tag iterator_category;
-
-  _Slist_node_base* _M_node;
-
-  _Slist_iterator_base(_Slist_node_base* __x) : _M_node(__x) {}
-  void _M_incr() { _M_node = _M_node->_M_next; }
-
-  bool operator==(const _Slist_iterator_base& __x) const {
-    return _M_node == __x._M_node;
-  }
-  bool operator!=(const _Slist_iterator_base& __x) const {
-    return _M_node != __x._M_node;
-  }
-};
-
-template <class _Tp, class _Ref, class _Ptr>
-struct _Slist_iterator : public _Slist_iterator_base
-{
-  typedef _Slist_iterator<_Tp, _Tp&, _Tp*>             iterator;
-  typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
-  typedef _Slist_iterator<_Tp, _Ref, _Ptr>             _Self;
-
-  typedef _Tp              value_type;
-  typedef _Ptr             pointer;
-  typedef _Ref             reference;
-  typedef _Slist_node<_Tp> _Node;
-
-  _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) {}
-  _Slist_iterator() : _Slist_iterator_base(0) {}
-  _Slist_iterator(const iterator& __x) : _Slist_iterator_base(__x._M_node) {}
-
-  reference operator*() const { return ((_Node*) _M_node)->_M_data; }
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return &(operator*()); }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-
-  _Self& operator++()
-  {
-    _M_incr();
-    return *this;
-  }
-  _Self operator++(int)
-  {
-    _Self __tmp = *this;
-    _M_incr();
-    return __tmp;
-  }
-};
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-inline ptrdiff_t* distance_type(const _Slist_iterator_base&) {
-  return 0;
-}
-
-inline forward_iterator_tag iterator_category(const _Slist_iterator_base&) {
-  return forward_iterator_tag();
-}
-
-template <class _Tp, class _Ref, class _Ptr> 
-inline _Tp* value_type(const _Slist_iterator<_Tp, _Ref, _Ptr>&) {
-  return 0;
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-// Base class that encapsulates details of allocators.  Three cases:
-// an ordinary standard-conforming allocator, a standard-conforming
-// allocator with no non-static data, and an SGI-style allocator.
-// This complexity is necessary only because we're worrying about backward
-// compatibility and because we want to avoid wasting storage on an 
-// allocator instance if it isn't necessary.
-
-#ifdef __STL_USE_STD_ALLOCATORS
-
-// Base for general standard-conforming allocators.
-template <class _Tp, class _Allocator, bool _IsStatic>
-class _Slist_alloc_base {
-public:
-  typedef typename _Alloc_traits<_Tp,_Allocator>::allocator_type
-          allocator_type;
-  allocator_type get_allocator() const { return _M_node_allocator; }
-
-  _Slist_alloc_base(const allocator_type& __a) : _M_node_allocator(__a) {}
-
-protected:
-  _Slist_node<_Tp>* _M_get_node() 
-    { return _M_node_allocator.allocate(1); }
-  void _M_put_node(_Slist_node<_Tp>* __p) 
-    { _M_node_allocator.deallocate(__p, 1); }
-
-protected:
-  typename _Alloc_traits<_Slist_node<_Tp>,_Allocator>::allocator_type
-           _M_node_allocator;
-  _Slist_node_base _M_head;
-};
-
-// Specialization for instanceless allocators.
-template <class _Tp, class _Allocator>
-class _Slist_alloc_base<_Tp,_Allocator, true> {
-public:
-  typedef typename _Alloc_traits<_Tp,_Allocator>::allocator_type
-          allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Slist_alloc_base(const allocator_type&) {}
-
-protected:
-  typedef typename _Alloc_traits<_Slist_node<_Tp>, _Allocator>::_Alloc_type
-          _Alloc_type;
-  _Slist_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }
-  void _M_put_node(_Slist_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }
-
-protected:
-  _Slist_node_base _M_head;
-};
-
-
-template <class _Tp, class _Alloc>
-struct _Slist_base
-  : public _Slist_alloc_base<_Tp, _Alloc,
-                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-{
-  typedef _Slist_alloc_base<_Tp, _Alloc,
-                            _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-          _Base;
-  typedef typename _Base::allocator_type allocator_type;
-
-  _Slist_base(const allocator_type& __a)
-    : _Base(__a) { this->_M_head._M_next = 0; }
-  ~_Slist_base() { this->_M_erase_after(&this->_M_head, 0); }
-
-protected:
-
-  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)
-  {
-    _Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);
-    _Slist_node_base* __next_next = __next->_M_next;
-    __pos->_M_next = __next_next;
-    destroy(&__next->_M_data);
-    this->_M_put_node(__next);
-    return __next_next;
-  }
-  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);
-};
-
-#else /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Tp, class _Alloc> 
-struct _Slist_base {
-  typedef _Alloc allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Slist_base(const allocator_type&) { _M_head._M_next = 0; }
-  ~_Slist_base() { _M_erase_after(&_M_head, 0); }
-
-protected:
-  typedef simple_alloc<_Slist_node<_Tp>, _Alloc> _Alloc_type;
-  _Slist_node<_Tp>* _M_get_node() { return _Alloc_type::allocate(1); }
-  void _M_put_node(_Slist_node<_Tp>* __p) { _Alloc_type::deallocate(__p, 1); }
-
-  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos)
-  {
-    _Slist_node<_Tp>* __next = (_Slist_node<_Tp>*) (__pos->_M_next);
-    _Slist_node_base* __next_next = __next->_M_next;
-    __pos->_M_next = __next_next;
-    destroy(&__next->_M_data);
-    this->_M_put_node(__next);
-    return __next_next;
-  }
-  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);
-
-protected:
-  _Slist_node_base _M_head;
-};  
-
-#endif /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Tp, class _Alloc> 
-_Slist_node_base*
-_Slist_base<_Tp,_Alloc>::_M_erase_after(_Slist_node_base* __before_first,
-                                        _Slist_node_base* __last_node) {
-  _Slist_node<_Tp>* __cur = (_Slist_node<_Tp>*) (__before_first->_M_next);
-  while (__cur != __last_node) {
-    _Slist_node<_Tp>* __tmp = __cur;
-    __cur = (_Slist_node<_Tp>*) __cur->_M_next;
-    destroy(&__tmp->_M_data);
-    this->_M_put_node(__tmp);
-  }
-  __before_first->_M_next = __last_node;
-  return __last_node;
-}
-
-template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >
-class slist : private _Slist_base<_Tp,_Alloc>
-{
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-
-private:
-  typedef _Slist_base<_Tp,_Alloc> _Base;
-public:
-  typedef _Tp                value_type;
-  typedef value_type*       pointer;
-  typedef const value_type* const_pointer;
-  typedef value_type&       reference;
-  typedef const value_type& const_reference;
-  typedef size_t            size_type;
-  typedef ptrdiff_t         difference_type;
-
-  typedef _Slist_iterator<_Tp, _Tp&, _Tp*>             iterator;
-  typedef _Slist_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
-
-  typedef typename _Base::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _Base::get_allocator(); }
-
-private:
-  typedef _Slist_node<_Tp>      _Node;
-  typedef _Slist_node_base      _Node_base;
-  typedef _Slist_iterator_base  _Iterator_base;
-
-  _Node* _M_create_node(const value_type& __x) {
-    _Node* __node = this->_M_get_node();
-    __STL_TRY {
-      construct(&__node->_M_data, __x);
-      __node->_M_next = 0;
-    }
-    __STL_UNWIND(this->_M_put_node(__node));
-    return __node;
-  }
-  
-  _Node* _M_create_node() {
-    _Node* __node = this->_M_get_node();
-    __STL_TRY {
-      construct(&__node->_M_data);
-      __node->_M_next = 0;
-    }
-    __STL_UNWIND(this->_M_put_node(__node));
-    return __node;
-  }
-
-public:
-  explicit slist(const allocator_type& __a = allocator_type()) : _Base(__a) {}
-
-  slist(size_type __n, const value_type& __x,
-        const allocator_type& __a =  allocator_type()) : _Base(__a)
-    { _M_insert_after_fill(&this->_M_head, __n, __x); }
-
-  explicit slist(size_type __n) : _Base(allocator_type())
-    { _M_insert_after_fill(&this->_M_head, __n, value_type()); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  // We don't need any dispatching tricks here, because _M_insert_after_range
-  // already does them.
-  template <class _InputIterator>
-  slist(_InputIterator __first, _InputIterator __last,
-        const allocator_type& __a =  allocator_type()) : _Base(__a)
-    { _M_insert_after_range(&this->_M_head, __first, __last); }
-
-#else /* __STL_MEMBER_TEMPLATES */
-  slist(const_iterator __first, const_iterator __last,
-        const allocator_type& __a =  allocator_type()) : _Base(__a)
-    { _M_insert_after_range(&this->_M_head, __first, __last); }
-  slist(const value_type* __first, const value_type* __last,
-        const allocator_type& __a =  allocator_type()) : _Base(__a)
-    { _M_insert_after_range(&this->_M_head, __first, __last); }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  slist(const slist& __x) : _Base(__x.get_allocator())
-    { _M_insert_after_range(&this->_M_head, __x.begin(), __x.end()); }
-
-  slist& operator= (const slist& __x);
-
-  ~slist() {}
-
-public:
-  // assign(), a generalized assignment member function.  Two
-  // versions: one that takes a count, and one that takes a range.
-  // The range version is a member template, so we dispatch on whether
-  // or not the type is an integer.
-
-  void assign(size_type __n, const _Tp& __val)
-    { _M_fill_assign(__n, __val); }
-
-  void _M_fill_assign(size_type __n, const _Tp& __val);
-
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  template <class _InputIterator>
-  void assign(_InputIterator __first, _InputIterator __last) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_assign_dispatch(__first, __last, _Integral());
-  }
-
-  template <class _Integer>
-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
-    { _M_fill_assign((size_type) __n, (_Tp) __val); }
-
-  template <class _InputIterator>
-  void _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
-                          __false_type);
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:
-
-  iterator begin() { return iterator((_Node*)this->_M_head._M_next); }
-  const_iterator begin() const 
-    { return const_iterator((_Node*)this->_M_head._M_next);}
-
-  iterator end() { return iterator(0); }
-  const_iterator end() const { return const_iterator(0); }
-
-  // Experimental new feature: before_begin() returns a
-  // non-dereferenceable iterator that, when incremented, yields
-  // begin().  This iterator may be used as the argument to
-  // insert_after, erase_after, etc.  Note that even for an empty 
-  // slist, before_begin() is not the same iterator as end().  It 
-  // is always necessary to increment before_begin() at least once to
-  // obtain end().
-  iterator before_begin() { return iterator((_Node*) &this->_M_head); }
-  const_iterator before_begin() const
-    { return const_iterator((_Node*) &this->_M_head); }
-
-  size_type size() const { return __slist_size(this->_M_head._M_next); }
-  
-  size_type max_size() const { return size_type(-1); }
-
-  bool empty() const { return this->_M_head._M_next == 0; }
-
-  void swap(slist& __x)
-    { __STD::swap(this->_M_head._M_next, __x._M_head._M_next); }
-
-public:
-
-  reference front() { return ((_Node*) this->_M_head._M_next)->_M_data; }
-  const_reference front() const 
-    { return ((_Node*) this->_M_head._M_next)->_M_data; }
-  void push_front(const value_type& __x)   {
-    __slist_make_link(&this->_M_head, _M_create_node(__x));
-  }
-  void push_front() { __slist_make_link(&this->_M_head, _M_create_node()); }
-  void pop_front() {
-    _Node* __node = (_Node*) this->_M_head._M_next;
-    this->_M_head._M_next = __node->_M_next;
-    destroy(&__node->_M_data);
-    this->_M_put_node(__node);
-  }
-
-  iterator previous(const_iterator __pos) {
-    return iterator((_Node*) __slist_previous(&this->_M_head, __pos._M_node));
-  }
-  const_iterator previous(const_iterator __pos) const {
-    return const_iterator((_Node*) __slist_previous(&this->_M_head,
-                                                    __pos._M_node));
-  }
-
-private:
-  _Node* _M_insert_after(_Node_base* __pos, const value_type& __x) {
-    return (_Node*) (__slist_make_link(__pos, _M_create_node(__x)));
-  }
-
-  _Node* _M_insert_after(_Node_base* __pos) {
-    return (_Node*) (__slist_make_link(__pos, _M_create_node()));
-  }
-
-  void _M_insert_after_fill(_Node_base* __pos,
-                            size_type __n, const value_type& __x) {
-    for (size_type __i = 0; __i < __n; ++__i)
-      __pos = __slist_make_link(__pos, _M_create_node(__x));
-  }
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  // Check whether it's an integral type.  If so, it's not an iterator.
-  template <class _InIter>
-  void _M_insert_after_range(_Node_base* __pos, 
-                             _InIter __first, _InIter __last) {
-    typedef typename _Is_integer<_InIter>::_Integral _Integral;
-    _M_insert_after_range(__pos, __first, __last, _Integral());
-  }
-
-  template <class _Integer>
-  void _M_insert_after_range(_Node_base* __pos, _Integer __n, _Integer __x,
-                             __true_type) {
-    _M_insert_after_fill(__pos, __n, __x);
-  }
-
-  template <class _InIter>
-  void _M_insert_after_range(_Node_base* __pos,
-                             _InIter __first, _InIter __last,
-                             __false_type) {
-    while (__first != __last) {
-      __pos = __slist_make_link(__pos, _M_create_node(*__first));
-      ++__first;
-    }
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-  void _M_insert_after_range(_Node_base* __pos,
-                             const_iterator __first, const_iterator __last) {
-    while (__first != __last) {
-      __pos = __slist_make_link(__pos, _M_create_node(*__first));
-      ++__first;
-    }
-  }
-  void _M_insert_after_range(_Node_base* __pos,
-                             const value_type* __first,
-                             const value_type* __last) {
-    while (__first != __last) {
-      __pos = __slist_make_link(__pos, _M_create_node(*__first));
-      ++__first;
-    }
-  }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:
-
-  iterator insert_after(iterator __pos, const value_type& __x) {
-    return iterator(_M_insert_after(__pos._M_node, __x));
-  }
-
-  iterator insert_after(iterator __pos) {
-    return insert_after(__pos, value_type());
-  }
-
-  void insert_after(iterator __pos, size_type __n, const value_type& __x) {
-    _M_insert_after_fill(__pos._M_node, __n, __x);
-  }
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  // We don't need any dispatching tricks here, because _M_insert_after_range
-  // already does them.
-  template <class _InIter>
-  void insert_after(iterator __pos, _InIter __first, _InIter __last) {
-    _M_insert_after_range(__pos._M_node, __first, __last);
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-  void insert_after(iterator __pos,
-                    const_iterator __first, const_iterator __last) {
-    _M_insert_after_range(__pos._M_node, __first, __last);
-  }
-  void insert_after(iterator __pos,
-                    const value_type* __first, const value_type* __last) {
-    _M_insert_after_range(__pos._M_node, __first, __last);
-  }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  iterator insert(iterator __pos, const value_type& __x) {
-    return iterator(_M_insert_after(__slist_previous(&this->_M_head,
-                                                     __pos._M_node),
-                    __x));
-  }
-
-  iterator insert(iterator __pos) {
-    return iterator(_M_insert_after(__slist_previous(&this->_M_head,
-                                                     __pos._M_node),
-                                    value_type()));
-  }
-
-  void insert(iterator __pos, size_type __n, const value_type& __x) {
-    _M_insert_after_fill(__slist_previous(&this->_M_head, __pos._M_node),
-                         __n, __x);
-  } 
-    
-#ifdef __STL_MEMBER_TEMPLATES
-
-  // We don't need any dispatching tricks here, because _M_insert_after_range
-  // already does them.
-  template <class _InIter>
-  void insert(iterator __pos, _InIter __first, _InIter __last) {
-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), 
-                          __first, __last);
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-  void insert(iterator __pos, const_iterator __first, const_iterator __last) {
-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), 
-                          __first, __last);
-  }
-  void insert(iterator __pos, const value_type* __first, 
-                              const value_type* __last) {
-    _M_insert_after_range(__slist_previous(&this->_M_head, __pos._M_node), 
-                          __first, __last);
-  }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-
-public:
-  iterator erase_after(iterator __pos) {
-    return iterator((_Node*) this->_M_erase_after(__pos._M_node));
-  }
-  iterator erase_after(iterator __before_first, iterator __last) {
-    return iterator((_Node*) this->_M_erase_after(__before_first._M_node, 
-                                                  __last._M_node));
-  } 
-
-  iterator erase(iterator __pos) {
-    return (_Node*) this->_M_erase_after(__slist_previous(&this->_M_head, 
-                                                          __pos._M_node));
-  }
-  iterator erase(iterator __first, iterator __last) {
-    return (_Node*) this->_M_erase_after(
-      __slist_previous(&this->_M_head, __first._M_node), __last._M_node);
-  }
-
-  void resize(size_type new_size, const _Tp& __x);
-  void resize(size_type new_size) { resize(new_size, _Tp()); }
-  void clear() { this->_M_erase_after(&this->_M_head, 0); }
-
-public:
-  // Moves the range [__before_first + 1, __before_last + 1) to *this,
-  //  inserting it immediately after __pos.  This is constant time.
-  void splice_after(iterator __pos, 
-                    iterator __before_first, iterator __before_last)
-  {
-    if (__before_first != __before_last) 
-      __slist_splice_after(__pos._M_node, __before_first._M_node, 
-                           __before_last._M_node);
-  }
-
-  // Moves the element that follows __prev to *this, inserting it immediately
-  //  after __pos.  This is constant time.
-  void splice_after(iterator __pos, iterator __prev)
-  {
-    __slist_splice_after(__pos._M_node,
-                         __prev._M_node, __prev._M_node->_M_next);
-  }
-
-
-  // Removes all of the elements from the list __x to *this, inserting
-  // them immediately after __pos.  __x must not be *this.  Complexity:
-  // linear in __x.size().
-  void splice_after(iterator __pos, slist& __x)
-  {
-    __slist_splice_after(__pos._M_node, &__x._M_head);
-  }
-
-  // Linear in distance(begin(), __pos), and linear in __x.size().
-  void splice(iterator __pos, slist& __x) {
-    if (__x._M_head._M_next)
-      __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),
-                           &__x._M_head, __slist_previous(&__x._M_head, 0));
-  }
-
-  // Linear in distance(begin(), __pos), and in distance(__x.begin(), __i).
-  void splice(iterator __pos, slist& __x, iterator __i) {
-    __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),
-                         __slist_previous(&__x._M_head, __i._M_node),
-                         __i._M_node);
-  }
-
-  // Linear in distance(begin(), __pos), in distance(__x.begin(), __first),
-  // and in distance(__first, __last).
-  void splice(iterator __pos, slist& __x, iterator __first, iterator __last)
-  {
-    if (__first != __last)
-      __slist_splice_after(__slist_previous(&this->_M_head, __pos._M_node),
-                           __slist_previous(&__x._M_head, __first._M_node),
-                           __slist_previous(__first._M_node, __last._M_node));
-  }
-
-public:
-  void reverse() { 
-    if (this->_M_head._M_next)
-      this->_M_head._M_next = __slist_reverse(this->_M_head._M_next);
-  }
-
-  void remove(const _Tp& __val); 
-  void unique(); 
-  void merge(slist& __x);
-  void sort();     
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _Predicate> 
-  void remove_if(_Predicate __pred);
-
-  template <class _BinaryPredicate> 
-  void unique(_BinaryPredicate __pred); 
-
-  template <class _StrictWeakOrdering> 
-  void merge(slist&, _StrictWeakOrdering);
-
-  template <class _StrictWeakOrdering> 
-  void sort(_StrictWeakOrdering __comp); 
-#endif /* __STL_MEMBER_TEMPLATES */
-};
-
-template <class _Tp, class _Alloc>
-slist<_Tp,_Alloc>& slist<_Tp,_Alloc>::operator=(const slist<_Tp,_Alloc>& __x)
-{
-  if (&__x != this) {
-    _Node_base* __p1 = &this->_M_head;
-    _Node* __n1 = (_Node*) this->_M_head._M_next;
-    const _Node* __n2 = (const _Node*) __x._M_head._M_next;
-    while (__n1 && __n2) {
-      __n1->_M_data = __n2->_M_data;
-      __p1 = __n1;
-      __n1 = (_Node*) __n1->_M_next;
-      __n2 = (const _Node*) __n2->_M_next;
-    }
-    if (__n2 == 0)
-      this->_M_erase_after(__p1, 0);
-    else
-      _M_insert_after_range(__p1, const_iterator((_Node*)__n2), 
-                                  const_iterator(0));
-  }
-  return *this;
-}
-
-template <class _Tp, class _Alloc>
-void slist<_Tp, _Alloc>::_M_fill_assign(size_type __n, const _Tp& __val) {
-  _Node_base* __prev = &this->_M_head;
-  _Node* __node = (_Node*) this->_M_head._M_next;
-  for ( ; __node != 0 && __n > 0 ; --__n) {
-    __node->_M_data = __val;
-    __prev = __node;
-    __node = (_Node*) __node->_M_next;
-  }
-  if (__n > 0)
-    _M_insert_after_fill(__prev, __n, __val);
-  else
-    this->_M_erase_after(__prev, 0);
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Alloc> template <class _InputIter>
-void
-slist<_Tp, _Alloc>::_M_assign_dispatch(_InputIter __first, _InputIter __last,
-                                       __false_type)
-{
-  _Node_base* __prev = &this->_M_head;
-  _Node* __node = (_Node*) this->_M_head._M_next;
-  while (__node != 0 && __first != __last) {
-    __node->_M_data = *__first;
-    __prev = __node;
-    __node = (_Node*) __node->_M_next;
-    ++__first;
-  }
-  if (__first != __last)
-    _M_insert_after_range(__prev, __first, __last);
-  else
-    this->_M_erase_after(__prev, 0);
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-inline bool 
-operator==(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)
-{
-  typedef typename slist<_Tp,_Alloc>::const_iterator const_iterator;
-  const_iterator __end1 = _SL1.end();
-  const_iterator __end2 = _SL2.end();
-
-  const_iterator __i1 = _SL1.begin();
-  const_iterator __i2 = _SL2.begin();
-  while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2) {
-    ++__i1;
-    ++__i2;
-  }
-  return __i1 == __end1 && __i2 == __end2;
-}
-
-
-template <class _Tp, class _Alloc>
-inline bool
-operator<(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2)
-{
-  return lexicographical_compare(_SL1.begin(), _SL1.end(), 
-                                 _SL2.begin(), _SL2.end());
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Tp, class _Alloc>
-inline bool 
-operator!=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {
-  return !(_SL1 == _SL2);
-}
-
-template <class _Tp, class _Alloc>
-inline bool 
-operator>(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {
-  return _SL2 < _SL1;
-}
-
-template <class _Tp, class _Alloc>
-inline bool 
-operator<=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {
-  return !(_SL2 < _SL1);
-}
-
-template <class _Tp, class _Alloc>
-inline bool 
-operator>=(const slist<_Tp,_Alloc>& _SL1, const slist<_Tp,_Alloc>& _SL2) {
-  return !(_SL1 < _SL2);
-}
-
-template <class _Tp, class _Alloc>
-inline void swap(slist<_Tp,_Alloc>& __x, slist<_Tp,_Alloc>& __y) {
-  __x.swap(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-
-template <class _Tp, class _Alloc>
-void slist<_Tp,_Alloc>::resize(size_type __len, const _Tp& __x)
-{
-  _Node_base* __cur = &this->_M_head;
-  while (__cur->_M_next != 0 && __len > 0) {
-    --__len;
-    __cur = __cur->_M_next;
-  }
-  if (__cur->_M_next) 
-    this->_M_erase_after(__cur, 0);
-  else
-    _M_insert_after_fill(__cur, __len, __x);
-}
-
-template <class _Tp, class _Alloc>
-void slist<_Tp,_Alloc>::remove(const _Tp& __val)
-{
-  _Node_base* __cur = &this->_M_head;
-  while (__cur && __cur->_M_next) {
-    if (((_Node*) __cur->_M_next)->_M_data == __val)
-      this->_M_erase_after(__cur);
-    else
-      __cur = __cur->_M_next;
-  }
-}
-
-template <class _Tp, class _Alloc> 
-void slist<_Tp,_Alloc>::unique()
-{
-  _Node_base* __cur = this->_M_head._M_next;
-  if (__cur) {
-    while (__cur->_M_next) {
-      if (((_Node*)__cur)->_M_data == 
-          ((_Node*)(__cur->_M_next))->_M_data)
-        this->_M_erase_after(__cur);
-      else
-        __cur = __cur->_M_next;
-    }
-  }
-}
-
-template <class _Tp, class _Alloc>
-void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x)
-{
-  _Node_base* __n1 = &this->_M_head;
-  while (__n1->_M_next && __x._M_head._M_next) {
-    if (((_Node*) __x._M_head._M_next)->_M_data < 
-        ((_Node*)       __n1->_M_next)->_M_data) 
-      __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);
-    __n1 = __n1->_M_next;
-  }
-  if (__x._M_head._M_next) {
-    __n1->_M_next = __x._M_head._M_next;
-    __x._M_head._M_next = 0;
-  }
-}
-
-template <class _Tp, class _Alloc>
-void slist<_Tp,_Alloc>::sort()
-{
-  if (this->_M_head._M_next && this->_M_head._M_next->_M_next) {
-    slist __carry;
-    slist __counter[64];
-    int __fill = 0;
-    while (!empty()) {
-      __slist_splice_after(&__carry._M_head,
-                           &this->_M_head, this->_M_head._M_next);
-      int __i = 0;
-      while (__i < __fill && !__counter[__i].empty()) {
-        __counter[__i].merge(__carry);
-        __carry.swap(__counter[__i]);
-        ++__i;
-      }
-      __carry.swap(__counter[__i]);
-      if (__i == __fill)
-        ++__fill;
-    }
-
-    for (int __i = 1; __i < __fill; ++__i)
-      __counter[__i].merge(__counter[__i-1]);
-    this->swap(__counter[__fill-1]);
-  }
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Alloc> 
-template <class _Predicate>
-void slist<_Tp,_Alloc>::remove_if(_Predicate __pred)
-{
-  _Node_base* __cur = &this->_M_head;
-  while (__cur->_M_next) {
-    if (__pred(((_Node*) __cur->_M_next)->_M_data))
-      this->_M_erase_after(__cur);
-    else
-      __cur = __cur->_M_next;
-  }
-}
-
-template <class _Tp, class _Alloc> template <class _BinaryPredicate> 
-void slist<_Tp,_Alloc>::unique(_BinaryPredicate __pred)
-{
-  _Node* __cur = (_Node*) this->_M_head._M_next;
-  if (__cur) {
-    while (__cur->_M_next) {
-      if (__pred(((_Node*)__cur)->_M_data, 
-                 ((_Node*)(__cur->_M_next))->_M_data))
-        this->_M_erase_after(__cur);
-      else
-        __cur = (_Node*) __cur->_M_next;
-    }
-  }
-}
-
-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering>
-void slist<_Tp,_Alloc>::merge(slist<_Tp,_Alloc>& __x,
-                              _StrictWeakOrdering __comp)
-{
-  _Node_base* __n1 = &this->_M_head;
-  while (__n1->_M_next && __x._M_head._M_next) {
-    if (__comp(((_Node*) __x._M_head._M_next)->_M_data,
-               ((_Node*)       __n1->_M_next)->_M_data))
-      __slist_splice_after(__n1, &__x._M_head, __x._M_head._M_next);
-    __n1 = __n1->_M_next;
-  }
-  if (__x._M_head._M_next) {
-    __n1->_M_next = __x._M_head._M_next;
-    __x._M_head._M_next = 0;
-  }
-}
-
-template <class _Tp, class _Alloc> template <class _StrictWeakOrdering> 
-void slist<_Tp,_Alloc>::sort(_StrictWeakOrdering __comp)
-{
-  if (this->_M_head._M_next && this->_M_head._M_next->_M_next) {
-    slist __carry;
-    slist __counter[64];
-    int __fill = 0;
-    while (!empty()) {
-      __slist_splice_after(&__carry._M_head,
-                           &this->_M_head, this->_M_head._M_next);
-      int __i = 0;
-      while (__i < __fill && !__counter[__i].empty()) {
-        __counter[__i].merge(__carry, __comp);
-        __carry.swap(__counter[__i]);
-        ++__i;
-      }
-      __carry.swap(__counter[__i]);
-      if (__i == __fill)
-        ++__fill;
-    }
-
-    for (int __i = 1; __i < __fill; ++__i)
-      __counter[__i].merge(__counter[__i-1], __comp);
-    this->swap(__counter[__fill-1]);
-  }
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-// Specialization of insert_iterator so that insertions will be constant
-// time rather than linear time.
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Tp, class _Alloc>
-class insert_iterator<slist<_Tp, _Alloc> > {
-protected:
-  typedef slist<_Tp, _Alloc> _Container;
-  _Container* container;
-  typename _Container::iterator iter;
-public:
-  typedef _Container          container_type;
-  typedef output_iterator_tag iterator_category;
-  typedef void                value_type;
-  typedef void                difference_type;
-  typedef void                pointer;
-  typedef void                reference;
-
-  insert_iterator(_Container& __x, typename _Container::iterator __i) 
-    : container(&__x) {
-    if (__i == __x.begin())
-      iter = __x.before_begin();
-    else
-      iter = __x.previous(__i);
-  }
-
-  insert_iterator<_Container>&
-  operator=(const typename _Container::value_type& __value) { 
-    iter = container->insert_after(iter, __value);
-    return *this;
-  }
-  insert_iterator<_Container>& operator*() { return *this; }
-  insert_iterator<_Container>& operator++() { return *this; }
-  insert_iterator<_Container>& operator++(int) { return *this; }
-};
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE 
-
-#endif /* __SGI_STL_INTERNAL_SLIST_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_stack.h b/lib/include/stl/stl_stack.h
deleted file mode 100644
index e407da1..0000000
--- a/lib/include/stl/stl_stack.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_STACK_H
-#define __SGI_STL_INTERNAL_STACK_H
-
-#include <sequence_concepts.h>
-
-__STL_BEGIN_NAMESPACE
-
-// Forward declarations of operators == and <, needed for friend declaration.
-
-template <class _Tp, 
-          class _Sequence __STL_DEPENDENT_DEFAULT_TMPL(deque<_Tp>) >
-class stack;
-
-template <class _Tp, class _Seq>
-bool operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);
-
-template <class _Tp, class _Seq>
-bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);
-
-
-template <class _Tp, class _Sequence>
-class stack {
-
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-  __STL_CLASS_REQUIRES(_Sequence, _BackInsertionSequence);
-  typedef typename _Sequence::value_type _Sequence_value_type;
-  __STL_CLASS_REQUIRES_SAME_TYPE(_Tp, _Sequence_value_type);
-
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _Tp1, class _Seq1>
-  friend bool operator== (const stack<_Tp1, _Seq1>&,
-                          const stack<_Tp1, _Seq1>&);
-  template <class _Tp1, class _Seq1>
-  friend bool operator< (const stack<_Tp1, _Seq1>&,
-                         const stack<_Tp1, _Seq1>&);
-#else /* __STL_MEMBER_TEMPLATES */
-  friend bool __STD_QUALIFIER
-  operator== __STL_nullptr_TMPL_ARGS (const stack&, const stack&);
-  friend bool __STD_QUALIFIER
-  operator< __STL_nullptr_TMPL_ARGS (const stack&, const stack&);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:
-  typedef typename _Sequence::value_type      value_type;
-  typedef typename _Sequence::size_type       size_type;
-  typedef          _Sequence                  container_type;
-
-  typedef typename _Sequence::reference       reference;
-  typedef typename _Sequence::const_reference const_reference;
-protected:
-  _Sequence c;
-public:
-  stack() : c() {}
-  explicit stack(const _Sequence& __s) : c(__s) {}
-
-  bool empty() const { return c.empty(); }
-  size_type size() const { return c.size(); }
-  reference top() { return c.back(); }
-  const_reference top() const { return c.back(); }
-  void push(const value_type& __x) { c.push_back(__x); }
-  void pop() { c.pop_back(); }
-};
-
-template <class _Tp, class _Seq>
-bool operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)
-{
-  return __x.c == __y.c;
-}
-
-template <class _Tp, class _Seq>
-bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)
-{
-  return __x.c < __y.c;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Tp, class _Seq>
-bool operator!=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)
-{
-  return !(__x == __y);
-}
-
-template <class _Tp, class _Seq>
-bool operator>(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)
-{
-  return __y < __x;
-}
-
-template <class _Tp, class _Seq>
-bool operator<=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)
-{
-  return !(__y < __x);
-}
-
-template <class _Tp, class _Seq>
-bool operator>=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)
-{
-  return !(__x < __y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_STACK_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_string_fwd.h b/lib/include/stl/stl_string_fwd.h
deleted file mode 100644
index 8e59de7..0000000
--- a/lib/include/stl/stl_string_fwd.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */ 
-
-#ifndef __SGI_STL_STRING_FWD_H
-#define __SGI_STL_STRING_FWD_H
-
-#include <stddef.h>
-#include <stl_config.h>
-#include <stl_alloc.h>
-#include <char_traits.h>
-
-__STL_BEGIN_NAMESPACE
-
-template <class _CharT, 
-          class _Traits = char_traits<_CharT>, 
-          class _Alloc = __STL_DEFAULT_ALLOCATOR(_CharT) >
-class basic_string;
-
-typedef basic_string<char>    string;
-typedef basic_string<wchar_t> wstring;
-
-static const char* __get_c_string(const string&);
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_STRING_FWD_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_tempbuf.h b/lib/include/stl/stl_tempbuf.h
deleted file mode 100644
index 0fc68d6..0000000
--- a/lib/include/stl/stl_tempbuf.h
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_TEMPBUF_H
-#define __SGI_STL_INTERNAL_TEMPBUF_H
-
-
-__STL_BEGIN_NAMESPACE
-
-template <class _Tp>
-pair<_Tp*, ptrdiff_t> 
-__get_temporary_buffer(ptrdiff_t __len, _Tp*)
-{
-  if (__len > ptrdiff_t(INT_MAX / sizeof(_Tp)))
-    __len = INT_MAX / sizeof(_Tp);
-
-  while (__len > 0) {
-    _Tp* __tmp = (_Tp*) malloc((size_t)__len * sizeof(_Tp));
-    if (__tmp != 0)
-      return pair<_Tp*, ptrdiff_t>(__tmp, __len);
-    __len /= 2;
-  }
-
-  return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);
-}
-
-#ifdef __STL_EXPLICIT_FUNCTION_TMPL_ARGS
-
-template <class _Tp>
-inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len) {
-  return __get_temporary_buffer(__len, (_Tp*) 0);
-}
-
-#endif /* __STL_EXPLICIT_FUNCTION_TMPL_ARGS */
-
-// This overload is not required by the standard; it is an extension.
-// It is supported for backward compatibility with the HP STL, and
-// because not all compilers support the language feature (explicit
-// function template arguments) that is required for the standard
-// version of get_temporary_buffer.
-template <class _Tp>
-inline pair<_Tp*, ptrdiff_t> get_temporary_buffer(ptrdiff_t __len, _Tp*) {
-  return __get_temporary_buffer(__len, (_Tp*) 0);
-}
-
-template <class _Tp>
-void return_temporary_buffer(_Tp* __p) {
-  free(__p);
-}
-
-template <class _ForwardIterator, class _Tp>
-class _Temporary_buffer {
-private:
-  ptrdiff_t  _M_original_len;
-  ptrdiff_t  _M_len;
-  _Tp*       _M_buffer;
-
-  void _M_allocate_buffer() {
-    _M_original_len = _M_len;
-    _M_buffer = 0;
-
-    if (_M_len > (ptrdiff_t)(INT_MAX / sizeof(_Tp)))
-      _M_len = INT_MAX / sizeof(_Tp);
-
-    while (_M_len > 0) {
-      _M_buffer = (_Tp*) malloc(_M_len * sizeof(_Tp));
-      if (_M_buffer)
-        break;
-      _M_len /= 2;
-    }
-  }
-
-  void _M_initialize_buffer(const _Tp&, __true_type) {}
-  void _M_initialize_buffer(const _Tp& val, __false_type) {
-    uninitialized_fill_n(_M_buffer, _M_len, val);
-  }
-
-public:
-  ptrdiff_t size() const { return _M_len; }
-  ptrdiff_t requested_size() const { return _M_original_len; }
-  _Tp* begin() { return _M_buffer; }
-  _Tp* end() { return _M_buffer + _M_len; }
-
-  _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last) {
-    // Workaround for a __type_traits bug in the pre-7.3 compiler.
-#   if defined(__sgi) && !defined(__GNUC__) && _COMPILER_VERSION < 730
-    typedef typename __type_traits<_Tp>::is_POD_type _Trivial;
-#   else
-    typedef typename __type_traits<_Tp>::has_trivial_default_constructor
-            _Trivial;
-#   endif
-
-    __STL_TRY {
-      _M_len = 0;
-      distance(__first, __last, _M_len);
-      _M_allocate_buffer();
-      if (_M_len > 0)
-        _M_initialize_buffer(*__first, _Trivial());
-    }
-    __STL_UNWIND(free(_M_buffer); _M_buffer = 0; _M_len = 0);
-  }
- 
-  ~_Temporary_buffer() {  
-    destroy(_M_buffer, _M_buffer + _M_len);
-    free(_M_buffer);
-  }
-
-private:
-  // Disable copy constructor and assignment operator.
-  _Temporary_buffer(const _Temporary_buffer&) {}
-  void operator=(const _Temporary_buffer&) {}
-};
-
-// Class temporary_buffer is not part of the standard.  It is an extension.
-
-template <class _ForwardIterator, 
-          class _Tp 
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-                    = typename iterator_traits<_ForwardIterator>::value_type
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-         >
-struct temporary_buffer : public _Temporary_buffer<_ForwardIterator, _Tp>
-{
-  temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
-    : _Temporary_buffer<_ForwardIterator, _Tp>(__first, __last) {}
-  ~temporary_buffer() {}
-};
-    
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_TEMPBUF_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_tree.h b/lib/include/stl/stl_tree.h
deleted file mode 100644
index ed160f4..0000000
--- a/lib/include/stl/stl_tree.h
+++ /dev/null
@@ -1,1369 +0,0 @@
-/*
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_TREE_H
-#define __SGI_STL_INTERNAL_TREE_H
-
-/*
-
-Red-black tree class, designed for use in implementing STL
-associative containers (set, multiset, map, and multimap). The
-insertion and deletion algorithms are based on those in Cormen,
-Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990),
-except that
-
-(1) the header cell is maintained with links not only to the root
-but also to the leftmost node of the tree, to enable constant time
-begin(), and to the rightmost node of the tree, to enable linear time
-performance when used with the generic set algorithms (set_union,
-etc.);
-
-(2) when a node being deleted has two children its successor node is
-relinked into its place, rather than copied, so that the only
-iterators invalidated are those referring to the deleted node.
-
-*/
-
-#include <stl_algobase.h>
-#include <stl_alloc.h>
-#include <stl_construct.h>
-#include <stl_function.h>
-
-__STL_BEGIN_NAMESPACE 
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1375
-#endif
-
-typedef bool _Rb_tree_Color_type;
-const _Rb_tree_Color_type _S_rb_tree_red = false;
-const _Rb_tree_Color_type _S_rb_tree_black = true;
-
-struct _Rb_tree_node_base
-{
-  typedef _Rb_tree_Color_type _Color_type;
-  typedef _Rb_tree_node_base* _Base_ptr;
-
-  _Color_type _M_color; 
-  _Base_ptr _M_parent;
-  _Base_ptr _M_left;
-  _Base_ptr _M_right;
-
-  static _Base_ptr _S_minimum(_Base_ptr __x)
-  {
-    while (__x->_M_left != 0) __x = __x->_M_left;
-    return __x;
-  }
-
-  static _Base_ptr _S_maximum(_Base_ptr __x)
-  {
-    while (__x->_M_right != 0) __x = __x->_M_right;
-    return __x;
-  }
-};
-
-template <class _Value>
-struct _Rb_tree_node : public _Rb_tree_node_base
-{
-  typedef _Rb_tree_node<_Value>* _Link_type;
-  _Value _M_value_field;
-};
-
-
-struct _Rb_tree_base_iterator
-{
-  typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
-  typedef bidirectional_iterator_tag iterator_category;
-  typedef ptrdiff_t difference_type;
-  _Base_ptr _M_node;
-
-  void _M_increment()
-  {
-    if (_M_node->_M_right != 0) {
-      _M_node = _M_node->_M_right;
-      while (_M_node->_M_left != 0)
-        _M_node = _M_node->_M_left;
-    }
-    else {
-      _Base_ptr __y = _M_node->_M_parent;
-      while (_M_node == __y->_M_right) {
-        _M_node = __y;
-        __y = __y->_M_parent;
-      }
-      if (_M_node->_M_right != __y)
-        _M_node = __y;
-    }
-  }
-
-  void _M_decrement()
-  {
-    if (_M_node->_M_color == _S_rb_tree_red &&
-        _M_node->_M_parent->_M_parent == _M_node)
-      _M_node = _M_node->_M_right;
-    else if (_M_node->_M_left != 0) {
-      _Base_ptr __y = _M_node->_M_left;
-      while (__y->_M_right != 0)
-        __y = __y->_M_right;
-      _M_node = __y;
-    }
-    else {
-      _Base_ptr __y = _M_node->_M_parent;
-      while (_M_node == __y->_M_left) {
-        _M_node = __y;
-        __y = __y->_M_parent;
-      }
-      _M_node = __y;
-    }
-  }
-};
-
-template <class _Value, class _Ref, class _Ptr>
-struct _Rb_tree_iterator : public _Rb_tree_base_iterator
-{
-  typedef _Value value_type;
-  typedef _Ref reference;
-  typedef _Ptr pointer;
-  typedef _Rb_tree_iterator<_Value, _Value&, _Value*>             
-    iterator;
-  typedef _Rb_tree_iterator<_Value, const _Value&, const _Value*> 
-    const_iterator;
-  typedef _Rb_tree_iterator<_Value, _Ref, _Ptr>                   
-    _Self;
-  typedef _Rb_tree_node<_Value>* _Link_type;
-
-  _Rb_tree_iterator() {}
-  _Rb_tree_iterator(_Link_type __x) { _M_node = __x; }
-  _Rb_tree_iterator(const iterator& __it) { _M_node = __it._M_node; }
-
-  reference operator*() const { return _Link_type(_M_node)->_M_value_field; }
-#ifndef __SGI_STL_NO_ARROW_OPERATOR
-  pointer operator->() const { return &(operator*()); }
-#endif /* __SGI_STL_NO_ARROW_OPERATOR */
-
-  _Self& operator++() { _M_increment(); return *this; }
-  _Self operator++(int) {
-    _Self __tmp = *this;
-    _M_increment();
-    return __tmp;
-  }
-    
-  _Self& operator--() { _M_decrement(); return *this; }
-  _Self operator--(int) {
-    _Self __tmp = *this;
-    _M_decrement();
-    return __tmp;
-  }
-};
-
-inline bool operator==(const _Rb_tree_base_iterator& __x,
-                       const _Rb_tree_base_iterator& __y) {
-  return __x._M_node == __y._M_node;
-}
-
-inline bool operator!=(const _Rb_tree_base_iterator& __x,
-                       const _Rb_tree_base_iterator& __y) {
-  return __x._M_node != __y._M_node;
-}
-
-#ifndef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-inline bidirectional_iterator_tag
-iterator_category(const _Rb_tree_base_iterator&) {
-  return bidirectional_iterator_tag();
-}
-
-inline _Rb_tree_base_iterator::difference_type*
-distance_type(const _Rb_tree_base_iterator&) {
-  return (_Rb_tree_base_iterator::difference_type*) 0;
-}
-
-template <class _Value, class _Ref, class _Ptr>
-inline _Value* value_type(const _Rb_tree_iterator<_Value, _Ref, _Ptr>&) {
-  return (_Value*) 0;
-}
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-inline void 
-_Rb_tree_rotate_left(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
-{
-  _Rb_tree_node_base* __y = __x->_M_right;
-  __x->_M_right = __y->_M_left;
-  if (__y->_M_left !=0)
-    __y->_M_left->_M_parent = __x;
-  __y->_M_parent = __x->_M_parent;
-
-  if (__x == __root)
-    __root = __y;
-  else if (__x == __x->_M_parent->_M_left)
-    __x->_M_parent->_M_left = __y;
-  else
-    __x->_M_parent->_M_right = __y;
-  __y->_M_left = __x;
-  __x->_M_parent = __y;
-}
-
-inline void 
-_Rb_tree_rotate_right(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
-{
-  _Rb_tree_node_base* __y = __x->_M_left;
-  __x->_M_left = __y->_M_right;
-  if (__y->_M_right != 0)
-    __y->_M_right->_M_parent = __x;
-  __y->_M_parent = __x->_M_parent;
-
-  if (__x == __root)
-    __root = __y;
-  else if (__x == __x->_M_parent->_M_right)
-    __x->_M_parent->_M_right = __y;
-  else
-    __x->_M_parent->_M_left = __y;
-  __y->_M_right = __x;
-  __x->_M_parent = __y;
-}
-
-inline void 
-_Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)
-{
-  __x->_M_color = _S_rb_tree_red;
-  while (__x != __root && __x->_M_parent->_M_color == _S_rb_tree_red) {
-    if (__x->_M_parent == __x->_M_parent->_M_parent->_M_left) {
-      _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_right;
-      if (__y && __y->_M_color == _S_rb_tree_red) {
-        __x->_M_parent->_M_color = _S_rb_tree_black;
-        __y->_M_color = _S_rb_tree_black;
-        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;
-        __x = __x->_M_parent->_M_parent;
-      }
-      else {
-        if (__x == __x->_M_parent->_M_right) {
-          __x = __x->_M_parent;
-          _Rb_tree_rotate_left(__x, __root);
-        }
-        __x->_M_parent->_M_color = _S_rb_tree_black;
-        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;
-        _Rb_tree_rotate_right(__x->_M_parent->_M_parent, __root);
-      }
-    }
-    else {
-      _Rb_tree_node_base* __y = __x->_M_parent->_M_parent->_M_left;
-      if (__y && __y->_M_color == _S_rb_tree_red) {
-        __x->_M_parent->_M_color = _S_rb_tree_black;
-        __y->_M_color = _S_rb_tree_black;
-        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;
-        __x = __x->_M_parent->_M_parent;
-      }
-      else {
-        if (__x == __x->_M_parent->_M_left) {
-          __x = __x->_M_parent;
-          _Rb_tree_rotate_right(__x, __root);
-        }
-        __x->_M_parent->_M_color = _S_rb_tree_black;
-        __x->_M_parent->_M_parent->_M_color = _S_rb_tree_red;
-        _Rb_tree_rotate_left(__x->_M_parent->_M_parent, __root);
-      }
-    }
-  }
-  __root->_M_color = _S_rb_tree_black;
-}
-
-inline _Rb_tree_node_base*
-_Rb_tree_rebalance_for_erase(_Rb_tree_node_base* __z,
-                             _Rb_tree_node_base*& __root,
-                             _Rb_tree_node_base*& __leftmost,
-                             _Rb_tree_node_base*& __rightmost)
-{
-  _Rb_tree_node_base* __y = __z;
-  _Rb_tree_node_base* __x = 0;
-  _Rb_tree_node_base* __x_parent = 0;
-  if (__y->_M_left == 0)     // __z has at most one non-null child. y == z.
-    __x = __y->_M_right;     // __x might be null.
-  else
-    if (__y->_M_right == 0)  // __z has exactly one non-null child. y == z.
-      __x = __y->_M_left;    // __x is not null.
-    else {                   // __z has two non-null children.  Set __y to
-      __y = __y->_M_right;   //   __z's successor.  __x might be null.
-      while (__y->_M_left != 0)
-        __y = __y->_M_left;
-      __x = __y->_M_right;
-    }
-  if (__y != __z) {          // relink y in place of z.  y is z's successor
-    __z->_M_left->_M_parent = __y; 
-    __y->_M_left = __z->_M_left;
-    if (__y != __z->_M_right) {
-      __x_parent = __y->_M_parent;
-      if (__x) __x->_M_parent = __y->_M_parent;
-      __y->_M_parent->_M_left = __x;      // __y must be a child of _M_left
-      __y->_M_right = __z->_M_right;
-      __z->_M_right->_M_parent = __y;
-    }
-    else
-      __x_parent = __y;  
-    if (__root == __z)
-      __root = __y;
-    else if (__z->_M_parent->_M_left == __z)
-      __z->_M_parent->_M_left = __y;
-    else 
-      __z->_M_parent->_M_right = __y;
-    __y->_M_parent = __z->_M_parent;
-    __STD::swap(__y->_M_color, __z->_M_color);
-    __y = __z;
-    // __y now points to node to be actually deleted
-  }
-  else {                        // __y == __z
-    __x_parent = __y->_M_parent;
-    if (__x) __x->_M_parent = __y->_M_parent;   
-    if (__root == __z)
-      __root = __x;
-    else 
-      if (__z->_M_parent->_M_left == __z)
-        __z->_M_parent->_M_left = __x;
-      else
-        __z->_M_parent->_M_right = __x;
-    if (__leftmost == __z) {
-      if (__z->_M_right == 0)        // __z->_M_left must be null also
-        __leftmost = __z->_M_parent;
-    // makes __leftmost == _M_header if __z == __root
-      else
-        __leftmost = _Rb_tree_node_base::_S_minimum(__x);
-    }
-    if (__rightmost == __z) {
-      if (__z->_M_left == 0)         // __z->_M_right must be null also
-        __rightmost = __z->_M_parent;  
-    // makes __rightmost == _M_header if __z == __root
-      else                      // __x == __z->_M_left
-        __rightmost = _Rb_tree_node_base::_S_maximum(__x);
-    }
-  }
-  if (__y->_M_color != _S_rb_tree_red) { 
-    while (__x != __root && (__x == 0 || __x->_M_color == _S_rb_tree_black))
-      if (__x == __x_parent->_M_left) {
-        _Rb_tree_node_base* __w = __x_parent->_M_right;
-        if (__w->_M_color == _S_rb_tree_red) {
-          __w->_M_color = _S_rb_tree_black;
-          __x_parent->_M_color = _S_rb_tree_red;
-          _Rb_tree_rotate_left(__x_parent, __root);
-          __w = __x_parent->_M_right;
-        }
-        if ((__w->_M_left == 0 || 
-             __w->_M_left->_M_color == _S_rb_tree_black) &&
-            (__w->_M_right == 0 || 
-             __w->_M_right->_M_color == _S_rb_tree_black)) {
-          __w->_M_color = _S_rb_tree_red;
-          __x = __x_parent;
-          __x_parent = __x_parent->_M_parent;
-        } else {
-          if (__w->_M_right == 0 || 
-              __w->_M_right->_M_color == _S_rb_tree_black) {
-            if (__w->_M_left) __w->_M_left->_M_color = _S_rb_tree_black;
-            __w->_M_color = _S_rb_tree_red;
-            _Rb_tree_rotate_right(__w, __root);
-            __w = __x_parent->_M_right;
-          }
-          __w->_M_color = __x_parent->_M_color;
-          __x_parent->_M_color = _S_rb_tree_black;
-          if (__w->_M_right) __w->_M_right->_M_color = _S_rb_tree_black;
-          _Rb_tree_rotate_left(__x_parent, __root);
-          break;
-        }
-      } else {                  // same as above, with _M_right <-> _M_left.
-        _Rb_tree_node_base* __w = __x_parent->_M_left;
-        if (__w->_M_color == _S_rb_tree_red) {
-          __w->_M_color = _S_rb_tree_black;
-          __x_parent->_M_color = _S_rb_tree_red;
-          _Rb_tree_rotate_right(__x_parent, __root);
-          __w = __x_parent->_M_left;
-        }
-        if ((__w->_M_right == 0 || 
-             __w->_M_right->_M_color == _S_rb_tree_black) &&
-            (__w->_M_left == 0 || 
-             __w->_M_left->_M_color == _S_rb_tree_black)) {
-          __w->_M_color = _S_rb_tree_red;
-          __x = __x_parent;
-          __x_parent = __x_parent->_M_parent;
-        } else {
-          if (__w->_M_left == 0 || 
-              __w->_M_left->_M_color == _S_rb_tree_black) {
-            if (__w->_M_right) __w->_M_right->_M_color = _S_rb_tree_black;
-            __w->_M_color = _S_rb_tree_red;
-            _Rb_tree_rotate_left(__w, __root);
-            __w = __x_parent->_M_left;
-          }
-          __w->_M_color = __x_parent->_M_color;
-          __x_parent->_M_color = _S_rb_tree_black;
-          if (__w->_M_left) __w->_M_left->_M_color = _S_rb_tree_black;
-          _Rb_tree_rotate_right(__x_parent, __root);
-          break;
-        }
-      }
-    if (__x) __x->_M_color = _S_rb_tree_black;
-  }
-  return __y;
-}
-
-// Base class to encapsulate the differences between old SGI-style
-// allocators and standard-conforming allocators.  In order to avoid
-// having an empty base class, we arbitrarily move one of rb_tree's
-// data members into the base class.
-
-#ifdef __STL_USE_STD_ALLOCATORS
-
-// _Base for general standard-conforming allocators.
-template <class _Tp, class _Alloc, bool _S_instanceless>
-class _Rb_tree_alloc_base {
-public:
-  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _M_node_allocator; }
-
-  _Rb_tree_alloc_base(const allocator_type& __a)
-    : _M_node_allocator(__a), _M_header(0) {}
-
-protected:
-  typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::allocator_type
-           _M_node_allocator;
-  _Rb_tree_node<_Tp>* _M_header;
-
-  _Rb_tree_node<_Tp>* _M_get_node() 
-    { return _M_node_allocator.allocate(1); }
-  void _M_put_node(_Rb_tree_node<_Tp>* __p) 
-    { _M_node_allocator.deallocate(__p, 1); }
-};
-
-// Specialization for instanceless allocators.
-template <class _Tp, class _Alloc>
-class _Rb_tree_alloc_base<_Tp, _Alloc, true> {
-public:
-  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Rb_tree_alloc_base(const allocator_type&) : _M_header(0) {}
-
-protected:
-  _Rb_tree_node<_Tp>* _M_header;
-
-  typedef typename _Alloc_traits<_Rb_tree_node<_Tp>, _Alloc>::_Alloc_type
-          _Alloc_type;
-
-  _Rb_tree_node<_Tp>* _M_get_node()
-    { return _Alloc_type::allocate(1); }
-  void _M_put_node(_Rb_tree_node<_Tp>* __p)
-    { _Alloc_type::deallocate(__p, 1); }
-};
-
-template <class _Tp, class _Alloc>
-struct _Rb_tree_base
-  : public _Rb_tree_alloc_base<_Tp, _Alloc,
-                               _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-{
-  typedef _Rb_tree_alloc_base<_Tp, _Alloc,
-                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-          _Base;
-  typedef typename _Base::allocator_type allocator_type;
-
-  _Rb_tree_base(const allocator_type& __a) 
-    : _Base(__a) { _Base::_M_header = _Base::_M_get_node(); }
-  ~_Rb_tree_base() { this->_M_put_node(_Base::_M_header); }
-
-};
-
-#else /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Tp, class _Alloc>
-struct _Rb_tree_base
-{
-  typedef _Alloc allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Rb_tree_base(const allocator_type&) 
-    : _M_header(0) { _M_header = _M_get_node(); }
-  ~_Rb_tree_base() { _M_put_node(_M_header); }
-
-protected:
-  _Rb_tree_node<_Tp>* _M_header;
-
-  typedef simple_alloc<_Rb_tree_node<_Tp>, _Alloc> _Alloc_type;
-
-  _Rb_tree_node<_Tp>* _M_get_node()
-    { return _Alloc_type::allocate(1); }
-  void _M_put_node(_Rb_tree_node<_Tp>* __p)
-    { _Alloc_type::deallocate(__p, 1); }
-};
-
-#endif /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Key, class _Value, class _KeyOfValue, class _Compare,
-          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) >
-class _Rb_tree : protected _Rb_tree_base<_Value, _Alloc> {
-  typedef _Rb_tree_base<_Value, _Alloc> _Base;
-protected:
-  typedef _Rb_tree_node_base* _Base_ptr;
-  typedef std::_Rb_tree_node<_Value> _Rb_tree_node;
-  typedef std::_Rb_tree_Color_type _Color_type;
-public:
-  typedef _Key key_type;
-  typedef _Value value_type;
-  typedef value_type* pointer;
-  typedef const value_type* const_pointer;
-  typedef value_type& reference;
-  typedef const value_type& const_reference;
-  typedef _Rb_tree_node* _Link_type;
-  typedef size_t size_type;
-  typedef ptrdiff_t difference_type;
-
-  typedef typename _Base::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _Base::get_allocator(); }
-
-protected:
-#ifdef __STL_USE_NAMESPACES
-  using _Base::_M_get_node;
-  using _Base::_M_put_node;
-  using _Base::_M_header;
-#endif /* __STL_USE_NAMESPACES */
-
-protected:
-
-  _Link_type _M_create_node(const value_type& __x)
-  {
-    _Link_type __tmp = _M_get_node();
-    __STL_TRY {
-      construct(&__tmp->_M_value_field, __x);
-    }
-    __STL_UNWIND(_M_put_node(__tmp));
-    return __tmp;
-  }
-
-  _Link_type _M_clone_node(_Link_type __x)
-  {
-    _Link_type __tmp = _M_create_node(__x->_M_value_field);
-    __tmp->_M_color = __x->_M_color;
-    __tmp->_M_left = 0;
-    __tmp->_M_right = 0;
-    return __tmp;
-  }
-
-  void destroy_node(_Link_type __p)
-  {
-    destroy(&__p->_M_value_field);
-    _M_put_node(__p);
-  }
-
-protected:
-  size_type _M_node_count; // keeps track of size of tree
-  _Compare _M_key_compare;
-
-  _Link_type& _M_root() const 
-    { return (_Link_type&) _M_header->_M_parent; }
-  _Link_type& _M_leftmost() const 
-    { return (_Link_type&) _M_header->_M_left; }
-  _Link_type& _M_rightmost() const 
-    { return (_Link_type&) _M_header->_M_right; }
-
-  static _Link_type& _S_left(_Link_type __x)
-    { return (_Link_type&)(__x->_M_left); }
-  static _Link_type& _S_right(_Link_type __x)
-    { return (_Link_type&)(__x->_M_right); }
-  static _Link_type& _S_parent(_Link_type __x)
-    { return (_Link_type&)(__x->_M_parent); }
-  static reference _S_value(_Link_type __x)
-    { return __x->_M_value_field; }
-  static const _Key& _S_key(_Link_type __x)
-    { return _KeyOfValue()(_S_value(__x)); }
-  static _Color_type& _S_color(_Link_type __x)
-    { return (_Color_type&)(__x->_M_color); }
-
-  static _Link_type& _S_left(_Base_ptr __x)
-    { return (_Link_type&)(__x->_M_left); }
-  static _Link_type& _S_right(_Base_ptr __x)
-    { return (_Link_type&)(__x->_M_right); }
-  static _Link_type& _S_parent(_Base_ptr __x)
-    { return (_Link_type&)(__x->_M_parent); }
-  static reference _S_value(_Base_ptr __x)
-    { return ((_Link_type)__x)->_M_value_field; }
-  static const _Key& _S_key(_Base_ptr __x)
-    { return _KeyOfValue()(_S_value(_Link_type(__x)));} 
-  static _Color_type& _S_color(_Base_ptr __x)
-    { return (_Color_type&)(_Link_type(__x)->_M_color); }
-
-  static _Link_type _S_minimum(_Link_type __x) 
-    { return (_Link_type)  _Rb_tree_node_base::_S_minimum(__x); }
-
-  static _Link_type _S_maximum(_Link_type __x)
-    { return (_Link_type) _Rb_tree_node_base::_S_maximum(__x); }
-
-public:
-  typedef _Rb_tree_iterator<value_type, reference, pointer> iterator;
-  typedef _Rb_tree_iterator<value_type, const_reference, const_pointer> 
-          const_iterator;
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
-  typedef std::reverse_iterator<iterator> reverse_iterator;
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-  typedef reverse_bidirectional_iterator<iterator, value_type, reference,
-                                         difference_type>
-          reverse_iterator; 
-  typedef reverse_bidirectional_iterator<const_iterator, value_type,
-                                         const_reference, difference_type>
-          const_reverse_iterator;
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */ 
-
-private:
-  iterator _M_insert(_Base_ptr __x, _Base_ptr __y, const value_type& __v);
-  _Link_type _M_copy(_Link_type __x, _Link_type __p);
-  void _M_erase(_Link_type __x);
-
-public:
-                                // allocation/deallocation
-  _Rb_tree()
-    : _Base(allocator_type()), _M_node_count(0), _M_key_compare()
-    { _M_empty_initialize(); }
-
-  _Rb_tree(const _Compare& __comp)
-    : _Base(allocator_type()), _M_node_count(0), _M_key_compare(__comp) 
-    { _M_empty_initialize(); }
-
-  _Rb_tree(const _Compare& __comp, const allocator_type& __a)
-    : _Base(__a), _M_node_count(0), _M_key_compare(__comp) 
-    { _M_empty_initialize(); }
-
-  _Rb_tree(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x) 
-    : _Base(__x.get_allocator()),
-      _M_node_count(0), _M_key_compare(__x._M_key_compare)
-  { 
-    if (__x._M_root() == 0)
-      _M_empty_initialize();
-    else {
-      _S_color(_M_header) = _S_rb_tree_red;
-      _M_root() = _M_copy(__x._M_root(), _M_header);
-      _M_leftmost() = _S_minimum(_M_root());
-      _M_rightmost() = _S_maximum(_M_root());
-    }
-    _M_node_count = __x._M_node_count;
-  }
-  ~_Rb_tree() { clear(); }
-  _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& 
-  operator=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x);
-
-private:
-  void _M_empty_initialize() {
-    _S_color(_M_header) = _S_rb_tree_red; // used to distinguish header from 
-                                          // __root, in iterator.operator++
-    _M_root() = 0;
-    _M_leftmost() = _M_header;
-    _M_rightmost() = _M_header;
-  }
-
-public:    
-                                // accessors:
-  _Compare key_comp() const { return _M_key_compare; }
-  iterator begin() { return _M_leftmost(); }
-  const_iterator begin() const { return _M_leftmost(); }
-  iterator end() { return _M_header; }
-  const_iterator end() const { return _M_header; }
-  reverse_iterator rbegin() { return reverse_iterator(end()); }
-  const_reverse_iterator rbegin() const { 
-    return const_reverse_iterator(end()); 
-  }
-  reverse_iterator rend() { return reverse_iterator(begin()); }
-  const_reverse_iterator rend() const { 
-    return const_reverse_iterator(begin());
-  } 
-  bool empty() const { return _M_node_count == 0; }
-  size_type size() const { return _M_node_count; }
-  size_type max_size() const { return size_type(-1); }
-
-  void swap(_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __t) {
-    __STD::swap(_M_header, __t._M_header);
-    __STD::swap(_M_node_count, __t._M_node_count);
-    __STD::swap(_M_key_compare, __t._M_key_compare);
-  }
-    
-public:
-                                // insert/erase
-  pair<iterator,bool> insert_unique(const value_type& __x);
-  iterator insert_equal(const value_type& __x);
-
-  iterator insert_unique(iterator __position, const value_type& __x);
-  iterator insert_equal(iterator __position, const value_type& __x);
-
-#ifdef __STL_MEMBER_TEMPLATES  
-  template <class _InputIterator>
-  void insert_unique(_InputIterator __first, _InputIterator __last);
-  template <class _InputIterator>
-  void insert_equal(_InputIterator __first, _InputIterator __last);
-#else /* __STL_MEMBER_TEMPLATES */
-  void insert_unique(const_iterator __first, const_iterator __last);
-  void insert_unique(const value_type* __first, const value_type* __last);
-  void insert_equal(const_iterator __first, const_iterator __last);
-  void insert_equal(const value_type* __first, const value_type* __last);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  void erase(iterator __position);
-  size_type erase(const key_type& __x);
-  void erase(iterator __first, iterator __last);
-  void erase(const key_type* __first, const key_type* __last);
-  void clear() {
-    if (_M_node_count != 0) {
-      _M_erase(_M_root());
-      _M_leftmost() = _M_header;
-      _M_root() = 0;
-      _M_rightmost() = _M_header;
-      _M_node_count = 0;
-    }
-  }      
-
-public:
-                                // set operations:
-  iterator find(const key_type& __x);
-  const_iterator find(const key_type& __x) const;
-  size_type count(const key_type& __x) const;
-  iterator lower_bound(const key_type& __x);
-  const_iterator lower_bound(const key_type& __x) const;
-  iterator upper_bound(const key_type& __x);
-  const_iterator upper_bound(const key_type& __x) const;
-  pair<iterator,iterator> equal_range(const key_type& __x);
-  pair<const_iterator, const_iterator> equal_range(const key_type& __x) const;
-
-public:
-                                // Debugging.
-  bool __rb_verify() const;
-};
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-inline bool 
-operator==(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, 
-           const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y)
-{
-  return __x.size() == __y.size() &&
-         equal(__x.begin(), __x.end(), __y.begin());
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-inline bool 
-operator<(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, 
-          const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y)
-{
-  return lexicographical_compare(__x.begin(), __x.end(), 
-                                 __y.begin(), __y.end());
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-inline bool 
-operator!=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, 
-           const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y) {
-  return !(__x == __y);
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-inline bool 
-operator>(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, 
-          const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y) {
-  return __y < __x;
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-inline bool 
-operator<=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, 
-           const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y) {
-  return !(__y < __x);
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-inline bool 
-operator>=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, 
-           const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y) {
-  return !(__x < __y);
-}
-
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-inline void 
-swap(_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x, 
-     _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __y)
-{
-  __x.swap(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& 
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::operator=(const _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>& __x)
-{
-  if (this != &__x) {
-                                // Note that _Key may be a constant type.
-    clear();
-    _M_node_count = 0;
-    _M_key_compare = __x._M_key_compare;        
-    if (__x._M_root() == 0) {
-      _M_root() = 0;
-      _M_leftmost() = _M_header;
-      _M_rightmost() = _M_header;
-    }
-    else {
-      _M_root() = _M_copy(__x._M_root(), _M_header);
-      _M_leftmost() = _S_minimum(_M_root());
-      _M_rightmost() = _S_maximum(_M_root());
-      _M_node_count = __x._M_node_count;
-    }
-  }
-  return *this;
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::_M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Value& __v)
-{
-  _Link_type __x = (_Link_type) __x_;
-  _Link_type __y = (_Link_type) __y_;
-  _Link_type __z;
-
-  if (__y == _M_header || __x != 0 || 
-      _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) {
-    __z = _M_create_node(__v);
-    _S_left(__y) = __z;               // also makes _M_leftmost() = __z 
-                                      //    when __y == _M_header
-    if (__y == _M_header) {
-      _M_root() = __z;
-      _M_rightmost() = __z;
-    }
-    else if (__y == _M_leftmost())
-      _M_leftmost() = __z;   // maintain _M_leftmost() pointing to min node
-  }
-  else {
-    __z = _M_create_node(__v);
-    _S_right(__y) = __z;
-    if (__y == _M_rightmost())
-      _M_rightmost() = __z;  // maintain _M_rightmost() pointing to max node
-  }
-  _S_parent(__z) = __y;
-  _S_left(__z) = 0;
-  _S_right(__z) = 0;
-  _Rb_tree_rebalance(__z, _M_header->_M_parent);
-  ++_M_node_count;
-  return iterator(__z);
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::insert_equal(const _Value& __v)
-{
-  _Link_type __y = _M_header;
-  _Link_type __x = _M_root();
-  while (__x != 0) {
-    __y = __x;
-    __x = _M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ? 
-            _S_left(__x) : _S_right(__x);
-  }
-  return _M_insert(__x, __y, __v);
-}
-
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-pair<typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator, 
-     bool>
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::insert_unique(const _Value& __v)
-{
-  _Link_type __y = _M_header;
-  _Link_type __x = _M_root();
-  bool __comp = true;
-  while (__x != 0) {
-    __y = __x;
-    __comp = _M_key_compare(_KeyOfValue()(__v), _S_key(__x));
-    __x = __comp ? _S_left(__x) : _S_right(__x);
-  }
-  iterator __j = iterator(__y);   
-  if (__comp) {
-    if (__j == begin())     
-      return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
-    else
-      --__j;
-  }
-  if (_M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
-    return pair<iterator,bool>(_M_insert(__x, __y, __v), true);
-  return pair<iterator,bool>(__j, false);
-}
-
-
-template <class _Key, class _Val, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator 
-_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>
-  ::insert_unique(iterator __position, const _Val& __v)
-{
-  if (__position._M_node == _M_header->_M_left) { // begin()
-    if (size() > 0 && 
-        _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node)))
-      return _M_insert(__position._M_node, __position._M_node, __v);
-    // first argument just needs to be non-null 
-    else
-      return insert_unique(__v).first;
-  } else if (__position._M_node == _M_header) { // end()
-    if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))
-      return _M_insert(0, _M_rightmost(), __v);
-    else
-      return insert_unique(__v).first;
-  } else {
-    iterator __before = __position;
-    --__before;
-    if (_M_key_compare(_S_key(__before._M_node), _KeyOfValue()(__v)) 
-        && _M_key_compare(_KeyOfValue()(__v), _S_key(__position._M_node))) {
-      if (_S_right(__before._M_node) == 0)
-        return _M_insert(0, __before._M_node, __v); 
-      else
-        return _M_insert(__position._M_node, __position._M_node, __v);
-    // first argument just needs to be non-null 
-    } else
-      return insert_unique(__v).first;
-  }
-}
-
-template <class _Key, class _Val, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator 
-_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>
-  ::insert_equal(iterator __position, const _Val& __v)
-{
-  if (__position._M_node == _M_header->_M_left) { // begin()
-    if (size() > 0 && 
-        !_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v)))
-      return _M_insert(__position._M_node, __position._M_node, __v);
-    // first argument just needs to be non-null 
-    else
-      return insert_equal(__v);
-  } else if (__position._M_node == _M_header) {// end()
-    if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))
-      return _M_insert(0, _M_rightmost(), __v);
-    else
-      return insert_equal(__v);
-  } else {
-    iterator __before = __position;
-    --__before;
-    if (!_M_key_compare(_KeyOfValue()(__v), _S_key(__before._M_node))
-        && !_M_key_compare(_S_key(__position._M_node), _KeyOfValue()(__v))) {
-      if (_S_right(__before._M_node) == 0)
-        return _M_insert(0, __before._M_node, __v); 
-      else
-        return _M_insert(__position._M_node, __position._M_node, __v);
-    // first argument just needs to be non-null 
-    } else
-      return insert_equal(__v);
-  }
-}
-
-#ifdef __STL_MEMBER_TEMPLATES  
-
-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>
-  template<class _II>
-void _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>
-  ::insert_equal(_II __first, _II __last)
-{
-  for ( ; __first != __last; ++__first)
-    insert_equal(*__first);
-}
-
-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc> 
-  template<class _II>
-void _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>
-  ::insert_unique(_II __first, _II __last) {
-  for ( ; __first != __last; ++__first)
-    insert_unique(*__first);
-}
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>
-void
-_Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>
-  ::insert_equal(const _Val* __first, const _Val* __last)
-{
-  for ( ; __first != __last; ++__first)
-    insert_equal(*__first);
-}
-
-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>
-void
-_Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>
-  ::insert_equal(const_iterator __first, const_iterator __last)
-{
-  for ( ; __first != __last; ++__first)
-    insert_equal(*__first);
-}
-
-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>
-void 
-_Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>
-  ::insert_unique(const _Val* __first, const _Val* __last)
-{
-  for ( ; __first != __last; ++__first)
-    insert_unique(*__first);
-}
-
-template <class _Key, class _Val, class _KoV, class _Cmp, class _Alloc>
-void _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>
-  ::insert_unique(const_iterator __first, const_iterator __last)
-{
-  for ( ; __first != __last; ++__first)
-    insert_unique(*__first);
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-         
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-inline void _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::erase(iterator __position)
-{
-  _Link_type __y = 
-    (_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,
-                                              _M_header->_M_parent,
-                                              _M_header->_M_left,
-                                              _M_header->_M_right);
-  destroy_node(__y);
-  --_M_node_count;
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::size_type 
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::erase(const _Key& __x)
-{
-  pair<iterator,iterator> __p = equal_range(__x);
-  size_type __n = 0;
-  distance(__p.first, __p.second, __n);
-  erase(__p.first, __p.second);
-  return __n;
-}
-
-template <class _Key, class _Val, class _KoV, class _Compare, class _Alloc>
-typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type 
-_Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>
-  ::_M_copy(_Link_type __x, _Link_type __p)
-{
-                        // structural copy.  __x and __p must be non-null.
-  _Link_type __top = _M_clone_node(__x);
-  __top->_M_parent = __p;
- 
-  __STL_TRY {
-    if (__x->_M_right)
-      __top->_M_right = _M_copy(_S_right(__x), __top);
-    __p = __top;
-    __x = _S_left(__x);
-
-    while (__x != 0) {
-      _Link_type __y = _M_clone_node(__x);
-      __p->_M_left = __y;
-      __y->_M_parent = __p;
-      if (__x->_M_right)
-        __y->_M_right = _M_copy(_S_right(__x), __y);
-      __p = __y;
-      __x = _S_left(__x);
-    }
-  }
-  __STL_UNWIND(_M_erase(__top));
-
-  return __top;
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-void _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::_M_erase(_Link_type __x)
-{
-                                // erase without rebalancing
-  while (__x != 0) {
-    _M_erase(_S_right(__x));
-    _Link_type __y = _S_left(__x);
-    destroy_node(__x);
-    __x = __y;
-  }
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-void _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::erase(iterator __first, iterator __last)
-{
-  if (__first == begin() && __last == end())
-    clear();
-  else
-    while (__first != __last) erase(__first++);
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-void _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::erase(const _Key* __first, const _Key* __last) 
-{
-  while (__first != __last) erase(*__first++);
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator 
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)
-{
-  _Link_type __y = _M_header;      // Last node which is not less than __k. 
-  _Link_type __x = _M_root();      // Current node. 
-
-  while (__x != 0) 
-    if (!_M_key_compare(_S_key(__x), __k))
-      __y = __x, __x = _S_left(__x);
-    else
-      __x = _S_right(__x);
-
-  iterator __j = iterator(__y);   
-  return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ? 
-     end() : __j;
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::const_iterator 
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k) const
-{
-  _Link_type __y = _M_header; /* Last node which is not less than __k. */
-  _Link_type __x = _M_root(); /* Current node. */
-
-  while (__x != 0) {
-    if (!_M_key_compare(_S_key(__x), __k))
-      __y = __x, __x = _S_left(__x);
-    else
-      __x = _S_right(__x);
-  }
-  const_iterator __j = const_iterator(__y);   
-  return (__j == end() || _M_key_compare(__k, _S_key(__j._M_node))) ?
-    end() : __j;
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::size_type 
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::count(const _Key& __k) const
-{
-  pair<const_iterator, const_iterator> __p = equal_range(__k);
-  size_type __n = 0;
-  distance(__p.first, __p.second, __n);
-  return __n;
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator 
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::lower_bound(const _Key& __k)
-{
-  _Link_type __y = _M_header; /* Last node which is not less than __k. */
-  _Link_type __x = _M_root(); /* Current node. */
-
-  while (__x != 0) 
-    if (!_M_key_compare(_S_key(__x), __k))
-      __y = __x, __x = _S_left(__x);
-    else
-      __x = _S_right(__x);
-
-  return iterator(__y);
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::const_iterator 
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::lower_bound(const _Key& __k) const
-{
-  _Link_type __y = _M_header; /* Last node which is not less than __k. */
-  _Link_type __x = _M_root(); /* Current node. */
-
-  while (__x != 0) 
-    if (!_M_key_compare(_S_key(__x), __k))
-      __y = __x, __x = _S_left(__x);
-    else
-      __x = _S_right(__x);
-
-  return const_iterator(__y);
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator 
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::upper_bound(const _Key& __k)
-{
-  _Link_type __y = _M_header; /* Last node which is greater than __k. */
-  _Link_type __x = _M_root(); /* Current node. */
-
-   while (__x != 0) 
-     if (_M_key_compare(__k, _S_key(__x)))
-       __y = __x, __x = _S_left(__x);
-     else
-       __x = _S_right(__x);
-
-   return iterator(__y);
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::const_iterator 
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::upper_bound(const _Key& __k) const
-{
-  _Link_type __y = _M_header; /* Last node which is greater than __k. */
-  _Link_type __x = _M_root(); /* Current node. */
-
-   while (__x != 0) 
-     if (_M_key_compare(__k, _S_key(__x)))
-       __y = __x, __x = _S_left(__x);
-     else
-       __x = _S_right(__x);
-
-   return const_iterator(__y);
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-inline 
-pair<typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator,
-     typename _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::iterator>
-_Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>
-  ::equal_range(const _Key& __k)
-{
-  return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k));
-}
-
-template <class _Key, class _Value, class _KoV, class _Compare, class _Alloc>
-inline 
-pair<typename _Rb_tree<_Key, _Value, _KoV, _Compare, _Alloc>::const_iterator,
-     typename _Rb_tree<_Key, _Value, _KoV, _Compare, _Alloc>::const_iterator>
-_Rb_tree<_Key, _Value, _KoV, _Compare, _Alloc>
-  ::equal_range(const _Key& __k) const
-{
-  return pair<const_iterator,const_iterator>(lower_bound(__k),
-                                             upper_bound(__k));
-}
-
-inline int 
-__black_count(_Rb_tree_node_base* __node, _Rb_tree_node_base* __root)
-{
-  if (__node == 0)
-    return 0;
-  else {
-    int __bc = __node->_M_color == _S_rb_tree_black ? 1 : 0;
-    if (__node == __root)
-      return __bc;
-    else
-      return __bc + __black_count(__node->_M_parent, __root);
-  }
-}
-
-template <class _Key, class _Value, class _KeyOfValue, 
-          class _Compare, class _Alloc>
-bool _Rb_tree<_Key,_Value,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
-{
-  if (_M_node_count == 0 || begin() == end())
-    return _M_node_count == 0 && begin() == end() &&
-      _M_header->_M_left == _M_header && _M_header->_M_right == _M_header;
-  
-  int __len = __black_count(_M_leftmost(), _M_root());
-  for (const_iterator __it = begin(); __it != end(); ++__it) {
-    _Link_type __x = (_Link_type) __it._M_node;
-    _Link_type __L = _S_left(__x);
-    _Link_type __R = _S_right(__x);
-
-    if (__x->_M_color == _S_rb_tree_red)
-      if ((__L && __L->_M_color == _S_rb_tree_red) ||
-          (__R && __R->_M_color == _S_rb_tree_red))
-        return false;
-
-    if (__L && _M_key_compare(_S_key(__x), _S_key(__L)))
-      return false;
-    if (__R && _M_key_compare(_S_key(__R), _S_key(__x)))
-      return false;
-
-    if (!__L && !__R && __black_count(__x, _M_root()) != __len)
-      return false;
-  }
-
-  if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
-    return false;
-  if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
-    return false;
-
-  return true;
-}
-
-// Class rb_tree is not part of the C++ standard.  It is provided for
-// compatibility with the HP STL.
-
-template <class _Key, class _Value, class _KeyOfValue, class _Compare,
-          class _Alloc = __STL_DEFAULT_ALLOCATOR(_Value) >
-struct rb_tree : public _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc>
-{
-  typedef _Rb_tree<_Key, _Value, _KeyOfValue, _Compare, _Alloc> _Base;
-  typedef typename _Base::allocator_type allocator_type;
-
-  rb_tree(const _Compare& __comp = _Compare(),
-          const allocator_type& __a = allocator_type())
-    : _Base(__comp, __a) {}
-  
-  ~rb_tree() {}
-};
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE 
-
-#endif /* __SGI_STL_INTERNAL_TREE_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_uninitialized.h b/lib/include/stl/stl_uninitialized.h
deleted file mode 100644
index d367fbe..0000000
--- a/lib/include/stl/stl_uninitialized.h
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_UNINITIALIZED_H
-#define __SGI_STL_INTERNAL_UNINITIALIZED_H
-
-__STL_BEGIN_NAMESPACE
-
-// uninitialized_copy
-
-// Valid if copy construction is equivalent to assignment, and if the
-//  destructor is trivial.
-template <class _InputIter, class _ForwardIter>
-inline _ForwardIter 
-__uninitialized_copy_aux(_InputIter __first, _InputIter __last,
-                         _ForwardIter __result,
-                         __true_type)
-{
-  return copy(__first, __last, __result);
-}
-
-template <class _InputIter, class _ForwardIter>
-_ForwardIter 
-__uninitialized_copy_aux(_InputIter __first, _InputIter __last,
-                         _ForwardIter __result,
-                         __false_type)
-{
-  _ForwardIter __cur = __result;
-  __STL_TRY {
-    for ( ; __first != __last; ++__first, ++__cur)
-      _Construct(&*__cur, *__first);
-    return __cur;
-  }
-  __STL_UNWIND(_Destroy(__result, __cur));
-}
-
-
-template <class _InputIter, class _ForwardIter, class _Tp>
-inline _ForwardIter
-__uninitialized_copy(_InputIter __first, _InputIter __last,
-                     _ForwardIter __result, _Tp*)
-{
-  typedef typename __type_traits<_Tp>::is_POD_type _Is_POD;
-  return __uninitialized_copy_aux(__first, __last, __result, _Is_POD());
-}
-
-template <class _InputIter, class _ForwardIter>
-inline _ForwardIter
-  uninitialized_copy(_InputIter __first, _InputIter __last,
-                     _ForwardIter __result)
-{
-  return __uninitialized_copy(__first, __last, __result,
-                              __VALUE_TYPE(__result));
-}
-
-inline char* uninitialized_copy(const char* __first, const char* __last,
-                                char* __result) {
-  memmove(__result, __first, __last - __first);
-  return __result + (__last - __first);
-}
-
-inline wchar_t* 
-uninitialized_copy(const wchar_t* __first, const wchar_t* __last,
-                   wchar_t* __result)
-{
-  memmove(__result, __first, sizeof(wchar_t) * (__last - __first));
-  return __result + (__last - __first);
-}
-
-// uninitialized_copy_n (not part of the C++ standard)
-
-template <class _InputIter, class _Size, class _ForwardIter>
-pair<_InputIter, _ForwardIter>
-__uninitialized_copy_n(_InputIter __first, _Size __count,
-                       _ForwardIter __result,
-                       input_iterator_tag)
-{
-  _ForwardIter __cur = __result;
-  __STL_TRY {
-    for ( ; __count > 0 ; --__count, ++__first, ++__cur) 
-      _Construct(&*__cur, *__first);
-    return pair<_InputIter, _ForwardIter>(__first, __cur);
-  }
-  __STL_UNWIND(_Destroy(__result, __cur));
-}
-
-template <class _RandomAccessIter, class _Size, class _ForwardIter>
-inline pair<_RandomAccessIter, _ForwardIter>
-__uninitialized_copy_n(_RandomAccessIter __first, _Size __count,
-                       _ForwardIter __result,
-                       random_access_iterator_tag) {
-  _RandomAccessIter __last = __first + __count;
-  return pair<_RandomAccessIter, _ForwardIter>(
-                 __last,
-                 uninitialized_copy(__first, __last, __result));
-}
-
-template <class _InputIter, class _Size, class _ForwardIter>
-inline pair<_InputIter, _ForwardIter>
-__uninitialized_copy_n(_InputIter __first, _Size __count,
-                     _ForwardIter __result) {
-  return __uninitialized_copy_n(__first, __count, __result,
-                                __ITERATOR_CATEGORY(__first));
-}
-
-template <class _InputIter, class _Size, class _ForwardIter>
-inline pair<_InputIter, _ForwardIter>
-uninitialized_copy_n(_InputIter __first, _Size __count,
-                     _ForwardIter __result) {
-  return __uninitialized_copy_n(__first, __count, __result,
-                                __ITERATOR_CATEGORY(__first));
-}
-
-// Valid if copy construction is equivalent to assignment, and if the
-// destructor is trivial.
-template <class _ForwardIter, class _Tp>
-inline void
-__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, 
-                         const _Tp& __x, __true_type)
-{
-  fill(__first, __last, __x);
-}
-
-template <class _ForwardIter, class _Tp>
-void
-__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, 
-                         const _Tp& __x, __false_type)
-{
-  _ForwardIter __cur = __first;
-  __STL_TRY {
-    for ( ; __cur != __last; ++__cur)
-      _Construct(&*__cur, __x);
-  }
-  __STL_UNWIND(_Destroy(__first, __cur));
-}
-
-template <class _ForwardIter, class _Tp, class _Tp1>
-inline void __uninitialized_fill(_ForwardIter __first, 
-                                 _ForwardIter __last, const _Tp& __x, _Tp1*)
-{
-  typedef typename __type_traits<_Tp1>::is_POD_type _Is_POD;
-  __uninitialized_fill_aux(__first, __last, __x, _Is_POD());
-                   
-}
-
-template <class _ForwardIter, class _Tp>
-inline void uninitialized_fill(_ForwardIter __first,
-                               _ForwardIter __last, 
-                               const _Tp& __x)
-{
-  __uninitialized_fill(__first, __last, __x, __VALUE_TYPE(__first));
-}
-
-// Valid if copy construction is equivalent to assignment, and if the
-//  destructor is trivial.
-template <class _ForwardIter, class _Size, class _Tp>
-inline _ForwardIter
-__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
-                           const _Tp& __x, __true_type)
-{
-  return fill_n(__first, __n, __x);
-}
-
-template <class _ForwardIter, class _Size, class _Tp>
-_ForwardIter
-__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,
-                           const _Tp& __x, __false_type)
-{
-  _ForwardIter __cur = __first;
-  __STL_TRY {
-    for ( ; __n > 0; --__n, ++__cur)
-      _Construct(&*__cur, __x);
-    return __cur;
-  }
-  __STL_UNWIND(_Destroy(__first, __cur));
-}
-
-template <class _ForwardIter, class _Size, class _Tp, class _Tp1>
-inline _ForwardIter 
-__uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x, _Tp1*)
-{
-  typedef typename __type_traits<_Tp1>::is_POD_type _Is_POD;
-  return __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());
-}
-
-template <class _ForwardIter, class _Size, class _Tp>
-inline _ForwardIter 
-uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x)
-{
-  return __uninitialized_fill_n(__first, __n, __x, __VALUE_TYPE(__first));
-}
-
-// Extensions: __uninitialized_copy_copy, __uninitialized_copy_fill, 
-// __uninitialized_fill_copy.
-
-// __uninitialized_copy_copy
-// Copies [first1, last1) into [result, result + (last1 - first1)), and
-//  copies [first2, last2) into
-//  [result, result + (last1 - first1) + (last2 - first2)).
-
-template <class _InputIter1, class _InputIter2, class _ForwardIter>
-inline _ForwardIter
-__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,
-                          _InputIter2 __first2, _InputIter2 __last2,
-                          _ForwardIter __result)
-{
-  _ForwardIter __mid = uninitialized_copy(__first1, __last1, __result);
-  __STL_TRY {
-    return uninitialized_copy(__first2, __last2, __mid);
-  }
-  __STL_UNWIND(_Destroy(__result, __mid));
-}
-
-// __uninitialized_fill_copy
-// Fills [result, mid) with x, and copies [first, last) into
-//  [mid, mid + (last - first)).
-template <class _ForwardIter, class _Tp, class _InputIter>
-inline _ForwardIter 
-__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid,
-                          const _Tp& __x,
-                          _InputIter __first, _InputIter __last)
-{
-  uninitialized_fill(__result, __mid, __x);
-  __STL_TRY {
-    return uninitialized_copy(__first, __last, __mid);
-  }
-  __STL_UNWIND(_Destroy(__result, __mid));
-}
-
-// __uninitialized_copy_fill
-// Copies [first1, last1) into [first2, first2 + (last1 - first1)), and
-//  fills [first2 + (last1 - first1), last2) with x.
-template <class _InputIter, class _ForwardIter, class _Tp>
-inline void
-__uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,
-                          _ForwardIter __first2, _ForwardIter __last2,
-                          const _Tp& __x)
-{
-  _ForwardIter __mid2 = uninitialized_copy(__first1, __last1, __first2);
-  __STL_TRY {
-    uninitialized_fill(__mid2, __last2, __x);
-  }
-  __STL_UNWIND(_Destroy(__first2, __mid2));
-}
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_INTERNAL_UNINITIALIZED_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stl_vector.h b/lib/include/stl/stl_vector.h
deleted file mode 100644
index 88a2fb7..0000000
--- a/lib/include/stl/stl_vector.h
+++ /dev/null
@@ -1,879 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-/* NOTE: This is an internal header file, included by other STL headers.
- *   You should not attempt to use it directly.
- */
-
-#ifndef __SGI_STL_INTERNAL_VECTOR_H
-#define __SGI_STL_INTERNAL_VECTOR_H
-
-#include <concept_checks.h>
-
-__STL_BEGIN_NAMESPACE 
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-// The vector base class serves two purposes.  First, its constructor
-// and destructor allocate (but don't initialize) storage.  This makes
-// exception safety easier.  Second, the base class encapsulates all of
-// the differences between SGI-style allocators and standard-conforming
-// allocators.
-
-#ifdef __STL_USE_STD_ALLOCATORS
-
-// Base class for ordinary allocators.
-template <class _Tp, class _Allocator, bool _IsStatic>
-class _Vector_alloc_base {
-public:
-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
-          allocator_type;
-  allocator_type get_allocator() const { return _M_data_allocator; }
-
-  _Vector_alloc_base(const allocator_type& __a)
-    : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0) 
-  {}
-  
-protected:
-  allocator_type _M_data_allocator;
-  _Tp* _M_start;
-  _Tp* _M_finish;
-  _Tp* _M_end_of_storage;
-
-  _Tp* _M_allocate(size_t __n)
-    { return _M_data_allocator.allocate(__n); }
-  void _M_deallocate(_Tp* __p, size_t __n)
-    { if (__p) _M_data_allocator.deallocate(__p, __n); }
-};
-
-// Specialization for allocators that have the property that we don't
-// actually have to store an allocator object.  
-template <class _Tp, class _Allocator>
-class _Vector_alloc_base<_Tp, _Allocator, true> {
-public:
-  typedef typename _Alloc_traits<_Tp, _Allocator>::allocator_type
-          allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Vector_alloc_base(const allocator_type&)
-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) 
-  {}
-  
-protected:
-  _Tp* _M_start;
-  _Tp* _M_finish;
-  _Tp* _M_end_of_storage;
-
-  typedef typename _Alloc_traits<_Tp, _Allocator>::_Alloc_type _Alloc_type;
-  _Tp* _M_allocate(size_t __n)
-    { return _Alloc_type::allocate(__n); }
-  void _M_deallocate(_Tp* __p, size_t __n)
-    { _Alloc_type::deallocate(__p, __n);}
-};
-
-template <class _Tp, class _Alloc>
-struct _Vector_base
-  : public _Vector_alloc_base<_Tp, _Alloc,
-                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-{
-  typedef _Vector_alloc_base<_Tp, _Alloc, 
-                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-          _Base;
-  typedef typename _Base::allocator_type allocator_type;
-
-  _Vector_base(const allocator_type& __a) : _Base(__a) {}
-  _Vector_base(size_t __n, const allocator_type& __a) : _Base(__a) {
-    _Base::_M_start = _Base::_M_allocate(__n);
-    _Base::_M_finish = _Base::_M_start;
-    _Base::_M_end_of_storage = _Base::_M_start + __n;
-  }
-
-  ~_Vector_base() { this->_M_deallocate(_Base::_M_start, _Base::_M_end_of_storage - _Base::_M_start); }
-};    
-
-#else /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Tp, class _Alloc> 
-class _Vector_base {
-public:
-  typedef _Alloc allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _Vector_base(const _Alloc&)
-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) {}
-  _Vector_base(size_t __n, const _Alloc&)
-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) 
-  {
-    _M_start = _M_allocate(__n);
-    _M_finish = _M_start;
-    _M_end_of_storage = _M_start + __n;
-  }
-
-  ~_Vector_base() { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }
-
-protected:
-  _Tp* _M_start;
-  _Tp* _M_finish;
-  _Tp* _M_end_of_storage;
-
-  typedef simple_alloc<_Tp, _Alloc> _M_data_allocator;
-  _Tp* _M_allocate(size_t __n)
-    { return _M_data_allocator::allocate(__n); }
-  void _M_deallocate(_Tp* __p, size_t __n) 
-    { _M_data_allocator::deallocate(__p, __n); }
-};
-
-#endif /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) >
-class vector : protected _Vector_base<_Tp, _Alloc> 
-{
-  // requirements:
-
-  __STL_CLASS_REQUIRES(_Tp, _Assignable);
-
-private:
-  typedef _Vector_base<_Tp, _Alloc> _Base;
-public:
-  typedef _Tp value_type;
-  typedef value_type* pointer;
-  typedef const value_type* const_pointer;
-  typedef value_type* iterator;
-  typedef const value_type* const_iterator;
-  typedef value_type& reference;
-  typedef const value_type& const_reference;
-  typedef size_t size_type;
-  typedef ptrdiff_t difference_type;
-
-  typedef typename _Base::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _Base::get_allocator(); }
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
-  typedef std::reverse_iterator<iterator> reverse_iterator;
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-  typedef std::reverse_iterator<const_iterator, value_type, const_reference,
-                           difference_type>  const_reverse_iterator;
-  typedef std::reverse_iterator<iterator, value_type, reference, difference_type>
-          reverse_iterator;
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-protected:
-#ifdef __STL_HAS_NAMESPACES
-  using _Base::_M_allocate;
-  using _Base::_M_deallocate;
-  using _Base::_M_start;
-  using _Base::_M_finish;
-  using _Base::_M_end_of_storage;
-#endif /* __STL_HAS_NAMESPACES */
-
-protected:
-  void _M_insert_aux(iterator __position, const _Tp& __x);
-  void _M_insert_aux(iterator __position);
-
-public:
-  iterator begin() { return _M_start; }
-  const_iterator begin() const { return _M_start; }
-  iterator end() { return _M_finish; }
-  const_iterator end() const { return _M_finish; }
-
-  reverse_iterator rbegin()
-    { return reverse_iterator(end()); }
-  const_reverse_iterator rbegin() const
-    { return const_reverse_iterator(end()); }
-  reverse_iterator rend()
-    { return reverse_iterator(begin()); }
-  const_reverse_iterator rend() const
-    { return const_reverse_iterator(begin()); }
-
-  size_type size() const
-    { return size_type(end() - begin()); }
-  size_type max_size() const
-    { return size_type(-1) / sizeof(_Tp); }
-  size_type capacity() const
-    { return size_type(_M_end_of_storage - begin()); }
-  bool empty() const
-    { return begin() == end(); }
-
-  reference operator[](size_type __n) { return *(begin() + __n); }
-  const_reference operator[](size_type __n) const { return *(begin() + __n); }
-
-#ifdef __STL_THROW_RANGE_ERRORS
-  void _M_range_check(size_type __n) const {
-    if (__n >= this->size())
-      __stl_throw_range_error("vector");
-  }
-
-  reference at(size_type __n)
-    { _M_range_check(__n); return (*this)[__n]; }
-  const_reference at(size_type __n) const
-    { _M_range_check(__n); return (*this)[__n]; }
-#endif /* __STL_THROW_RANGE_ERRORS */
-
-  explicit vector(const allocator_type& __a = allocator_type())
-    : _Base(__a) {}
-
-  vector(size_type __n, const _Tp& __value,
-         const allocator_type& __a = allocator_type()) 
-    : _Base(__n, __a)
-    { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }
-
-  explicit vector(size_type __n)
-    : _Base(__n, allocator_type())
-    { _M_finish = uninitialized_fill_n(_M_start, __n, _Tp()); }
-
-  vector(const vector<_Tp, _Alloc>& __x) 
-    : _Base(__x.size(), __x.get_allocator())
-    { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }
-
-#ifdef __STL_MEMBER_TEMPLATES
-  // Check whether it's an integral type.  If so, it's not an iterator.
-  template <class _InputIterator>
-  vector(_InputIterator __first, _InputIterator __last,
-         const allocator_type& __a = allocator_type()) : _Base(__a) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_initialize_aux(__first, __last, _Integral());
-  }
-
-  template <class _Integer>
-  void _M_initialize_aux(_Integer __n, _Integer __value, __true_type) {
-    _M_start = _M_allocate(__n);
-    _M_end_of_storage = _M_start + __n; 
-    _M_finish = uninitialized_fill_n(_M_start, __n, __value);
-  }
-
-  template <class _InputIterator>
-  void _M_initialize_aux(_InputIterator __first, _InputIterator __last,
-                         __false_type) {
-    _M_range_initialize(__first, __last, __ITERATOR_CATEGORY(__first));
-  }
-
-#else
-  vector(const _Tp* __first, const _Tp* __last,
-         const allocator_type& __a = allocator_type())
-    : _Base(__last - __first, __a) 
-    { _M_finish = uninitialized_copy(__first, __last, _M_start); }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  ~vector() { destroy(_M_start, _M_finish); }
-
-  vector<_Tp, _Alloc>& operator=(const vector<_Tp, _Alloc>& __x);
-  void reserve(size_type __n) {
-    if (capacity() < __n) {
-      const size_type __old_size = size();
-      iterator __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);
-      destroy(_M_start, _M_finish);
-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
-      _M_start = __tmp;
-      _M_finish = __tmp + __old_size;
-      _M_end_of_storage = _M_start + __n;
-    }
-  }
-
-  // assign(), a generalized assignment member function.  Two
-  // versions: one that takes a count, and one that takes a range.
-  // The range version is a member template, so we dispatch on whether
-  // or not the type is an integer.
-
-  void assign(size_type __n, const _Tp& __val) { _M_fill_assign(__n, __val); }
-  void _M_fill_assign(size_type __n, const _Tp& __val);
-
-#ifdef __STL_MEMBER_TEMPLATES
-  
-  template <class _InputIterator>
-  void assign(_InputIterator __first, _InputIterator __last) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_assign_dispatch(__first, __last, _Integral());
-  }
-
-  template <class _Integer>
-  void _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
-    { _M_fill_assign((size_type) __n, (_Tp) __val); }
-
-  template <class _InputIter>
-  void _M_assign_dispatch(_InputIter __first, _InputIter __last, __false_type)
-    { _M_assign_aux(__first, __last, __ITERATOR_CATEGORY(__first)); }
-
-  template <class _InputIterator>
-  void _M_assign_aux(_InputIterator __first, _InputIterator __last,
-                     input_iterator_tag);
-
-  template <class _ForwardIterator>
-  void _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
-                     forward_iterator_tag); 
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  reference front() { return *begin(); }
-  const_reference front() const { return *begin(); }
-  reference back() { return *(end() - 1); }
-  const_reference back() const { return *(end() - 1); }
-
-  void push_back(const _Tp& __x) {
-    if (_M_finish != _M_end_of_storage) {
-      construct(_M_finish, __x);
-      ++_M_finish;
-    }
-    else
-      _M_insert_aux(end(), __x);
-  }
-  void push_back() {
-    if (_M_finish != _M_end_of_storage) {
-      construct(_M_finish);
-      ++_M_finish;
-    }
-    else
-      _M_insert_aux(end());
-  }
-  void swap(vector<_Tp, _Alloc>& __x) {
-    __STD::swap(_M_start, __x._M_start);
-    __STD::swap(_M_finish, __x._M_finish);
-    __STD::swap(_M_end_of_storage, __x._M_end_of_storage);
-  }
-
-  iterator insert(iterator __position, const _Tp& __x) {
-    size_type __n = __position - begin();
-    if (_M_finish != _M_end_of_storage && __position == end()) {
-      construct(_M_finish, __x);
-      ++_M_finish;
-    }
-    else
-      _M_insert_aux(__position, __x);
-    return begin() + __n;
-  }
-  iterator insert(iterator __position) {
-    size_type __n = __position - begin();
-    if (_M_finish != _M_end_of_storage && __position == end()) {
-      construct(_M_finish);
-      ++_M_finish;
-    }
-    else
-      _M_insert_aux(__position);
-    return begin() + __n;
-  }
-#ifdef __STL_MEMBER_TEMPLATES
-  // Check whether it's an integral type.  If so, it's not an iterator.
-  template <class _InputIterator>
-  void insert(iterator __pos, _InputIterator __first, _InputIterator __last) {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_insert_dispatch(__pos, __first, __last, _Integral());
-  }
-
-  template <class _Integer>
-  void _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
-                          __true_type)
-    { _M_fill_insert(__pos, (size_type) __n, (_Tp) __val); }
-
-  template <class _InputIterator>
-  void _M_insert_dispatch(iterator __pos,
-                          _InputIterator __first, _InputIterator __last,
-                          __false_type) {
-    _M_range_insert(__pos, __first, __last, __ITERATOR_CATEGORY(__first));
-  }
-#else /* __STL_MEMBER_TEMPLATES */
-  void insert(iterator __position,
-              const_iterator __first, const_iterator __last);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  void insert (iterator __pos, size_type __n, const _Tp& __x)
-    { _M_fill_insert(__pos, __n, __x); }
-
-  void _M_fill_insert (iterator __pos, size_type __n, const _Tp& __x);
-
-  void pop_back() {
-    --_M_finish;
-    destroy(_M_finish);
-  }
-  iterator erase(iterator __position) {
-    if (__position + 1 != end())
-      copy(__position + 1, _M_finish, __position);
-    --_M_finish;
-    destroy(_M_finish);
-    return __position;
-  }
-  iterator erase(iterator __first, iterator __last) {
-    iterator __i = copy(__last, _M_finish, __first);
-    destroy(__i, _M_finish);
-    _M_finish = _M_finish - (__last - __first);
-    return __first;
-  }
-
-  void resize(size_type __new_size, const _Tp& __x) {
-    if (__new_size < size()) 
-      erase(begin() + __new_size, end());
-    else
-      insert(end(), __new_size - size(), __x);
-  }
-  void resize(size_type __new_size) { resize(__new_size, _Tp()); }
-  void clear() { erase(begin(), end()); }
-
-protected:
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _ForwardIterator>
-  iterator _M_allocate_and_copy(size_type __n, _ForwardIterator __first, 
-                                               _ForwardIterator __last)
-{
-    iterator __result = _M_allocate(__n);
-    __STL_TRY {
-      uninitialized_copy(__first, __last, __result);
-      return __result;
-    }
-    __STL_UNWIND(_M_deallocate(__result, __n));
-  }
-#else /* __STL_MEMBER_TEMPLATES */
-  iterator _M_allocate_and_copy(size_type __n, const_iterator __first, 
-                                               const_iterator __last)
-  {
-    iterator __result = _M_allocate(__n);
-    __STL_TRY {
-      uninitialized_copy(__first, __last, __result);
-      return __result;
-    }
-    __STL_UNWIND(_M_deallocate(__result, __n));
-  }
-#endif /* __STL_MEMBER_TEMPLATES */
-
-
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  void _M_range_initialize(_InputIterator __first,  
-                           _InputIterator __last, input_iterator_tag)
-  {
-    for ( ; __first != __last; ++__first)
-      push_back(*__first);
-  }
-
-  // This function is only called by the constructor. 
-  template <class _ForwardIterator>
-  void _M_range_initialize(_ForwardIterator __first,
-                           _ForwardIterator __last, forward_iterator_tag)
-  {
-    size_type __n = 0;
-    distance(__first, __last, __n);
-    _M_start = _M_allocate(__n);
-    _M_end_of_storage = _M_start + __n;
-    _M_finish = uninitialized_copy(__first, __last, _M_start);
-  }
-
-  template <class _InputIterator>
-  void _M_range_insert(iterator __pos,
-                       _InputIterator __first, _InputIterator __last,
-                       input_iterator_tag);
-
-  template <class _ForwardIterator>
-  void _M_range_insert(iterator __pos,
-                       _ForwardIterator __first, _ForwardIterator __last,
-                       forward_iterator_tag);
-
-#endif /* __STL_MEMBER_TEMPLATES */
-};
-
-template <class _Tp, class _Alloc>
-inline bool 
-operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
-{
-  return __x.size() == __y.size() &&
-         equal(__x.begin(), __x.end(), __y.begin());
-}
-
-template <class _Tp, class _Alloc>
-inline bool 
-operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
-{
-  return lexicographical_compare(__x.begin(), __x.end(), 
-                                 __y.begin(), __y.end());
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Tp, class _Alloc>
-inline void swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
-{
-  __x.swap(__y);
-}
-
-template <class _Tp, class _Alloc>
-inline bool
-operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {
-  return !(__x == __y);
-}
-
-template <class _Tp, class _Alloc>
-inline bool
-operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {
-  return __y < __x;
-}
-
-template <class _Tp, class _Alloc>
-inline bool
-operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {
-  return !(__y < __x);
-}
-
-template <class _Tp, class _Alloc>
-inline bool
-operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y) {
-  return !(__x < __y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-template <class _Tp, class _Alloc>
-vector<_Tp,_Alloc>& 
-vector<_Tp,_Alloc>::operator=(const vector<_Tp, _Alloc>& __x)
-{
-  if (&__x != this) {
-    const size_type __xlen = __x.size();
-    if (__xlen > capacity()) {
-      iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());
-      destroy(_M_start, _M_finish);
-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
-      _M_start = __tmp;
-      _M_end_of_storage = _M_start + __xlen;
-    }
-    else if (size() >= __xlen) {
-      iterator __i = copy(__x.begin(), __x.end(), begin());
-      destroy(__i, _M_finish);
-    }
-    else {
-      copy(__x.begin(), __x.begin() + size(), _M_start);
-      uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);
-    }
-    _M_finish = _M_start + __xlen;
-  }
-  return *this;
-}
-
-template <class _Tp, class _Alloc>
-void vector<_Tp, _Alloc>::_M_fill_assign(size_t __n, const value_type& __val) 
-{
-  if (__n > capacity()) {
-    vector<_Tp, _Alloc> __tmp(__n, __val, get_allocator());
-    __tmp.swap(*this);
-  }
-  else if (__n > size()) {
-    fill(begin(), end(), __val);
-    _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);
-  }
-  else
-    erase(fill_n(begin(), __n, __val), end());
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Alloc> template <class _InputIter>
-void vector<_Tp, _Alloc>::_M_assign_aux(_InputIter __first, _InputIter __last,
-                                        input_iterator_tag) {
-  iterator __cur = begin();
-  for ( ; __first != __last && __cur != end(); ++__cur, ++__first)
-    *__cur = *__first;
-  if (__first == __last)
-    erase(__cur, end());
-  else
-    insert(end(), __first, __last);
-}
-
-template <class _Tp, class _Alloc> template <class _ForwardIter>
-void
-vector<_Tp, _Alloc>::_M_assign_aux(_ForwardIter __first, _ForwardIter __last,
-                                   forward_iterator_tag) {
-  size_type __len = 0;
-  distance(__first, __last, __len);
-
-  if (__len > capacity()) {
-    iterator __tmp = _M_allocate_and_copy(__len, __first, __last);
-    destroy(_M_start, _M_finish);
-    _M_deallocate(_M_start, _M_end_of_storage - _M_start);
-    _M_start = __tmp;
-    _M_end_of_storage = _M_finish = _M_start + __len;
-  }
-  else if (size() >= __len) {
-    iterator __new_finish = copy(__first, __last, _M_start);
-    destroy(__new_finish, _M_finish);
-    _M_finish = __new_finish;
-  }
-  else {
-    _ForwardIter __mid = __first;
-    advance(__mid, size());
-    copy(__first, __mid, _M_start);
-    _M_finish = uninitialized_copy(__mid, __last, _M_finish);
-  }
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-void 
-vector<_Tp, _Alloc>::_M_insert_aux(iterator __position, const _Tp& __x)
-{
-  if (_M_finish != _M_end_of_storage) {
-    construct(_M_finish, *(_M_finish - 1));
-    ++_M_finish;
-    _Tp __x_copy = __x;
-    copy_backward(__position, _M_finish - 2, _M_finish - 1);
-    *__position = __x_copy;
-  }
-  else {
-    const size_type __old_size = size();
-
-#ifdef STM32PLUS_BUILD
-    const size_type __len = __old_size != 0 ? stm32plus::Stm32VectorAllocAhead<_Tp>(__old_size) : 1;
-#else
-    const size_type __len = __old_size != 0 ? 2 * __old_size : 1;
-#endif
-    iterator __new_start = _M_allocate(__len);
-    iterator __new_finish = __new_start;
-    __STL_TRY {
-      __new_finish = uninitialized_copy(_M_start, __position, __new_start);
-      construct(__new_finish, __x);
-      ++__new_finish;
-      __new_finish = uninitialized_copy(__position, _M_finish, __new_finish);
-    }
-    __STL_UNWIND((destroy(__new_start,__new_finish), 
-                  _M_deallocate(__new_start,__len)));
-    destroy(begin(), end());
-    _M_deallocate(_M_start, _M_end_of_storage - _M_start);
-    _M_start = __new_start;
-    _M_finish = __new_finish;
-    _M_end_of_storage = __new_start + __len;
-  }
-}
-
-template <class _Tp, class _Alloc>
-void 
-vector<_Tp, _Alloc>::_M_insert_aux(iterator __position)
-{
-  if (_M_finish != _M_end_of_storage) {
-    construct(_M_finish, *(_M_finish - 1));
-    ++_M_finish;
-    copy_backward(__position, _M_finish - 2, _M_finish - 1);
-    *__position = _Tp();
-  }
-  else {
-    const size_type __old_size = size();
-
-#ifdef STM32PLUS_BUILD
-    const size_type __len = __old_size != 0 ? stm32plus::Stm32VectorAllocAhead<_Tp>(__old_size) : 1;
-#else
-    const size_type __len = __old_size != 0 ? 2 * __old_size : 1;
-#endif
-    iterator __new_start = _M_allocate(__len);
-    iterator __new_finish = __new_start;
-    __STL_TRY {
-      __new_finish = uninitialized_copy(_M_start, __position, __new_start);
-      construct(__new_finish);
-      ++__new_finish;
-      __new_finish = uninitialized_copy(__position, _M_finish, __new_finish);
-    }
-    __STL_UNWIND((destroy(__new_start,__new_finish), 
-                  _M_deallocate(__new_start,__len)));
-    destroy(begin(), end());
-    _M_deallocate(_M_start, _M_end_of_storage - _M_start);
-    _M_start = __new_start;
-    _M_finish = __new_finish;
-    _M_end_of_storage = __new_start + __len;
-  }
-}
-
-template <class _Tp, class _Alloc>
-void vector<_Tp, _Alloc>::_M_fill_insert(iterator __position, size_type __n, 
-                                         const _Tp& __x)
-{
-  if (__n != 0) {
-    if (size_type(_M_end_of_storage - _M_finish) >= __n) {
-      _Tp __x_copy = __x;
-      const size_type __elems_after = _M_finish - __position;
-      iterator __old_finish = _M_finish;
-      if (__elems_after > __n) {
-        uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);
-        _M_finish += __n;
-        copy_backward(__position, __old_finish - __n, __old_finish);
-        fill(__position, __position + __n, __x_copy);
-      }
-      else {
-        uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);
-        _M_finish += __n - __elems_after;
-        uninitialized_copy(__position, __old_finish, _M_finish);
-        _M_finish += __elems_after;
-        fill(__position, __old_finish, __x_copy);
-      }
-    }
-    else {
-      const size_type __old_size = size();        
-      const size_type __len = __old_size + max(__old_size, __n);
-      iterator __new_start = _M_allocate(__len);
-      iterator __new_finish = __new_start;
-      __STL_TRY {
-        __new_finish = uninitialized_copy(_M_start, __position, __new_start);
-        __new_finish = uninitialized_fill_n(__new_finish, __n, __x);
-        __new_finish
-          = uninitialized_copy(__position, _M_finish, __new_finish);
-      }
-      __STL_UNWIND((destroy(__new_start,__new_finish), 
-                    _M_deallocate(__new_start,__len)));
-      destroy(_M_start, _M_finish);
-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
-      _M_start = __new_start;
-      _M_finish = __new_finish;
-      _M_end_of_storage = __new_start + __len;
-    }
-  }
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Alloc> template <class _InputIterator>
-void 
-vector<_Tp, _Alloc>::_M_range_insert(iterator __pos, 
-                                     _InputIterator __first, 
-                                     _InputIterator __last,
-                                     input_iterator_tag)
-{
-  for ( ; __first != __last; ++__first) {
-    __pos = insert(__pos, *__first);
-    ++__pos;
-  }
-}
-
-template <class _Tp, class _Alloc> template <class _ForwardIterator>
-void 
-vector<_Tp, _Alloc>::_M_range_insert(iterator __position,
-                                     _ForwardIterator __first,
-                                     _ForwardIterator __last,
-                                     forward_iterator_tag)
-{
-  if (__first != __last) {
-    size_type __n = 0;
-    distance(__first, __last, __n);
-    if (size_type(_M_end_of_storage - _M_finish) >= __n) {
-      const size_type __elems_after = _M_finish - __position;
-      iterator __old_finish = _M_finish;
-      if (__elems_after > __n) {
-        uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);
-        _M_finish += __n;
-        copy_backward(__position, __old_finish - __n, __old_finish);
-        copy(__first, __last, __position);
-      }
-      else {
-        _ForwardIterator __mid = __first;
-        advance(__mid, __elems_after);
-        uninitialized_copy(__mid, __last, _M_finish);
-        _M_finish += __n - __elems_after;
-        uninitialized_copy(__position, __old_finish, _M_finish);
-        _M_finish += __elems_after;
-        copy(__first, __mid, __position);
-      }
-    }
-    else {
-      const size_type __old_size = size();
-      const size_type __len = __old_size + max(__old_size, __n);
-      iterator __new_start = _M_allocate(__len);
-      iterator __new_finish = __new_start;
-      __STL_TRY {
-        __new_finish = uninitialized_copy(_M_start, __position, __new_start);
-        __new_finish = uninitialized_copy(__first, __last, __new_finish);
-        __new_finish
-          = uninitialized_copy(__position, _M_finish, __new_finish);
-      }
-      __STL_UNWIND((destroy(__new_start,__new_finish), 
-                    _M_deallocate(__new_start,__len)));
-      destroy(_M_start, _M_finish);
-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
-      _M_start = __new_start;
-      _M_finish = __new_finish;
-      _M_end_of_storage = __new_start + __len;
-    }
-  }
-}
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Alloc>
-void 
-vector<_Tp, _Alloc>::insert(iterator __position, 
-                            const_iterator __first, 
-                            const_iterator __last)
-{
-  if (__first != __last) {
-    size_type __n = 0;
-    distance(__first, __last, __n);
-    if (size_type(_M_end_of_storage - _M_finish) >= __n) {
-      const size_type __elems_after = _M_finish - __position;
-      iterator __old_finish = _M_finish;
-      if (__elems_after > __n) {
-        uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);
-        _M_finish += __n;
-        copy_backward(__position, __old_finish - __n, __old_finish);
-        copy(__first, __last, __position);
-      }
-      else {
-        uninitialized_copy(__first + __elems_after, __last, _M_finish);
-        _M_finish += __n - __elems_after;
-        uninitialized_copy(__position, __old_finish, _M_finish);
-        _M_finish += __elems_after;
-        copy(__first, __first + __elems_after, __position);
-      }
-    }
-    else {
-      const size_type __old_size = size();
-      const size_type __len = __old_size + max(__old_size, __n);
-      iterator __new_start = _M_allocate(__len);
-      iterator __new_finish = __new_start;
-      __STL_TRY {
-        __new_finish = uninitialized_copy(_M_start, __position, __new_start);
-        __new_finish = uninitialized_copy(__first, __last, __new_finish);
-        __new_finish
-          = uninitialized_copy(__position, _M_finish, __new_finish);
-      }
-      __STL_UNWIND((destroy(__new_start,__new_finish),
-                    _M_deallocate(__new_start,__len)));
-      destroy(_M_start, _M_finish);
-      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
-      _M_start = __new_start;
-      _M_finish = __new_finish;
-      _M_end_of_storage = __new_start + __len;
-    }
-  }
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE 
-
-#endif /* __SGI_STL_INTERNAL_VECTOR_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/stm32_config.h b/lib/include/stl/stm32_config.h
deleted file mode 100644
index cf7111f..0000000
--- a/lib/include/stl/stm32_config.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * This file is a part of the open source stm32plus library.
- * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
- * Please see website for licensing terms.
- */
-
-
-#pragma once
-
-#include <cstdio>
-#include <cstdlib>
-#include <string/StringUtil.h>
-
-
-namespace stm32plus {
-
-// default alloc-ahead for vectors. quoting from the SGI docs:
-//
-//   "It is crucial that the amount of growth is proportional to the current capacity(),
-//    rather than a fixed constant: in the former case inserting a series of elements
-//    into a vector is a linear time operation, and in the latter case it is quadratic."
-//
-// If this advice pertains to you, then uncomment the first line and comment out the second.
-// The default here on the stm32 is to assume that memory is scarce.
-
-//  template<typename T> size_t Stm32VectorAllocAhead(size_t oldSize_) { return 2*oldSize_; }
-  template<typename T> size_t Stm32VectorAllocAhead(size_t oldSize_) { return 20+oldSize_; }
-//  template<> size_t Stm32VectorAllocAhead<char>(size_t oldSize_) { return 20+oldSize_; }     // sample specialization for char
-
-// minimum buffer size allocated ahead by a deque
-
-  inline size_t Stm32DequeBufferSize() { return 20; }
-
-// alloc-ahead additional memory increment for strings. The default SGI implementation will add
-// the old size, doubling memory each time. We don't have memory to burn, so add 20 types each time
-
-  template<typename T> size_t Stm32StringAllocAheadIncrement(size_t) { return 20; }
-}
diff --git a/lib/include/stl/streambuf b/lib/include/stl/streambuf
deleted file mode 100644
index 0daa388..0000000
--- a/lib/include/stl/streambuf
+++ /dev/null
@@ -1,329 +0,0 @@
-/*	Copyright (C) 2004 Garrett A. Kajmowicz
-
-	This file is part of the uClibc++ Library.
-
-	This library is free software; you can redistribute it and/or
-	modify it under the terms of the GNU Lesser General Public
-	License as published by the Free Software Foundation; either
-	version 2.1 of the License, or (at your option) any later version.
-
-	This library is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-	Lesser General Public License for more details.
-
-	You should have received a copy of the GNU Lesser General Public
-	License along with this library; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-
-#include <basic_definitions>
-#include <locale>
-#include <string>
-#include <iosfwd>
-
-#ifndef HEADER_STD_STREAMBUF
-#define HEADER_STD_STREAMBUF 1
-
-#include <ios>
-
-#pragma GCC visibility push(default)
-
-namespace std{
-
-	template <class charT, class traits> class _UCXXEXPORT basic_streambuf{
-	public:
-#ifdef __UCLIBCXX_SUPPORT_CDIR__
-		friend ios_base::Init::Init();
-#endif
-	// Types:
-		typedef charT				char_type;
-		typedef typename traits::int_type	int_type;
-		typedef typename traits::pos_type	pos_type;
-		typedef typename traits::off_type	off_type;
-		typedef traits				traits_type;
-
-		virtual ~basic_streambuf();
-
-		locale pubimbue(const locale &loc);
-
-		locale getloc() const{
-			return myLocale;
-		}
-
-		basic_streambuf<char_type,traits>* pubsetbuf(char_type* s, streamsize n){
-			return setbuf(s,n);
-		}
-		pos_type pubseekoff(off_type off, 
-			typename ios_base::seekdir way, 
-			ios_base::openmode which = ios_base::in |
-			ios_base::out
-			)
-		{
-			return seekoff(off,way,which);
-		}
-		pos_type pubseekpos(pos_type sp, ios_base::openmode which = ios_base::in | ios_base::out){
-			return seekpos(sp,which);
-		}
-		int pubsync(){
-			return sync();
-		}
-
-		streamsize in_avail();
-
-		int_type snextc();
-
-		int_type sbumpc();
-
-		int_type sgetc();
-
-		streamsize sgetn(char_type* s, streamsize n){
-			return xsgetn(s,n);
-		}
-
-		int_type sputbackc(char_type c);
-
-		int_type sungetc();
-
-		int_type sputc(char_type c);
-
-		streamsize sputn(const char_type* s, streamsize n){
-			if(openedFor & ios_base::app){
-				seekoff(0, ios_base::end, ios_base::out);
-			}
-			return xsputn(s, n);
-		}
-
-	protected:
-		locale myLocale;
-		//Pointers for the "get" buffers
-		charT * mgbeg;
-		charT * mgnext;
-		charT * mgend;
-
-		//Pointers for the "put" buffers	
-		charT * mpbeg;
-		charT * mpnext;
-		charT * mpend;
-
-		//In the event of null buffers Lets us know what the buffer is opened for
-		ios_base::openmode openedFor;
-		
-		basic_streambuf();
-
-		basic_streambuf(const basic_streambuf<char, char_traits<char> > &)
-			: myLocale(),
-			mgbeg(0), mgnext(0), mgend(0), mpbeg(0), mpnext(0), mpend(0),
-			openedFor(0)
-		{ }
-		basic_streambuf<char, char_traits<char> > & operator=(const basic_streambuf<char, char_traits<char> > &){
-			return *this;
-		}
-		
-		char_type* eback() const{
-			return mgbeg;
-		}
-		char_type* gptr()  const{
-			return mgnext;
-		}
-		char_type* egptr() const{
-			return mgend;
-		}
-		void gbump(int n){
-			mgnext+=n;
-		}
-		void setg(char_type* gbeg, char_type* gnext, char_type* gend){
-			mgbeg = gbeg;
-			mgnext = gnext;
-			mgend = gend;
-		}
-
-		char_type* pbase() const{
-			return mpbeg;
-		}
-		char_type* pptr() const{
-			return mpnext;
-		}
-		char_type* epptr() const{
-			return mpend;
-		}
-		void pbump(int n){
-			mpnext+=n;
-		}
-		void setp(char_type* pbeg, char_type* pend){
-			mpbeg = pbeg;
-			mpnext  = pbeg;
-			mpend = pend;
-		}
-
-		virtual void imbue(const locale &loc){
-			myLocale = loc;
-		}
-
-		//Virtual functions which we will not implement
-
-		virtual basic_streambuf<char_type,traits>* setbuf(char_type* , streamsize){
-			return 0;
-		}
-		virtual pos_type seekoff(off_type , ios_base::seekdir, 
-			ios_base::openmode = ios_base::in | ios_base::out)
-		{
-			return 0;
-		}
-		virtual pos_type seekpos(pos_type , ios_base::openmode = ios_base::in | ios_base::out){
-			return 0;
-		}
-		virtual int sync(){
-			return 0;
-		}
-
-		virtual int showmanyc(){
-			return 0;
-		}
-		virtual streamsize xsgetn(char_type* , streamsize ){
-			return 0;
-		}
-		virtual int_type underflow(){
-			return traits_type::eof();
-		}
-		virtual int_type uflow(){
-			int_type ret = underflow();
-			if (!traits_type::eq_int_type(ret, traits_type::eof()))
-				gbump(1);
-			return ret;
-		}
-
-		virtual int_type pbackfail(int_type c = traits::eof()){
-			return c;
-		}
-		virtual streamsize xsputn(const char_type* c, streamsize n){
-			//This function is designed to be replaced by subclasses
-			for(streamsize i = 0; i< n; ++i){
-				if(sputc(c[i]) == traits::eof()){
-					return i;
-				}
-			}
-			return n;
-		}
-		virtual int_type overflow (int_type c = traits::eof()){
-			return c;
-		}
-	};
-
-	typedef basic_streambuf<char>     streambuf;
-#ifdef __UCLIBCXX_HAS_WCHAR__
-	typedef basic_streambuf<wchar_t> wstreambuf;
-#endif
-
-
-//Definitions put below to allow for easy expansion of code
-
-	template <class C, class T> basic_streambuf<C, T>::~basic_streambuf(){  }
-
-	template <class C, class T> locale basic_streambuf<C, T>::pubimbue(const locale &loc){
-		locale temp = myLocale;
-		myLocale = loc;
-		return temp;
-	}
-
-	template <class C, class T> streamsize basic_streambuf<C, T>::in_avail(){
-		if(mgend !=0 && mgnext !=0){
-			return mgend - mgnext;
-		}
-		return showmanyc();
-	}
-
-	template <class C, class T> typename basic_streambuf<C, T>::int_type basic_streambuf<C, T>::sbumpc(){
-		if(mgbeg == 0 || mgnext == mgend){
-			return uflow();
-		}
-		int_type retval = T::to_int_type(*gptr());
-		gbump(1);
-		return retval;
-	}
-
-	template <class C, class T> typename basic_streambuf<C, T>::int_type basic_streambuf<C, T>::snextc(){
-		if(sbumpc() == T::eof() ){
-			return T::eof() ;
-		}
-		return sgetc();
-	}
-
-	template <class C, class T> typename basic_streambuf<C, T>::int_type basic_streambuf<C, T>::sgetc(){
-		if(mgbeg == 0 || mgnext == mgend){
-			return underflow();
-		}
-		return T::to_int_type(*gptr());
-	}
-
-	template <class C, class T> typename basic_streambuf<C, T>::int_type basic_streambuf<C, T>::sputbackc(char_type c){
-		if(mgbeg == 0 || mgnext == mgbeg || !T::eq(c, gptr()[-1] )){
-			return pbackfail(T::to_int_type(c));
-		}
-		gbump(-1);
-		return T::to_int_type(*gptr());
-	}
-
-	template <class C, class T> typename basic_streambuf<C, T>::int_type basic_streambuf<C, T>::sungetc(){
-		if(mgbeg == 0 || mgnext == mgbeg){
-			return ios_base::failbit;
-		}
-		gbump(-1);
-		return T::to_int_type(*gptr());
-	}
-
-	template <class C, class T> typename basic_streambuf<C, T>::int_type basic_streambuf<C, T>::sputc(char_type c){
-		if(openedFor & ios_base::app){
-			seekoff(0, ios_base::end, ios_base::out);
-		}
-		if(mpnext < mpend){
-			*mpnext = c;
-			++mpnext;
-		}else{
-			return overflow( T::to_int_type(c) );
-		}
-		return T::to_int_type(c);
-	}
-
-	template <class C, class T> basic_streambuf<C, T>::basic_streambuf() 
-		: myLocale(),
-		mgbeg(0), mgnext(0), mgend(0), mpbeg(0), mpnext(0), mpend(0),
-		openedFor(0)
-	{ }
-
-
-
-
-
-
-#ifdef __UCLIBCXX_EXPAND_STREAMBUF_CHAR__
-#ifndef __UCLIBCXX_COMPILE_STREAMBUF__
-
-#ifdef __UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-
-	template <> _UCXXEXPORT streambuf::basic_streambuf();
-	template <> _UCXXEXPORT streambuf::~basic_streambuf();
-
-#endif //__UCLIBCXX_EXPAND_CONSTRUCTORS_DESTRUCTORS__
-
-	template <> _UCXXEXPORT locale streambuf::pubimbue(const locale &loc);
-	template <> _UCXXEXPORT streamsize streambuf::in_avail();
-	template <> _UCXXEXPORT streambuf::int_type streambuf::sbumpc();
-	template <> _UCXXEXPORT streambuf::int_type streambuf::snextc();
-	template <> _UCXXEXPORT streambuf::int_type streambuf::sgetc();
-	template <> _UCXXEXPORT streambuf::int_type streambuf::sputbackc(char_type c);
-	template <> _UCXXEXPORT streambuf::int_type streambuf::sungetc();
-	template <> _UCXXEXPORT streambuf::int_type streambuf::sputc(char_type c);
-
-#endif
-#endif
-
-
-
-
-
-}
-
-#pragma GCC visibility pop
-
-#endif
diff --git a/lib/include/stl/string b/lib/include/stl/string
deleted file mode 100644
index f928846..0000000
--- a/lib/include/stl/string
+++ /dev/null
@@ -1,2453 +0,0 @@
-/*
- * Copyright (c) 1997-1999
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */ 
-
-#ifndef __SGI_STL_STRING
-#define __SGI_STL_STRING
-
-#include <stl_config.h>
-#include <stl_string_fwd.h>
-#include <ctype.h>        
-#include <functional>
-#include <stl_ctraits_fns.h>
-
-#ifndef STM32PLUS_BUILD
-#include <stdexcept>
-#endif
-
-#include <stl_iterator_base.h>
-#include <memory>
-#include <algorithm>
-
-#ifdef __STL_USE_NEW_IOSTREAMS
-#include <ios>
-#include <istream>
-#else /* __STL_USE_NEW_IOSTREAMS */
-#include <char_traits.h>
-#endif /* __STL_USE_NEW_IOSTREAMS */
-
-// Standard C++ string class.  This class has performance
-// characteristics very much like vector<>, meaning, for example, that
-// it does not perform reference-count or copy-on-write, and that
-// concatenation of two strings is an O(N) operation. 
-
-// There are three reasons why basic_string is not identical to
-// vector.  First, basic_string always stores a null character at the
-// end; this makes it possible for c_str to be a fast operation.
-// Second, the C++ standard requires basic_string to copy elements
-// using char_traits<>::assign, char_traits<>::copy, and
-// char_traits<>::move.  This means that all of vector<>'s low-level
-// operations must be rewritten.  Third, basic_string<> has a lot of
-// extra functions in its interface that are convenient but, strictly
-// speaking, redundant.
-
-// Additionally, the C++ standard imposes a major restriction: according
-// to the standard, the character type _CharT must be a POD type.  This
-// implementation weakens that restriction, and allows _CharT to be a
-// a user-defined non-POD type.  However, _CharT must still have a
-// default constructor.
-
-__STL_BEGIN_NAMESPACE
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma set woff 1174
-#pragma set woff 1375
-#endif
-
-// A helper class to use a char_traits as a function object.
-
-template <class _Traits>
-struct _Not_within_traits
-  : public unary_function<typename _Traits::char_type, bool>
-{
-  typedef const typename _Traits::char_type* _Pointer;
-  const _Pointer _M_first;
-  const _Pointer _M_last;
-
-  _Not_within_traits(_Pointer __f, _Pointer __l) 
-    : _M_first(__f), _M_last(__l) {}
-
-  bool operator()(const typename _Traits::char_type& __x) const {
-    return find_if(_M_first, _M_last, 
-                   bind1st(_Eq_traits<_Traits>(), __x)) == _M_last;
-  }
-};
-
-// ------------------------------------------------------------
-// Class _String_base.  
-
-// _String_base is a helper class that makes it it easier to write an
-// exception-safe version of basic_string.  The constructor allocates,
-// but does not initialize, a block of memory.  The destructor
-// deallocates, but does not destroy elements within, a block of
-// memory.  The destructor assumes that _M_start either is null, or else
-// points to a block of memory that was allocated using _String_base's 
-// allocator and whose size is _M_end_of_storage - _M_start.
-
-// Additionally, _String_base encapsulates the difference between
-// old SGI-style allocators and standard-conforming allocators.
-
-#ifdef __STL_USE_STD_ALLOCATORS
-
-// General base class.
-template <class _Tp, class _Alloc, bool _S_instanceless>
-class _String_alloc_base {
-public:
-  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _M_data_allocator; }
-
-  _String_alloc_base(const allocator_type& __a)
-    : _M_data_allocator(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
-    {}
-
-protected:
-  _Tp* _M_allocate(size_t __n)
-    { return _M_data_allocator.allocate(__n); }
-  void _M_deallocate(_Tp* __p, size_t __n) {
-    if (__p)
-      _M_data_allocator.deallocate(__p, __n); 
-  }
-
-protected:
-  allocator_type _M_data_allocator;
-
-  _Tp* _M_start;
-  _Tp* _M_finish;
-  _Tp* _M_end_of_storage;
-};
-
-// Specialization for instanceless allocators.
-template <class _Tp, class _Alloc>
-class _String_alloc_base<_Tp,_Alloc,true> {
-public:
-  typedef typename _Alloc_traits<_Tp, _Alloc>::allocator_type allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-  _String_alloc_base(const allocator_type&)
-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) {}
-
-protected:
-  typedef typename _Alloc_traits<_Tp, _Alloc>::_Alloc_type _Alloc_type;
-  _Tp* _M_allocate(size_t __n)
-    { return _Alloc_type::allocate(__n); }
-  void _M_deallocate(_Tp* __p, size_t __n)
-    { _Alloc_type::deallocate(__p, __n); }
-
-protected:
-  _Tp* _M_start;
-  _Tp* _M_finish;
-  _Tp* _M_end_of_storage;
-};
-
-template <class _Tp, class _Alloc>
-class _String_base 
-  : public _String_alloc_base<_Tp, _Alloc,
-                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-{
-protected:
-  typedef _String_alloc_base<_Tp, _Alloc,
-                             _Alloc_traits<_Tp, _Alloc>::_S_instanceless>
-          _Base;
-  typedef typename _Base::allocator_type allocator_type;
-
-  void _M_allocate_block(size_t __n) { 
-    if (__n <= max_size()) {
-      _Base::_M_start  = _Base::_M_allocate(__n);
-      _Base::_M_finish = _Base::_M_start;
-      _Base::_M_end_of_storage = _Base::_M_start + __n;
-    }
-    else
-      _M_throw_length_error();
-  }
-
-  void _M_deallocate_block() 
-    { this->_M_deallocate(_Base::_M_start, _Base::_M_end_of_storage - _Base::_M_start); }
-  
-  size_t max_size() const { return (size_t(-1) / sizeof(_Tp)) - 1; }
-
-  _String_base(const allocator_type& __a) : _Base(__a) { }
-  
-  _String_base(const allocator_type& __a, size_t __n) : _Base(__a)
-    { _M_allocate_block(__n); }
-
-  ~_String_base() { this->_M_deallocate_block(); }
-
-  void _M_throw_length_error() const;
-  void _M_throw_out_of_range() const;
-};
-
-#else /* __STL_USE_STD_ALLOCATORS */
-
-template <class _Tp, class _Alloc> class _String_base {
-public:
-  typedef _Alloc allocator_type;
-  allocator_type get_allocator() const { return allocator_type(); }
-
-protected:
-  typedef simple_alloc<_Tp, _Alloc> _Alloc_type;
-
-  _Tp* _M_start;
-  _Tp* _M_finish;
-  _Tp* _M_end_of_storage;
-                                // Precondition: 0 < __n <= max_size().
-
-  _Tp* _M_allocate(size_t __n) { return _Alloc_type::allocate(__n); }
-  void _M_deallocate(_Tp* __p, size_t __n) {
-    if (__p)
-      _Alloc_type::deallocate(__p, __n); 
-  }
-
-  void _M_allocate_block(size_t __n) { 
-    if (__n <= max_size()) {
-      _M_start  = _M_allocate(__n);
-      _M_finish = _M_start;
-      _M_end_of_storage = _M_start + __n;
-    }
-    else
-      _M_throw_length_error();
-  }
-
-  void _M_deallocate_block() 
-    { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }
-  
-  size_t max_size() const { return (size_t(-1) / sizeof(_Tp)) - 1; }
-
-  _String_base(const allocator_type&)
-    : _M_start(0), _M_finish(0), _M_end_of_storage(0) { }
-  
-  _String_base(const allocator_type&, size_t __n)
-    : _M_start(0), _M_finish(0), _M_end_of_storage(0)
-    { _M_allocate_block(__n); }
-
-  ~_String_base() { _M_deallocate_block(); }
-
-  void _M_throw_length_error() const;
-  void _M_throw_out_of_range() const;
-};
-
-#endif /* __STL_USE_STD_ALLOCATORS */
-
-// Helper functions for exception handling.
-template <class _Tp, class _Alloc> 
-void _String_base<_Tp,_Alloc>::_M_throw_length_error() const {
-  __STL_THROW(length_error("basic_string"));
-}
-
-template <class _Tp, class _Alloc> 
-void _String_base<_Tp, _Alloc>::_M_throw_out_of_range() const {
-  __STL_THROW(out_of_range("basic_string"));
-}
-
-
-// ------------------------------------------------------------
-// Class basic_string.  
-
-// Class invariants:
-// (1) [start, finish) is a valid range.
-// (2) Each iterator in [start, finish) points to a valid object
-//     of type value_type.
-// (3) *finish is a valid object of type value_type; in particular,
-//     it is value_type().
-// (4) [finish + 1, end_of_storage) is a valid range.
-// (5) Each iterator in [finish + 1, end_of_storage) points to 
-//     unininitialized memory.
-
-// Note one important consequence: a string of length n must manage
-// a block of memory whose size is at least n + 1.  
-
-
-template <class _CharT, class _Traits, class _Alloc> 
-class basic_string : private _String_base<_CharT,_Alloc> {
-public:
-  typedef _CharT value_type;
-  typedef _Traits traits_type;
-
-  typedef value_type* pointer;
-  typedef const value_type* const_pointer;
-  typedef value_type& reference;
-  typedef const value_type& const_reference;
-  typedef size_t size_type;
-  typedef ptrdiff_t difference_type;
-
-  typedef const value_type*                const_iterator;
-  typedef value_type*                      iterator;
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
-  typedef std::reverse_iterator<iterator>       reverse_iterator;
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-  typedef reverse_iterator<const_iterator, value_type, const_reference, 
-                           difference_type>  
-          const_reverse_iterator;
-  typedef reverse_iterator<iterator, value_type, reference, difference_type>
-          reverse_iterator; 
-#endif /* __STL_PARTIAL_SPECIALIZATION */
-
-  static const size_type npos;
-
-  typedef _String_base<_CharT,_Alloc> _Base;
-
-public:                         // Constructor, destructor, assignment.
-  typedef typename _Base::allocator_type allocator_type;
-  allocator_type get_allocator() const { return _Base::get_allocator(); }
-
-  explicit basic_string(const allocator_type& __a = allocator_type())
-    : _Base(__a, 8) { _M_terminate_string(); }
-
-  struct _Reserve_t {};
-  basic_string(_Reserve_t, size_t __n,
-               const allocator_type& __a = allocator_type())
-    : _Base(__a, __n + 1) { _M_terminate_string(); }
-
-  basic_string(const basic_string& __s) : _Base(__s.get_allocator()) 
-    { _M_range_initialize(__s.begin(), __s.end()); }
-
-  basic_string(const basic_string& __s, size_type __pos, size_type __n = npos,
-               const allocator_type& __a = allocator_type()) 
-    : _Base(__a) {
-    if (__pos > __s.size())
-      _M_throw_out_of_range();
-    else
-      _M_range_initialize(__s.begin() + __pos,
-                          __s.begin() + __pos + min(__n, __s.size() - __pos));
-  }
-
-  basic_string(const _CharT* __s, size_type __n,
-               const allocator_type& __a = allocator_type()) 
-    : _Base(__a) 
-    { _M_range_initialize(__s, __s + __n); }
-
-  basic_string(const _CharT* __s,
-               const allocator_type& __a = allocator_type())
-    : _Base(__a) 
-    { _M_range_initialize(__s, __s + _Traits::length(__s)); }
-
-  basic_string(size_type __n, _CharT __c,
-               const allocator_type& __a = allocator_type())
-    : _Base(__a, __n + 1)
-  {
-    _M_finish = uninitialized_fill_n(_M_start, __n, __c);
-    _M_terminate_string();
-  }
-
-  // Check to see if _InputIterator is an integer type.  If so, then
-  // it can't be an iterator.
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIterator>
-  basic_string(_InputIterator __f, _InputIterator __l,
-               const allocator_type& __a = allocator_type())
-    : _Base(__a)
-  {
-    typedef typename _Is_integer<_InputIterator>::_Integral _Integral;
-    _M_initialize_dispatch(__f, __l, _Integral());
-  }
-#else /* __STL_MEMBER_TEMPLATES */
-  basic_string(const _CharT* __f, const _CharT* __l,
-               const allocator_type& __a = allocator_type())
-    : _Base(__a)
-  {
-    _M_range_initialize(__f, __l);
-  }
-#endif
-
-  ~basic_string() { destroy(_M_start, _M_finish + 1); }
-    
-  basic_string& operator=(const basic_string& __s) {
-    if (&__s != this) 
-      assign(__s.begin(), __s.end());
-    return *this;
-  }
-
-  basic_string& operator=(const _CharT* __s) 
-    { return assign(__s, __s + _Traits::length(__s)); }
-
-  basic_string& operator=(_CharT __c)
-    { return assign(static_cast<size_type>(1), __c); }
-
-protected:                      // Protected members inherited from base.
-#ifdef __STL_HAS_NAMESPACES
-  using _Base::_M_allocate;
-  using _Base::_M_deallocate;
-  using _Base::_M_allocate_block;
-  using _Base::_M_deallocate_block;
-  using _Base::_M_throw_length_error;
-  using _Base::_M_throw_out_of_range;
-
-  using _Base::_M_start;
-  using _Base::_M_finish;
-  using _Base::_M_end_of_storage;
-#endif /* __STL_HAS_NAMESPACES */
-
-private:                        // Helper functions used by constructors
-                                // and elsewhere.
-  void _M_construct_null(_CharT* __p) {
-    construct(__p);
-#   ifdef __STL_DEFAULT_CONSTRUCTOR_BUG
-    __STL_TRY {
-      *__p = (_CharT) 0;
-    }
-    __STL_UNWIND(destroy(__p));
-#   endif
-  }
-
-  static _CharT _M_null() {
-#   ifndef __STL_DEFAULT_CONSTRUCTOR_BUG
-    return _CharT();
-#   else
-    return (_CharT) 0;
-#   endif
-  }
-
-private:                        
-  // Helper functions used by constructors.  It is a severe error for
-  // any of them to be called anywhere except from within constructors.
-
-  void _M_terminate_string() {
-    __STL_TRY {
-      _M_construct_null(_M_finish);
-    }
-    __STL_UNWIND(destroy(_M_start, _M_finish));
-  }
-
-#ifdef __STL_MEMBER_TEMPLATES
-    
-  template <class _InputIter>
-  void _M_range_initialize(_InputIter __f, _InputIter __l,
-                           input_iterator_tag) {
-    _M_allocate_block(8);
-    _M_construct_null(_M_finish);
-    __STL_TRY {
-      append(__f, __l);
-    }
-    __STL_UNWIND(destroy(_M_start, _M_finish + 1));
-  }
-
-  template <class _ForwardIter>
-  void _M_range_initialize(_ForwardIter __f, _ForwardIter __l, 
-                           forward_iterator_tag) {
-    difference_type __n = 0;
-    distance(__f, __l, __n);
-    _M_allocate_block(__n + 1);
-    _M_finish = uninitialized_copy(__f, __l, _M_start);
-    _M_terminate_string();
-  }
-
-  template <class _InputIter>
-  void _M_range_initialize(_InputIter __f, _InputIter __l) {
-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;
-    _M_range_initialize(__f, __l, _Category());
-  }
-
-  template <class _Integer>
-  void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {
-    _M_allocate_block(__n + 1);
-    _M_finish = uninitialized_fill_n(_M_start, __n, __x);
-    _M_terminate_string();
-  }
-
-  template <class _InputIter>
-  void _M_initialize_dispatch(_InputIter __f, _InputIter __l, __false_type) {
-     _M_range_initialize(__f, __l);
-  }
-    
-#else /* __STL_MEMBER_TEMPLATES */
-
-  void _M_range_initialize(const _CharT* __f, const _CharT* __l) {
-    ptrdiff_t __n = __l - __f;
-    _M_allocate_block(__n + 1);
-    _M_finish = uninitialized_copy(__f, __l, _M_start);
-    _M_terminate_string();
-  }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:                         // Iterators.
-  iterator begin()             { return _M_start; }
-  iterator end()               { return _M_finish; }
-  const_iterator begin() const { return _M_start; }
-  const_iterator end()   const { return _M_finish; }  
-
-  reverse_iterator rbegin()             
-    { return reverse_iterator(_M_finish); }
-  reverse_iterator rend()               
-    { return reverse_iterator(_M_start); }
-  const_reverse_iterator rbegin() const 
-    { return const_reverse_iterator(_M_finish); }
-  const_reverse_iterator rend()   const 
-    { return const_reverse_iterator(_M_start); }
-
-public:                         // Size, capacity, etc.
-  size_type size() const { return _M_finish - _M_start; }
-  size_type length() const { return size(); }
-
-  size_t max_size() const { return _Base::max_size(); }
-
-
-  void resize(size_type __n, _CharT __c) {
-    if (__n <= size())
-      erase(begin() + __n, end());
-    else
-      append(__n - size(), __c);
-  }
-
-  void resize(size_type __n) { resize(__n, _M_null()); }
-
-  void reserve(size_type = 0);
-
-  size_type capacity() const { return (_M_end_of_storage - _M_start) - 1; }
-
-  void clear() {
-    if (!empty()) {
-      _Traits::assign(*_M_start, _M_null());
-      destroy(_M_start+1, _M_finish+1);
-      _M_finish = _M_start;
-    }
-  } 
-
-  bool empty() const { return _M_start == _M_finish; }    
-
-public:                         // Element access.
-
-  const_reference operator[](size_type __n) const
-    { return *(_M_start + __n); }
-  reference operator[](size_type __n)
-    { return *(_M_start + __n); }
-
-  const_reference at(size_type __n) const {
-    if (__n >= size())
-      _M_throw_out_of_range();
-    return *(_M_start + __n);
-  }
-
-  reference at(size_type __n) {
-    if (__n >= size())
-      _M_throw_out_of_range();
-    return *(_M_start + __n);
-  }
-
-public:                         // Append, operator+=, push_back.
-
-  basic_string& operator+=(const basic_string& __s) { return append(__s); }
-  basic_string& operator+=(const _CharT* __s) { return append(__s); }
-  basic_string& operator+=(_CharT __c) { push_back(__c); return *this; }
-
-  basic_string& append(const basic_string& __s) 
-    { return append(__s.begin(), __s.end()); }
-
-  basic_string& append(const basic_string& __s,
-                       size_type __pos, size_type __n)
-  {
-    if (__pos > __s.size())
-      _M_throw_out_of_range();
-    return append(__s.begin() + __pos,
-                  __s.begin() + __pos + min(__n, __s.size() - __pos));
-  }
-
-  basic_string& append(const _CharT* __s, size_type __n) 
-    { return append(__s, __s+__n); }
-
-  basic_string& append(const _CharT* __s) 
-    { return append(__s, __s + _Traits::length(__s)); }
-
-  basic_string& append(size_type __n, _CharT __c);
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  // Check to see if _InputIterator is an integer type.  If so, then
-  // it can't be an iterator.
-  template <class _InputIter>
-  basic_string& append(_InputIter __first, _InputIter __last) {
-    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
-    return _M_append_dispatch(__first, __last, _Integral());
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-  basic_string& append(const _CharT* __first, const _CharT* __last);
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  void push_back(_CharT __c) {
-    if (_M_finish + 1 == _M_end_of_storage)
-      reserve(size() + max(size(), static_cast<size_type>(1)));
-    _M_construct_null(_M_finish + 1);
-    _Traits::assign(*_M_finish, __c);
-    ++_M_finish;
-  }
-
-  void pop_back() {
-    _Traits::assign(*(_M_finish - 1), _M_null());
-    destroy(_M_finish);
-    --_M_finish;
-  }
-
-private:                        // Helper functions for append.
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  template <class _InputIter>
-  basic_string& append(_InputIter __f, _InputIter __l, input_iterator_tag);
-
-  template <class _ForwardIter>
-  basic_string& append(_ForwardIter __f, _ForwardIter __l, 
-                       forward_iterator_tag);
-
-  template <class _Integer>
-  basic_string& _M_append_dispatch(_Integer __n, _Integer __x, __true_type) {
-    return append((size_type) __n, (_CharT) __x);
-  }
-
-  template <class _InputIter>
-  basic_string& _M_append_dispatch(_InputIter __f, _InputIter __l,
-                                   __false_type) {
-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;
-    return append(__f, __l, _Category());
-  }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:                         // Assign
-  
-  basic_string& assign(const basic_string& __s) 
-    { return assign(__s.begin(), __s.end()); }
-
-  basic_string& assign(const basic_string& __s, 
-                       size_type __pos, size_type __n) {
-    if (__pos > __s.size())
-      _M_throw_out_of_range();
-    return assign(__s.begin() + __pos, 
-                  __s.begin() + __pos + min(__n, __s.size() - __pos));
-  }
-
-  basic_string& assign(const _CharT* __s, size_type __n)
-    { return assign(__s, __s + __n); }
-
-  basic_string& assign(const _CharT* __s)
-    { return assign(__s, __s + _Traits::length(__s)); }
-
-  basic_string& assign(size_type __n, _CharT __c);
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  // Check to see if _InputIterator is an integer type.  If so, then
-  // it can't be an iterator.
-  template <class _InputIter>
-  basic_string& assign(_InputIter __first, _InputIter __last) {
-    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
-    return _M_assign_dispatch(__first, __last, _Integral());
-  }
-
-#endif  /* __STL_MEMBER_TEMPLATES */
-
-  basic_string& assign(const _CharT* __f, const _CharT* __l);
-
-private:                        // Helper functions for assign.
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  template <class _Integer>
-  basic_string& _M_assign_dispatch(_Integer __n, _Integer __x, __true_type) {
-    return assign((size_type) __n, (_CharT) __x);
-  }
-
-  template <class _InputIter>
-  basic_string& _M_assign_dispatch(_InputIter __f, _InputIter __l,
-                                   __false_type);
-
-#endif  /* __STL_MEMBER_TEMPLATES */
-
-public:                         // Insert
-
-  basic_string& insert(size_type __pos, const basic_string& __s) {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    if (size() > max_size() - __s.size())
-      _M_throw_length_error();
-    insert(_M_start + __pos, __s.begin(), __s.end());
-    return *this;
-  }
-
-  basic_string& insert(size_type __pos, const basic_string& __s,
-                       size_type __beg, size_type __n) {
-    if (__pos > size() || __beg > __s.size())
-      _M_throw_out_of_range();
-    size_type __len = min(__n, __s.size() - __beg);
-    if (size() > max_size() - __len)
-      _M_throw_length_error();
-    insert(_M_start + __pos,
-           __s.begin() + __beg, __s.begin() + __beg + __len);
-    return *this;
-  }
-
-  basic_string& insert(size_type __pos, const _CharT* __s, size_type __n) {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    if (size() > max_size() - __n)
-      _M_throw_length_error();
-    insert(_M_start + __pos, __s, __s + __n);
-    return *this;
-  }
-
-  basic_string& insert(size_type __pos, const _CharT* __s) {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    size_type __len = _Traits::length(__s);
-    if (size() > max_size() - __len)
-      _M_throw_length_error();
-    insert(_M_start + __pos, __s, __s + __len);
-    return *this;
-  }
-    
-  basic_string& insert(size_type __pos, size_type __n, _CharT __c) {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    if (size() > max_size() - __n)
-      _M_throw_length_error();
-    insert(_M_start + __pos, __n, __c);
-    return *this;
-  }
-
-  iterator insert(iterator __p, _CharT __c) {
-    if (__p == _M_finish) {
-      push_back(__c);
-      return _M_finish - 1;
-    }
-    else
-      return _M_insert_aux(__p, __c);
-  }
-
-  void insert(iterator __p, size_t __n, _CharT __c);
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  // Check to see if _InputIterator is an integer type.  If so, then
-  // it can't be an iterator.
-  template <class _InputIter>
-  void insert(iterator __p, _InputIter __first, _InputIter __last) {
-    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
-    _M_insert_dispatch(__p, __first, __last, _Integral());
-  }
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-  void insert(iterator __p, const _CharT* __first, const _CharT* __last);
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-private:                        // Helper functions for insert.
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  template <class _InputIter>
-  void insert(iterator __p, _InputIter, _InputIter, input_iterator_tag);
-
-  template <class _ForwardIter>
-  void insert(iterator __p, _ForwardIter, _ForwardIter, forward_iterator_tag);
-
-
-  template <class _Integer>
-  void _M_insert_dispatch(iterator __p, _Integer __n, _Integer __x,
-                          __true_type) {
-    insert(__p, (size_type) __n, (_CharT) __x);
-  }
-
-  template <class _InputIter>
-  void _M_insert_dispatch(iterator __p, _InputIter __first, _InputIter __last,
-                          __false_type) {
-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;
-    insert(__p, __first, __last, _Category());
-  }
-
-  template <class _InputIterator>
-  void 
-  _M_copy(_InputIterator __first, _InputIterator __last, iterator __result) {
-    for ( ; __first != __last; ++__first, ++__result)
-      _Traits::assign(*__result, *__first);
-  }
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-  iterator _M_insert_aux(iterator, _CharT);
-
-  void 
-  _M_copy(const _CharT* __first, const _CharT* __last, _CharT* __result) {
-    _Traits::copy(__result, __first, __last - __first);
-  }
-
-public:                         // Erase.
-
-  basic_string& erase(size_type __pos = 0, size_type __n = npos) {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    erase(_M_start + __pos, _M_start + __pos + min(__n, size() - __pos));
-    return *this;
-  }  
-
-  iterator erase(iterator __position) {
-                                // The move includes the terminating null.
-    _Traits::move(__position, __position + 1, _M_finish - __position);
-    destroy(_M_finish);
-    --_M_finish;
-    return __position;
-  }
-
-  iterator erase(iterator __first, iterator __last) {
-    if (__first != __last) {
-                                // The move includes the terminating null.
-      _Traits::move(__first, __last, (_M_finish - __last) + 1);
-      const iterator __new_finish = _M_finish - (__last - __first);
-      destroy(__new_finish + 1, _M_finish + 1);
-      _M_finish = __new_finish;
-    }
-    return __first;
-  }
-
-public:                         // Replace.  (Conceptually equivalent
-                                // to erase followed by insert.)
-  basic_string& replace(size_type __pos, size_type __n, 
-                        const basic_string& __s) {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    const size_type __len = min(__n, size() - __pos);
-    if (size() - __len >= max_size() - __s.size())
-      _M_throw_length_error();
-    return replace(_M_start + __pos, _M_start + __pos + __len, 
-                   __s.begin(), __s.end());
-  }
-
-  basic_string& replace(size_type __pos1, size_type __n1,
-                        const basic_string& __s,
-                        size_type __pos2, size_type __n2) {
-    if (__pos1 > size() || __pos2 > __s.size())
-      _M_throw_out_of_range();
-    const size_type __len1 = min(__n1, size() - __pos1);
-    const size_type __len2 = min(__n2, __s.size() - __pos2);
-    if (size() - __len1 >= max_size() - __len2)
-      _M_throw_length_error();
-    return replace(_M_start + __pos1, _M_start + __pos1 + __len1,
-                   __s._M_start + __pos2, __s._M_start + __pos2 + __len2);
-  }
-
-  basic_string& replace(size_type __pos, size_type __n1,
-                        const _CharT* __s, size_type __n2) {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    const size_type __len = min(__n1, size() - __pos);
-    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
-      _M_throw_length_error();
-    return replace(_M_start + __pos, _M_start + __pos + __len,
-                   __s, __s + __n2);
-  }
-
-  basic_string& replace(size_type __pos, size_type __n1,
-                        const _CharT* __s) {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    const size_type __len = min(__n1, size() - __pos);
-    const size_type __n2 = _Traits::length(__s);
-    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
-      _M_throw_length_error();
-    return replace(_M_start + __pos, _M_start + __pos + __len,
-                   __s, __s + _Traits::length(__s));
-  }
-
-  basic_string& replace(size_type __pos, size_type __n1,
-                        size_type __n2, _CharT __c) {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    const size_type __len = min(__n1, size() - __pos);
-    if (__n2 > max_size() || size() - __len >= max_size() - __n2)
-      _M_throw_length_error();
-    return replace(_M_start + __pos, _M_start + __pos + __len, __n2, __c);
-  }
-
-  basic_string& replace(iterator __first, iterator __last, 
-                        const basic_string& __s) 
-    { return replace(__first, __last, __s.begin(), __s.end()); }
-
-  basic_string& replace(iterator __first, iterator __last,
-                        const _CharT* __s, size_type __n) 
-    { return replace(__first, __last, __s, __s + __n); }
-
-  basic_string& replace(iterator __first, iterator __last,
-                        const _CharT* __s) {
-    return replace(__first, __last, __s, __s + _Traits::length(__s));
-  }
-
-  basic_string& replace(iterator __first, iterator __last, 
-                        size_type __n, _CharT __c);
-
-  // Check to see if _InputIterator is an integer type.  If so, then
-  // it can't be an iterator.
-#ifdef __STL_MEMBER_TEMPLATES
-  template <class _InputIter>
-  basic_string& replace(iterator __first, iterator __last,
-                        _InputIter __f, _InputIter __l) {
-    typedef typename _Is_integer<_InputIter>::_Integral _Integral;
-    return _M_replace_dispatch(__first, __last, __f, __l,  _Integral());
-  }
-#else /* __STL_MEMBER_TEMPLATES */
-  basic_string& replace(iterator __first, iterator __last,
-                        const _CharT* __f, const _CharT* __l);
-#endif /* __STL_MEMBER_TEMPLATES */
-
-private:                        // Helper functions for replace.
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-  template <class _Integer>
-  basic_string& _M_replace_dispatch(iterator __first, iterator __last,
-                                    _Integer __n, _Integer __x,
-                                    __true_type) {
-    return replace(__first, __last, (size_type) __n, (_CharT) __x);
-  }
-
-  template <class _InputIter>
-  basic_string& _M_replace_dispatch(iterator __first, iterator __last,
-                                    _InputIter __f, _InputIter __l,
-                                    __false_type) {
-    typedef typename iterator_traits<_InputIter>::iterator_category _Category;
-    return replace(__first, __last, __f, __l, _Category());
-  }
-
-  template <class _InputIter>
-  basic_string& replace(iterator __first, iterator __last,
-                        _InputIter __f, _InputIter __l, input_iterator_tag);
-
-  template <class _ForwardIter>
-  basic_string& replace(iterator __first, iterator __last,
-                        _ForwardIter __f, _ForwardIter __l, 
-                        forward_iterator_tag);
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-public:                         // Other modifier member functions.
-
-  size_type copy(_CharT* __s, size_type __n, size_type __pos = 0) const {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    const size_type __len = min(__n, size() - __pos);
-    _Traits::copy(__s, _M_start + __pos, __len);
-    return __len;
-  }
-
-  void swap(basic_string& __s) {
-    __STD::swap(_M_start, __s._M_start);
-    __STD::swap(_M_finish, __s._M_finish);
-    __STD::swap(_M_end_of_storage, __s._M_end_of_storage);
-  }
-
-public:                         // Conversion to C string.
-
-  const _CharT* c_str() const { return _M_start; }
-  const _CharT* data()  const { return _M_start; }
-
-public:                         // find.
-
-  size_type find(const basic_string& __s, size_type __pos = 0) const 
-    { return find(__s.begin(), __pos, __s.size()); }
-
-  size_type find(const _CharT* __s, size_type __pos = 0) const 
-    { return find(__s, __pos, _Traits::length(__s)); }
-
-  size_type find(const _CharT* __s, size_type __pos, size_type __n) const;
-  size_type find(_CharT __c, size_type __pos = 0) const;
-
-public:                         // rfind.
-
-  size_type rfind(const basic_string& __s, size_type __pos = npos) const 
-    { return rfind(__s.begin(), __pos, __s.size()); }
-
-  size_type rfind(const _CharT* __s, size_type __pos = npos) const 
-    { return rfind(__s, __pos, _Traits::length(__s)); }
-
-  size_type rfind(const _CharT* __s, size_type __pos, size_type __n) const;
-  size_type rfind(_CharT __c, size_type __pos = npos) const;
-
-public:                         // find_first_of
-  
-  size_type find_first_of(const basic_string& __s, size_type __pos = 0) const 
-    { return find_first_of(__s.begin(), __pos, __s.size()); }
-
-  size_type find_first_of(const _CharT* __s, size_type __pos = 0) const 
-    { return find_first_of(__s, __pos, _Traits::length(__s)); }
-
-  size_type find_first_of(const _CharT* __s, size_type __pos, 
-                          size_type __n) const;
-
-  size_type find_first_of(_CharT __c, size_type __pos = 0) const 
-    { return find(__c, __pos); }
-
-public:                         // find_last_of
-
-  size_type find_last_of(const basic_string& __s,
-                         size_type __pos = npos) const
-    { return find_last_of(__s.begin(), __pos, __s.size()); }
-
-  size_type find_last_of(const _CharT* __s, size_type __pos = npos) const 
-    { return find_last_of(__s, __pos, _Traits::length(__s)); }
-
-  size_type find_last_of(const _CharT* __s, size_type __pos, 
-                         size_type __n) const;
-
-  size_type find_last_of(_CharT __c, size_type __pos = npos) const {
-    return rfind(__c, __pos);
-  }
-
-public:                         // find_first_not_of
-
-  size_type find_first_not_of(const basic_string& __s, 
-                              size_type __pos = 0) const 
-    { return find_first_not_of(__s.begin(), __pos, __s.size()); }
-
-  size_type find_first_not_of(const _CharT* __s, size_type __pos = 0) const 
-    { return find_first_not_of(__s, __pos, _Traits::length(__s)); }
-
-  size_type find_first_not_of(const _CharT* __s, size_type __pos,
-                              size_type __n) const;
-
-  size_type find_first_not_of(_CharT __c, size_type __pos = 0) const;
-
-public:                         // find_last_not_of
-
-  size_type find_last_not_of(const basic_string& __s, 
-                             size_type __pos = npos) const
-    { return find_last_not_of(__s.begin(), __pos, __s.size()); }
-
-  size_type find_last_not_of(const _CharT* __s, size_type __pos = npos) const
-    { return find_last_not_of(__s, __pos, _Traits::length(__s)); }
-
-  size_type find_last_not_of(const _CharT* __s, size_type __pos,
-                             size_type __n) const;
-
-  size_type find_last_not_of(_CharT __c, size_type __pos = npos) const;
-
-public:                         // Substring.
-
-  basic_string substr(size_type __pos = 0, size_type __n = npos) const {
-    if (__pos > size())
-      _M_throw_out_of_range();
-    return basic_string(_M_start + __pos, 
-                        _M_start + __pos + min(__n, size() - __pos));
-  }
-
-public:                         // Compare
-
-  int compare(const basic_string& __s) const 
-    { return _M_compare(_M_start, _M_finish, __s._M_start, __s._M_finish); }
-
-  int compare(size_type __pos1, size_type __n1,
-              const basic_string& __s) const {
-    if (__pos1 > size())
-      _M_throw_out_of_range();
-    return _M_compare(_M_start + __pos1, 
-                      _M_start + __pos1 + min(__n1, size() - __pos1),
-                      __s._M_start, __s._M_finish);
-  }
-    
-  int compare(size_type __pos1, size_type __n1,
-              const basic_string& __s,
-              size_type __pos2, size_type __n2) const {
-    if (__pos1 > size() || __pos2 > __s.size())
-      _M_throw_out_of_range();
-    return _M_compare(_M_start + __pos1, 
-                      _M_start + __pos1 + min(__n1, size() - __pos1),
-                      __s._M_start + __pos2, 
-                      __s._M_start + __pos2 + min(__n2, size() - __pos2));
-  }
-
-  int compare(const _CharT* __s) const {
-    return _M_compare(_M_start, _M_finish, __s, __s + _Traits::length(__s));
-  }
-
-  int compare(size_type __pos1, size_type __n1, const _CharT* __s) const {
-    if (__pos1 > size())
-      _M_throw_out_of_range();
-    return _M_compare(_M_start + __pos1, 
-                      _M_start + __pos1 + min(__n1, size() - __pos1),
-                      __s, __s + _Traits::length(__s));
-  }
-
-  int compare(size_type __pos1, size_type __n1, const _CharT* __s,
-              size_type __n2) const {
-    if (__pos1 > size())
-      _M_throw_out_of_range();
-    return _M_compare(_M_start + __pos1, 
-                      _M_start + __pos1 + min(__n1, size() - __pos1),
-                      __s, __s + __n2);
-  }
-
-public:                        // Helper function for compare.
-  static int _M_compare(const _CharT* __f1, const _CharT* __l1,
-                        const _CharT* __f2, const _CharT* __l2) {
-    const ptrdiff_t __n1 = __l1 - __f1;
-    const ptrdiff_t __n2 = __l2 - __f2;
-    const int cmp = _Traits::compare(__f1, __f2, min(__n1, __n2));
-    return cmp != 0 ? cmp : (__n1 < __n2 ? -1 : (__n1 > __n2 ? 1 : 0));
-  }
-};
-
-
-
-// ------------------------------------------------------------
-// Non-inline declarations.
-
-template <class _CharT, class _Traits, class _Alloc> 
-const typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>::npos 
-  = (typename basic_string<_CharT,_Traits,_Alloc>::size_type) -1;
-
-// Change the string's capacity so that it is large enough to hold
-//  at least __res_arg elements, plus the terminating null.  Note that,
-//  if __res_arg < capacity(), this member function may actually decrease
-//  the string's capacity.
-template <class _CharT, class _Traits, class _Alloc> 
-void basic_string<_CharT,_Traits,_Alloc>::reserve(size_type __res_arg) {
-  if (__res_arg > max_size())
-    _M_throw_length_error();
-
-  size_type __n = max(__res_arg, size()) + 1;
-  pointer __new_start = _M_allocate(__n);
-  pointer __new_finish = __new_start;
-
-  __STL_TRY {
-    __new_finish = uninitialized_copy(_M_start, _M_finish, __new_start);
-    _M_construct_null(__new_finish);
-  }
-  __STL_UNWIND((destroy(__new_start, __new_finish), 
-                _M_deallocate(__new_start, __n)));
-
-  destroy(_M_start, _M_finish + 1);
-  _M_deallocate_block();
-  _M_start = __new_start;
-  _M_finish = __new_finish;
-  _M_end_of_storage = __new_start + __n;
-}
-
-template <class _CharT, class _Traits, class _Alloc> 
-basic_string<_CharT,_Traits,_Alloc>& 
-basic_string<_CharT,_Traits,_Alloc>::append(size_type __n, _CharT __c) {
-  if (__n > max_size() || size() > max_size() - __n)
-    _M_throw_length_error();
-  if (size() + __n > capacity())
-    reserve(size() + max(size(), __n));
-  if (__n > 0) {
-    uninitialized_fill_n(_M_finish + 1, __n - 1, __c);
-    __STL_TRY {
-      _M_construct_null(_M_finish + __n);
-    }
-    __STL_UNWIND(destroy(_M_finish + 1, _M_finish + __n));
-    _Traits::assign(*_M_finish, __c);
-    _M_finish += __n;
-  }
-  return *this;
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Traits, class _Alloc> 
-template <class _InputIterator>
-basic_string<_Tp, _Traits, _Alloc>& 
-basic_string<_Tp, _Traits, _Alloc>::append(_InputIterator __first, 
-                                          _InputIterator __last,
-                                          input_iterator_tag) {
-  for ( ; __first != __last ; ++__first)
-    push_back(*__first);
-  return *this;
-}
-
-template <class _Tp, class _Traits, class _Alloc> 
-template <class _ForwardIter>
-basic_string<_Tp, _Traits, _Alloc>& 
-basic_string<_Tp, _Traits, _Alloc>::append(_ForwardIter __first, 
-                                           _ForwardIter __last,
-                                           forward_iterator_tag) {
-  if (__first != __last) {
-    const size_type __old_size = size();
-    difference_type __n = 0;
-
-    distance(__first, __last, __n);
-
-    if (static_cast<size_type>(__n) > max_size() ||
-        __old_size > max_size() - static_cast<size_type>(__n))
-      _M_throw_length_error();
-    if (__old_size + static_cast<size_type>(__n) > capacity()) {
-
-#ifdef STM32PLUS_BUILD
-    	const size_type __len = __old_size +
-                            max(stm32plus::Stm32StringAllocAheadIncrement<_Tp>(__old_size),
-                            		static_cast<size_type>(__n)) + 1;
-#else
-    	const size_type __len = __old_size +
-                            max(__old_size, static_cast<size_type>(__n)) + 1;
-#endif
-      pointer __new_start = _M_allocate(__len);
-      pointer __new_finish = __new_start;
-      __STL_TRY {
-        __new_finish = uninitialized_copy(_M_start, _M_finish, __new_start);
-        __new_finish = uninitialized_copy(__first, __last, __new_finish);
-        _M_construct_null(__new_finish);
-      }
-      __STL_UNWIND((destroy(__new_start,__new_finish),
-                    _M_deallocate(__new_start,__len)));
-      destroy(_M_start, _M_finish + 1);
-      _M_deallocate_block();
-      _M_start = __new_start;
-      _M_finish = __new_finish;
-      _M_end_of_storage = __new_start + __len; 
-    }
-    else {
-      _ForwardIter __f1 = __first;
-      ++__f1;
-      uninitialized_copy(__f1, __last, _M_finish + 1);
-      __STL_TRY {
-        _M_construct_null(_M_finish + __n);
-      }
-      __STL_UNWIND(destroy(_M_finish + 1, _M_finish + __n));
-      _Traits::assign(*_M_finish, *__first);
-      _M_finish += __n;
-    }
-  }
-  return *this;  
-}
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-template <class _Tp, class _Traits, class _Alloc> 
-basic_string<_Tp, _Traits, _Alloc>& 
-basic_string<_Tp, _Traits, _Alloc>::append(const _Tp* __first,
-                                           const _Tp* __last)
-{
-  if (__first != __last) {
-    const size_type __old_size = size();
-    ptrdiff_t __n = __last - __first;
-    if (__n > max_size() || __old_size > max_size() - __n)
-      _M_throw_length_error();
-    if (__old_size + __n > capacity()) {
-      const size_type __len = __old_size + max(__old_size, (size_t) __n) + 1;
-      pointer __new_start = _M_allocate(__len);
-      pointer __new_finish = __new_start;
-      __STL_TRY {
-        __new_finish = uninitialized_copy(_M_start, _M_finish, __new_start);
-        __new_finish = uninitialized_copy(__first, __last, __new_finish);
-        _M_construct_null(__new_finish);
-      }
-      __STL_UNWIND((destroy(__new_start,__new_finish),
-                    _M_deallocate(__new_start,__len)));
-      destroy(_M_start, _M_finish + 1);
-      _M_deallocate_block();
-      _M_start = __new_start;
-      _M_finish = __new_finish;
-      _M_end_of_storage = __new_start + __len; 
-    }
-    else {
-      const _Tp* __f1 = __first;
-      ++__f1;
-      uninitialized_copy(__f1, __last, _M_finish + 1);
-      __STL_TRY {
-        _M_construct_null(_M_finish + __n);
-      }
-      __STL_UNWIND(destroy(_M_finish + 1, _M_finish + __n));
-      _Traits::assign(*_M_finish, *__first);
-      _M_finish += __n;
-    }
-  }
-  return *this;  
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _CharT, class _Traits, class _Alloc> 
-basic_string<_CharT,_Traits,_Alloc>& 
-basic_string<_CharT,_Traits,_Alloc>::assign(size_type __n, _CharT __c) {
-  if (__n <= size()) {
-    _Traits::assign(_M_start, __n, __c);
-    erase(_M_start + __n, _M_finish);
-  }
-  else {
-    _Traits::assign(_M_start, size(), __c);
-    append(__n - size(), __c);
-  }
-  return *this;
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _CharT, class _Traits, class _Alloc> 
-template <class _InputIter>
-basic_string<_CharT,_Traits,_Alloc>& basic_string<_CharT,_Traits,_Alloc>
-  ::_M_assign_dispatch(_InputIter __f, _InputIter __l, __false_type)
-{
-  pointer __cur = _M_start;
-  while (__f != __l && __cur != _M_finish) {
-    _Traits::assign(*__cur, *__f);
-    ++__f;
-    ++__cur;
-  }
-  if (__f == __l)
-    erase(__cur, _M_finish);
-  else
-    append(__f, __l);
-  return *this;
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _CharT, class _Traits, class _Alloc> 
-basic_string<_CharT,_Traits,_Alloc>& 
-basic_string<_CharT,_Traits,_Alloc>::assign(const _CharT* __f, 
-                                            const _CharT* __l)
-{
-  const ptrdiff_t __n = __l - __f;
-  if (static_cast<size_type>(__n) <= size()) {
-    _Traits::copy(_M_start, __f, __n);
-    erase(_M_start + __n, _M_finish);
-  }
-  else {
-    _Traits::copy(_M_start, __f, size());
-    append(__f + size(), __l);
-  }
-  return *this;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::iterator
-basic_string<_CharT,_Traits,_Alloc>
-  ::_M_insert_aux(basic_string<_CharT,_Traits,_Alloc>::iterator __p,
-                  _CharT __c)
-{
-  iterator __new_pos = __p;
-  if (_M_finish + 1 < _M_end_of_storage) {
-    _M_construct_null(_M_finish + 1);
-    _Traits::move(__p + 1, __p, _M_finish - __p);
-    _Traits::assign(*__p, __c);
-    ++_M_finish;
-  }
-  else {
-    const size_type __old_len = size();
-#ifdef STM32PLUS_BUILD
-    const size_type __len = __old_len +
-                            max(stm32plus::Stm32StringAllocAheadIncrement<_CharT>(__old_len), static_cast<size_type>(1)) + 1;
-#else
-    const size_type __len = __old_len +
-                            max(__old_len, static_cast<size_type>(1)) + 1;
-#endif
-    iterator __new_start = _M_allocate(__len);
-    iterator __new_finish = __new_start;
-    __STL_TRY {
-      __new_pos = uninitialized_copy(_M_start, __p, __new_start);
-      construct(__new_pos, __c);
-      __new_finish = __new_pos + 1;
-      __new_finish = uninitialized_copy(__p, _M_finish, __new_finish);
-      _M_construct_null(__new_finish);
-    }
-    __STL_UNWIND((destroy(__new_start,__new_finish), 
-                  _M_deallocate(__new_start,__len)));
-    destroy(_M_start, _M_finish + 1);
-    _M_deallocate_block();
-    _M_start = __new_start;
-    _M_finish = __new_finish;
-    _M_end_of_storage = __new_start + __len;
-  }
-  return __new_pos;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-void basic_string<_CharT,_Traits,_Alloc>
-  ::insert(basic_string<_CharT,_Traits,_Alloc>::iterator __position,
-           size_t __n, _CharT __c)
-{
-  if (__n != 0) {
-    if (size_type(_M_end_of_storage - _M_finish) >= __n + 1) {
-      const size_type __elems_after = _M_finish - __position;
-      iterator __old_finish = _M_finish;
-      if (__elems_after >= __n) {
-        uninitialized_copy((_M_finish - __n) + 1, _M_finish + 1,
-                           _M_finish + 1);
-        _M_finish += __n;
-        _Traits::move(__position + __n,
-                      __position, (__elems_after - __n) + 1);
-        _Traits::assign(__position, __n, __c);
-      }
-      else {
-        uninitialized_fill_n(_M_finish + 1, __n - __elems_after - 1, __c);
-        _M_finish += __n - __elems_after;
-        __STL_TRY {
-          uninitialized_copy(__position, __old_finish + 1, _M_finish);
-          _M_finish += __elems_after;
-        }
-        __STL_UNWIND((destroy(__old_finish + 1, _M_finish), 
-                      _M_finish = __old_finish));
-        _Traits::assign(__position, __elems_after + 1, __c);
-      }
-    }
-    else {
-      const size_type __old_size = size();        
-
-#ifdef STM32PLUS_BUILD
-      const size_type __len = __old_size + max(stm32plus::Stm32StringAllocAheadIncrement<_CharT>(__old_size), __n) + 1;
-#else
-      const size_type __len = __old_size + max(__old_size, __n) + 1;
-#endif
-      iterator __new_start = _M_allocate(__len);
-      iterator __new_finish = __new_start;
-      __STL_TRY {
-        __new_finish = uninitialized_copy(_M_start, __position, __new_start);
-        __new_finish = uninitialized_fill_n(__new_finish, __n, __c);
-        __new_finish = uninitialized_copy(__position, _M_finish,
-                                          __new_finish);
-        _M_construct_null(__new_finish);
-      }
-      __STL_UNWIND((destroy(__new_start,__new_finish),
-                    _M_deallocate(__new_start,__len)));
-      destroy(_M_start, _M_finish + 1);
-      _M_deallocate_block();
-      _M_start = __new_start;
-      _M_finish = __new_finish;
-      _M_end_of_storage = __new_start + __len;    
-    }
-  }
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _Tp, class _Traits, class _Alloc>
-template <class _InputIter>
-void basic_string<_Tp, _Traits, _Alloc>::insert(iterator __p,
-                                                _InputIter __first, 
-                                                _InputIter __last,
-                                                input_iterator_tag)
-{
-  for ( ; __first != __last; ++__first) {
-    __p = insert(__p, *__first);
-    ++__p;
-  }
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-template <class _ForwardIter>
-void 
-basic_string<_CharT,_Traits,_Alloc>::insert(iterator __position,
-                                            _ForwardIter __first, 
-                                            _ForwardIter __last,
-                                            forward_iterator_tag)
-{
-  if (__first != __last) {
-    difference_type __n = 0;
-
-    distance(__first, __last, __n);
-
-    if (_M_end_of_storage - _M_finish >= __n + 1) {
-      const difference_type __elems_after = _M_finish - __position;
-      iterator __old_finish = _M_finish;
-      if (__elems_after >= __n) {
-        uninitialized_copy((_M_finish - __n) + 1, _M_finish + 1,
-                           _M_finish + 1);
-        _M_finish += __n;
-        _Traits::move(__position + __n,
-                      __position, (__elems_after - __n) + 1);
-        _M_copy(__first, __last, __position);
-      }
-      else {
-        _ForwardIter __mid = __first;
-        advance(__mid, __elems_after + 1);
-        uninitialized_copy(__mid, __last, _M_finish + 1);
-        _M_finish += __n - __elems_after;
-        __STL_TRY {
-          uninitialized_copy(__position, __old_finish + 1, _M_finish);
-          _M_finish += __elems_after;
-        }
-        __STL_UNWIND((destroy(__old_finish + 1, _M_finish), 
-                      _M_finish = __old_finish));
-        _M_copy(__first, __mid, __position);
-      }
-    }
-    else {
-      const size_type __old_size = size();        
-
-#ifdef STM32PLUS_BUILD
-      const size_type __len
-        = __old_size + max(stm32plus::Stm32StringAllocAheadIncrement<_CharT>(__old_size), static_cast<size_type>(__n)) + 1;
-#else
-      const size_type __len
-        = __old_size + max(__old_size, static_cast<size_type>(__n)) + 1;
-#endif
-
-      pointer __new_start = _M_allocate(__len);
-      pointer __new_finish = __new_start;
-      __STL_TRY {
-        __new_finish = uninitialized_copy(_M_start, __position, __new_start);
-        __new_finish = uninitialized_copy(__first, __last, __new_finish);
-        __new_finish
-          = uninitialized_copy(__position, _M_finish, __new_finish);
-        _M_construct_null(__new_finish);
-      }
-      __STL_UNWIND((destroy(__new_start,__new_finish),
-                    _M_deallocate(__new_start,__len)));
-      destroy(_M_start, _M_finish + 1);
-      _M_deallocate_block();
-      _M_start = __new_start;
-      _M_finish = __new_finish;
-      _M_end_of_storage = __new_start + __len; 
-    }
-  }
-}
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-template <class _CharT, class _Traits, class _Alloc>
-void 
-basic_string<_CharT,_Traits,_Alloc>::insert(iterator __position,
-                                            const _CharT* __first, 
-                                            const _CharT* __last)
-{
-  if (__first != __last) {
-    const ptrdiff_t __n = __last - __first;
-    if (_M_end_of_storage - _M_finish >= __n + 1) {
-      const ptrdiff_t __elems_after = _M_finish - __position;
-      iterator __old_finish = _M_finish;
-      if (__elems_after >= __n) {
-        uninitialized_copy((_M_finish - __n) + 1, _M_finish + 1,
-                           _M_finish + 1);
-        _M_finish += __n;
-        _Traits::move(__position + __n,
-                      __position, (__elems_after - __n) + 1);
-        _M_copy(__first, __last, __position);
-      }
-      else {
-        const _CharT* __mid = __first;
-        advance(__mid, __elems_after + 1);
-        uninitialized_copy(__mid, __last, _M_finish + 1);
-        _M_finish += __n - __elems_after;
-        __STL_TRY {
-          uninitialized_copy(__position, __old_finish + 1, _M_finish);
-          _M_finish += __elems_after;
-        }
-        __STL_UNWIND((destroy(__old_finish + 1, _M_finish), 
-                      _M_finish = __old_finish));
-        _M_copy(__first, __mid, __position);
-      }
-    }
-    else {
-      const size_type __old_size = size();        
-      const size_type __len
-        = __old_size + max(__old_size, static_cast<size_type>(__n)) + 1;
-      pointer __new_start = _M_allocate(__len);
-      pointer __new_finish = __new_start;
-      __STL_TRY {
-        __new_finish = uninitialized_copy(_M_start, __position, __new_start);
-        __new_finish = uninitialized_copy(__first, __last, __new_finish);
-        __new_finish
-          = uninitialized_copy(__position, _M_finish, __new_finish);
-        _M_construct_null(__new_finish);
-      }
-      __STL_UNWIND((destroy(__new_start,__new_finish),
-                    _M_deallocate(__new_start,__len)));
-      destroy(_M_start, _M_finish + 1);
-      _M_deallocate_block();
-      _M_start = __new_start;
-      _M_finish = __new_finish;
-      _M_end_of_storage = __new_start + __len; 
-    }
-  }
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _CharT, class _Traits, class _Alloc>
-basic_string<_CharT,_Traits,_Alloc>&
-basic_string<_CharT,_Traits,_Alloc>
-  ::replace(iterator __first, iterator __last, size_type __n, _CharT __c)
-{
-  const size_type __len = static_cast<size_type>(__last - __first);
-  if (__len >= __n) {
-    _Traits::assign(__first, __n, __c);
-    erase(__first + __n, __last);
-  }
-  else {
-    _Traits::assign(__first, __len, __c);
-    insert(__last, __n - __len, __c);
-  }
-  return *this;
-}
-
-#ifdef __STL_MEMBER_TEMPLATES
-
-template <class _CharT, class _Traits, class _Alloc>
-template <class _InputIter>
-basic_string<_CharT,_Traits,_Alloc>&
-basic_string<_CharT,_Traits,_Alloc>
-  ::replace(iterator __first, iterator __last, _InputIter __f, _InputIter __l,
-            input_iterator_tag) 
-{
-  for ( ; __first != __last && __f != __l; ++__first, ++__f)
-    _Traits::assign(*__first, *__f);
-
-  if (__f == __l)
-    erase(__first, __last);
-  else
-    insert(__last, __f, __l);
-  return *this;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-template <class _ForwardIter>
-basic_string<_CharT,_Traits,_Alloc>&
-basic_string<_CharT,_Traits,_Alloc>
-  ::replace(iterator __first, iterator __last,
-            _ForwardIter __f, _ForwardIter __l,
-            forward_iterator_tag) 
-{
-  difference_type __n = 0;
-  distance(__f, __l, __n);
-  const difference_type __len = __last - __first;
-  if (__len >= __n) {
-    _M_copy(__f, __l, __first);
-    erase(__first + __n, __last);
-  }
-  else {
-    _ForwardIter __m = __f;
-    advance(__m, __len);
-    _M_copy(__f, __m, __first);
-    insert(__last, __m, __l);
-  }
-  return *this;
-}
-
-#else /* __STL_MEMBER_TEMPLATES */
-
-template <class _CharT, class _Traits, class _Alloc>
-basic_string<_CharT,_Traits,_Alloc>&
-basic_string<_CharT,_Traits,_Alloc>
-  ::replace(iterator __first, iterator __last,
-            const _CharT* __f, const _CharT* __l)
-{
-  const ptrdiff_t         __n = __l - __f;
-  const difference_type __len = __last - __first;
-  if (__len >= __n) {
-    _M_copy(__f, __l, __first);
-    erase(__first + __n, __last);
-  }
-  else {
-    const _CharT* __m = __f + __len;
-    _M_copy(__f, __m, __first);
-    insert(__last, __m, __l);
-  }
-  return *this;
-}
-
-#endif /* __STL_MEMBER_TEMPLATES */
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>
-  ::find(const _CharT* __s, size_type __pos, size_type __n) const 
-{
-  if (__pos + __n > size())
-    return npos;
-  else {
-    const const_iterator __result =
-      search(_M_start + __pos, _M_finish, 
-             __s, __s + __n, _Eq_traits<_Traits>());
-    return __result != _M_finish ? __result - begin() : npos;
-  }
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>
-  ::find(_CharT __c, size_type __pos) const 
-{
-  if (__pos >= size())
-    return npos;
-  else {
-    const const_iterator __result =
-      find_if(_M_start + __pos, _M_finish,
-              bind2nd(_Eq_traits<_Traits>(), __c));
-    return __result != _M_finish ? __result - begin() : npos;
-  }
-}    
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>
-  ::rfind(const _CharT* __s, size_type __pos, size_type __n) const 
-{
-  const size_t __len = size();
-
-  if (__n > __len)
-    return npos;
-  else if (__n == 0)
-    return min(__len, __pos);
-  else {
-    const const_iterator __last = begin() + min(__len - __n, __pos) + __n;
-    const const_iterator __result = find_end(begin(), __last,
-                                           __s, __s + __n,
-                                           _Eq_traits<_Traits>());
-    return __result != __last ? __result - begin() : npos;
-  }
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>
-  ::rfind(_CharT __c, size_type __pos) const 
-{
-  const size_type __len = size();
-
-  if (__len < 1)
-    return npos;
-  else {
-    const const_iterator __last = begin() + min(__len - 1, __pos) + 1;
-    const_reverse_iterator __rresult =
-      find_if(const_reverse_iterator(__last), rend(),
-              bind2nd(_Eq_traits<_Traits>(), __c));
-    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
-  }
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>
-  ::find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
-{
-  if (__pos >= size())
-    return npos;
-  else {
-    const_iterator __result = __STD::find_first_of(begin() + __pos, end(),
-                                                   __s, __s + __n,
-                                                   _Eq_traits<_Traits>());
-    return __result != _M_finish ? __result - begin() : npos;
-  }
-}
-
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>
-  ::find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
-{
-  const size_type __len = size();
-
-  if (__len < 1)
-    return npos;
-  else {
-    const const_iterator __last = _M_start + min(__len - 1, __pos) + 1;
-    const const_reverse_iterator __rresult =
-      __STD::find_first_of(const_reverse_iterator(__last), rend(),
-                           __s, __s + __n,
-                           _Eq_traits<_Traits>());
-    return __rresult != rend() ? (__rresult.base() - 1) - _M_start : npos;
-  }
-}
-
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>
-  ::find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
-{
-  if (__pos > size())
-    return npos;
-  else {
-    const_iterator __result = find_if(_M_start + __pos, _M_finish,
-                                _Not_within_traits<_Traits>(__s, __s + __n));
-    return __result != _M_finish ? __result - _M_start : npos;
-  }
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>
-  ::find_first_not_of(_CharT __c, size_type __pos) const
-{
-  if (__pos > size())
-    return npos;
-  else {
-    const_iterator __result
-      = find_if(begin() + __pos, end(),
-                not1(bind2nd(_Eq_traits<_Traits>(), __c)));
-    return __result != _M_finish ? __result - begin() : npos;
-  }
-}    
-
-template <class _CharT, class _Traits, class _Alloc>
-typename basic_string<_CharT,_Traits,_Alloc>::size_type
-basic_string<_CharT,_Traits,_Alloc>
-  ::find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const 
-{
-
-  const size_type __len = size();
-
-  if (__len < 1)
-    return npos;
-  else {
-    const const_iterator __last = begin() + min(__len - 1, __pos) + 1;
-    const const_reverse_iterator __rresult =
-      find_if(const_reverse_iterator(__last), rend(),
-              _Not_within_traits<_Traits>(__s, __s + __n));
-    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
-  }
-}
-
-template <class _Tp, class _Traits, class _Alloc>
-typename basic_string<_Tp, _Traits, _Alloc>::size_type
-basic_string<_Tp, _Traits, _Alloc>
-  ::find_last_not_of(_Tp __c, size_type __pos) const 
-{
-  const size_type __len = size();
-
-  if (__len < 1)
-    return npos;
-  else {
-    const const_iterator __last = begin() + min(__len - 1, __pos) + 1;
-    const_reverse_iterator __rresult =
-      find_if(const_reverse_iterator(__last), rend(),
-              not1(bind2nd(_Eq_traits<_Traits>(), __c)));
-    return __rresult != rend() ? (__rresult.base() - 1) - begin() : npos;
-  }
-}
-
-// ------------------------------------------------------------
-// Non-member functions.
-
-// Operator+
-
-template <class _CharT, class _Traits, class _Alloc>
-inline basic_string<_CharT,_Traits,_Alloc>
-operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
-          const basic_string<_CharT,_Traits,_Alloc>& __y)
-{
-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
-  typedef typename _Str::_Reserve_t _Reserve_t;
-  _Reserve_t __reserve;
-  _Str __result(__reserve, __x.size() + __y.size(), __x.get_allocator());
-  __result.append(__x);
-  __result.append(__y);
-  return __result;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline basic_string<_CharT,_Traits,_Alloc>
-operator+(const _CharT* __s,
-          const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
-  typedef typename _Str::_Reserve_t _Reserve_t;
-  _Reserve_t __reserve;
-  const size_t __n = _Traits::length(__s);
-  _Str __result(__reserve, __n + __y.size());
-  __result.append(__s, __s + __n);
-  __result.append(__y);
-  return __result;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline basic_string<_CharT,_Traits,_Alloc>
-operator+(_CharT __c,
-          const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
-  typedef typename _Str::_Reserve_t _Reserve_t;
-  _Reserve_t __reserve;
-  _Str __result(__reserve, 1 + __y.size());
-  __result.push_back(__c);
-  __result.append(__y);
-  return __result;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline basic_string<_CharT,_Traits,_Alloc>
-operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
-          const _CharT* __s) {
-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
-  typedef typename _Str::_Reserve_t _Reserve_t;
-  _Reserve_t __reserve;
-  const size_t __n = _Traits::length(__s);
-  _Str __result(__reserve, __x.size() + __n, __x.get_allocator());
-  __result.append(__x);
-  __result.append(__s, __s + __n);
-  return __result;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline basic_string<_CharT,_Traits,_Alloc>
-operator+(const basic_string<_CharT,_Traits,_Alloc>& __x,
-          const _CharT __c) {
-  typedef basic_string<_CharT,_Traits,_Alloc> _Str;
-  typedef typename _Str::_Reserve_t _Reserve_t;
-  _Reserve_t __reserve;
-  _Str __result(__reserve, __x.size() + 1, __x.get_allocator());
-  __result.append(__x);
-  __result.push_back(__c);
-  return __result;
-}
-
-// Operator== and operator!=
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
-           const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return __x.size() == __y.size() &&
-         _Traits::compare(__x.data(), __y.data(), __x.size()) == 0;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator==(const _CharT* __s,
-           const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  size_t __n = _Traits::length(__s);
-  return __n == __y.size() && _Traits::compare(__s, __y.data(), __n) == 0;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator==(const basic_string<_CharT,_Traits,_Alloc>& __x,
-           const _CharT* __s) {
-  size_t __n = _Traits::length(__s);
-  return __x.size() == __n && _Traits::compare(__x.data(), __s, __n) == 0;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
-           const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return !(__x == __y);
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator!=(const _CharT* __s,
-           const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return !(__s == __y);
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator!=(const basic_string<_CharT,_Traits,_Alloc>& __x,
-           const _CharT* __s) {
-  return !(__x == __s);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-// Operator< (and also >, <=, and >=).
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
-          const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return basic_string<_CharT,_Traits,_Alloc>
-    ::_M_compare(__x.begin(), __x.end(), __y.begin(), __y.end()) < 0;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator<(const _CharT* __s,
-          const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  size_t __n = _Traits::length(__s);
-  return basic_string<_CharT,_Traits,_Alloc>
-    ::_M_compare(__s, __s + __n, __y.begin(), __y.end()) < 0;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator<(const basic_string<_CharT,_Traits,_Alloc>& __x,
-          const _CharT* __s) {
-  size_t __n = _Traits::length(__s);
-  return basic_string<_CharT,_Traits,_Alloc>
-    ::_M_compare(__x.begin(), __x.end(), __s, __s + __n) < 0;
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
-          const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return __y < __x;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator>(const _CharT* __s,
-          const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return __y < __s;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator>(const basic_string<_CharT,_Traits,_Alloc>& __x,
-          const _CharT* __s) {
-  return __s < __x;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
-           const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return !(__y < __x);
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator<=(const _CharT* __s,
-           const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return !(__y < __s);
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator<=(const basic_string<_CharT,_Traits,_Alloc>& __x,
-           const _CharT* __s) {
-  return !(__s < __x);
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
-           const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return !(__x < __y);
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator>=(const _CharT* __s,
-           const basic_string<_CharT,_Traits,_Alloc>& __y) {
-  return !(__s < __y);
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-inline bool
-operator>=(const basic_string<_CharT,_Traits,_Alloc>& __x,
-           const _CharT* __s) {
-  return !(__x < __s);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-// Swap.
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _CharT, class _Traits, class _Alloc>
-inline void swap(basic_string<_CharT,_Traits,_Alloc>& __x,
-                 basic_string<_CharT,_Traits,_Alloc>& __y) {
-  __x.swap(__y);
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-
-// I/O.  
-
-#ifndef __STL_USE_NEW_IOSTREAMS 
-__STL_END_NAMESPACE
-#include <iostream.h>
-__STL_BEGIN_NAMESPACE
-#endif /* __STL_USE_NEW_IOSTREAMS */
-
-#ifdef __STL_USE_NEW_IOSTREAMS
-
-template <class _CharT, class _Traits>
-inline bool
-__sgi_string_fill(basic_ostream<_CharT, _Traits>& __os,
-                  basic_streambuf<_CharT, _Traits>* __buf,
-                  size_t __n)
-{
-  _CharT __f = __os.fill();
-  size_t __i;
-  bool __ok = true;
-
-  for (__i = 0; __i < __n; __i++)
-    __ok = __ok && !_Traits::eq_int_type(__buf->sputc(__f), _Traits::eof());
-  return __ok;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-basic_ostream<_CharT, _Traits>&
-operator<<(basic_ostream<_CharT, _Traits>& __os, 
-           const basic_string<_CharT,_Traits,_Alloc>& __s)
-{
-  typename basic_ostream<_CharT, _Traits>::sentry __sentry(__os);
-  bool __ok = false;
-
-  if (__sentry) {
-    __ok = true;
-    size_t __n = __s.size();
-    size_t __pad_len = 0;
-    const bool __left = (__os.flags() & ios::left) != 0;
-    const size_t __w = __os.width(0);
-    basic_streambuf<_CharT, _Traits>* __buf = __os.rdbuf();
-
-    if (__w != 0 && __n < __w)
-      __pad_len = __w - __n;
-    
-    if (!__left)
-      __ok = __sgi_string_fill(__os, __buf, __pad_len);    
-
-    __ok = __ok && 
-           __buf->sputn(__s.data(), streamsize(__n)) == streamsize(__n);
-
-    if (__left)
-      __ok = __ok && __sgi_string_fill(__os, __buf, __pad_len);
-  }
-
-  if (!__ok)
-    __os.setstate(ios_base::failbit);
-
-  return __os;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-basic_istream<_CharT, _Traits>& 
-operator>>(basic_istream<_CharT, _Traits>& __is,
-           basic_string<_CharT,_Traits,_Alloc>& __s)
-{
-  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is);
-
-  if (__sentry) {
-    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
-#ifndef STM32PLUS_BUILD
-    const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__is.getloc());
-#endif
-    __s.clear();
-    size_t __n = __is.width(0);
-    if (__n == 0)
-      __n = static_cast<size_t>(-1);
-    else
-      __s.reserve(__n);
-    
-
-    while (__n-- > 0) {
-      typename _Traits::int_type __c1 = __buf->sbumpc();
-      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
-        __is.setstate(ios_base::eofbit);
-        break;
-      }
-      else {
-        _CharT __c = _Traits::to_char_type(__c1);
-
-#ifdef STM32PLUS_BUILD
-        if(isspace(__c)) {
-#else
-        if (__ctype.is(ctype<_CharT>::space, __c)) {
-#endif
-          if (_Traits::eq_int_type(__buf->sputbackc(__c), _Traits::eof()))
-            __is.setstate(ios_base::failbit);
-          break;
-        }
-        else
-          __s.push_back(__c);
-      }
-    }
-    
-    // If we have read no characters, then set failbit.
-    if (__s.size() == 0)
-      __is.setstate(ios_base::failbit);
-  }
-  else
-    __is.setstate(ios_base::failbit);
-
-  return __is;
-}
-
-template <class _CharT, class _Traits, class _Alloc>    
-basic_istream<_CharT, _Traits>& 
-getline(istream& __is,
-        basic_string<_CharT,_Traits,_Alloc>& __s,
-        _CharT __delim)
-{
-  size_t __nread = 0;
-  typename basic_istream<_CharT, _Traits>::sentry __sentry(__is, true);
-  if (__sentry) {
-    basic_streambuf<_CharT, _Traits>* __buf = __is.rdbuf();
-    __s.clear();
-
-    int __c1;
-    while (__nread < __s.max_size()) {
-      int __c1 = __buf->sbumpc();
-      if (_Traits::eq_int_type(__c1, _Traits::eof())) {
-        __is.setstate(ios_base::eofbit);
-        break;
-      }
-      else {
-        ++__nread;
-        _CharT __c = _Traits::to_char_type(__c1);
-        if (!_Traits::eq(__c, __delim)) 
-          __s.push_back(__c);
-        else
-          break;              // Character is extracted but not appended.
-      }
-    }
-  }
-  if (__nread == 0 || __nread >= __s.max_size())
-    __is.setstate(ios_base::failbit);
-
-  return __is;
-}
-
-template <class _CharT, class _Traits, class _Alloc>    
-inline basic_istream<_CharT, _Traits>& 
-getline(basic_istream<_CharT, _Traits>& __is,
-        basic_string<_CharT,_Traits,_Alloc>& __s)
-{
-  return getline(__is, __s, '\n');
-}
-
-#else /* __STL_USE_NEW_IOSTREAMS */
-
-inline void __sgi_string_fill(ostream& __os, streambuf* __buf, size_t __n)
-{
-  char __f = __os.fill();
-  size_t __i;
-
-  for (__i = 0; __i < __n; __i++) __buf->sputc(__f);
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-ostream& operator<<(ostream& __os, 
-                    const basic_string<_CharT,_Traits,_Alloc>& __s)
-{
-  streambuf* __buf = __os.rdbuf();
-  if (__buf) {
-    size_t __n = __s.size();
-    size_t __pad_len = 0;
-    const bool __left = (__os.flags() & ios::left) != 0;
-    const size_t __w = __os.width();
-
-    if (__w > 0) {
-      __n = min(__w, __n);
-      __pad_len = __w - __n;
-    }
-    
-    if (!__left)
-      __sgi_string_fill(__os, __buf, __pad_len);
-  
-    const size_t __nwritten = __buf->sputn(__s.data(), __n);
-
-    if (__left)
-      __sgi_string_fill(__os, __buf, __pad_len);
-
-    if (__nwritten != __n)
-      __os.clear(__os.rdstate() | ios::failbit);
-
-    __os.width(0);
-  }
-  else
-    __os.clear(__os.rdstate() | ios::badbit);
-
-  return __os;
-}
-
-template <class _CharT, class _Traits, class _Alloc>
-istream& operator>>(istream& __is, basic_string<_CharT,_Traits,_Alloc>& __s)
-{
-  if (!__is)
-    return __is;
-
-  streambuf* __buf = __is.rdbuf();
-  if (__buf) {
-
-#ifdef __USLC__
-/* Jochen Schlick '1999  - operator >> modified. Work-around to get the 
- *                         output buffer flushed (necessary when using 
- *                         "cout" (without endl or flushing) followed by
- *                         "cin >>" ...)
- */
-    if (__is.flags() & ios::skipws) {
-      _CharT __c;
-      do 
-         __is.get(__c);
-      while (__is && isspace(__c));
-      if (__is)
-         __is.putback(__c);
-    }
-#else
-    if (__is.flags() & ios::skipws) {
-      int __c;
-      do {
-        __c = __buf->sbumpc();
-      }
-      while (__c != EOF && isspace((unsigned char)__c));
-
-      if (__c == EOF) {
-        __is.clear(__is.rdstate() | ios::eofbit | ios::failbit);
-      }
-      else {
-        if (__buf->sputbackc(__c) == EOF)
-          __is.clear(__is.rdstate() | ios::failbit);
-      }
-    }
-#endif
-
-    // If we arrive at end of file (or fail for some other reason) while
-    // still discarding whitespace, then we don't try to read the string.
-    if (__is) {
-      __s.clear();
-
-      size_t __n = __is.width();
-      if (__n == 0)
-        __n = static_cast<size_t>(-1);
-      else
-        __s.reserve(__n);
-
-      while (__n-- > 0) {
-        int __c1 = __buf->sbumpc();
-        if (__c1 == EOF) {
-          __is.clear(__is.rdstate() | ios::eofbit);
-          break;
-        }
-        else {
-          _CharT __c = _Traits::to_char_type(__c1);
-
-          if (isspace((unsigned char) __c)) {
-            if (__buf->sputbackc(__c) == EOF)
-              __is.clear(__is.rdstate() | ios::failbit);
-            break;
-          }
-          else
-            __s.push_back(__c);
-        }
-      }
-    
-      // If we have read no characters, then set failbit.
-      if (__s.size() == 0)
-        __is.clear(__is.rdstate() | ios::failbit);
-    }
-
-    __is.width(0);
-  }
-  else                          // We have no streambuf.
-    __is.clear(__is.rdstate() | ios::badbit);
-
-  return __is;
-}
-
-template <class _CharT, class _Traits, class _Alloc>    
-istream& getline(istream& __is,
-                 basic_string<_CharT,_Traits,_Alloc>& __s,
-                 _CharT __delim)
-{
-  streambuf* __buf = __is.rdbuf();
-  if (__buf) {
-    size_t __nread = 0;
-    if (__is) {
-      __s.clear();
-
-      while (__nread < __s.max_size()) {
-        int __c1 = __buf->sbumpc();
-        if (__c1 == EOF) {
-          __is.clear(__is.rdstate() | ios::eofbit);
-          break;
-        }
-        else {
-          ++__nread;
-          _CharT __c = _Traits::to_char_type(__c1);
-          if (!_Traits::eq(__c, __delim)) 
-            __s.push_back(__c);
-          else
-            break;              // Character is extracted but not appended.
-        }
-      }
-    }
-
-    if (__nread == 0 || __nread >= __s.max_size())
-      __is.clear(__is.rdstate() | ios::failbit);
-  }
-  else
-    __is.clear(__is.rdstate() | ios::badbit);
-
-  return __is;
-}
-
-template <class _CharT, class _Traits, class _Alloc>    
-inline istream& 
-getline(istream& __is, basic_string<_CharT,_Traits,_Alloc>& __s)
-{
-  return getline(__is, __s, '\n');
-}
-
-#endif /* __STL_USE_NEW_IOSTREAMS */
-
-
-template <class _CharT, class _Traits, class _Alloc>
-void _S_string_copy(const basic_string<_CharT,_Traits,_Alloc>& __s,
-                    _CharT* __buf,
-                    size_t __n)
-{
-  if (__n > 0) {
-    __n = min(__n - 1, __s.size());
-    copy(__s.begin(), __s.begin() + __n, __buf);
-    _Traits::assign(__buf[__n],
-                    basic_string<_CharT,_Traits,_Alloc>::_M_null());
-  }
-}
-
-inline const char* __get_c_string(const string& __s) { return __s.c_str(); }
-
-// ------------------------------------------------------------
-// Typedefs
-
-#if defined(__sgi) && !defined(__GNUC__) && (_MIPS_SIM != _MIPS_SIM_ABI32)
-#pragma reset woff 1174
-#pragma reset woff 1375
-#endif
-
-__STL_END_NAMESPACE
-
-#include <stl_hash_fun.h>
-
-__STL_BEGIN_NAMESPACE
-
-template <class _CharT, class _Traits, class _Alloc>
-size_t __stl_string_hash(const basic_string<_CharT,_Traits,_Alloc>& __s) {
-  unsigned long __h = 0;
-  for (typename basic_string<_CharT,_Traits,_Alloc>::const_iterator __i = __s.begin();
-       __i != __s.end();
-       ++__i)
-    __h = 5*__h + *__i;
-  return size_t(__h);
-}
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _CharT, class _Traits, class _Alloc>
-struct hash<basic_string<_CharT,_Traits,_Alloc> > {
-  size_t operator()(const basic_string<_CharT,_Traits,_Alloc>& __s) const
-    { return __stl_string_hash(__s); }
-};
-
-#else
-
-__STL_TEMPLATE_NULL struct hash<string> {
-  size_t operator()(const string& __s) const
-    { return __stl_string_hash(__s); }
-};
-
-__STL_TEMPLATE_NULL struct hash<wstring> {
-  size_t operator()(const wstring& __s) const
-    { return __stl_string_hash(__s); }
-};
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_STRING */
-
-
-// Local Variables:
-// mode:C++
-// End:
-
diff --git a/lib/include/stl/type_traits.h b/lib/include/stl/type_traits.h
deleted file mode 100644
index ff073cd..0000000
--- a/lib/include/stl/type_traits.h
+++ /dev/null
@@ -1,373 +0,0 @@
-/*
- *
- * Copyright (c) 1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __TYPE_TRAITS_H
-#define __TYPE_TRAITS_H
-
-#ifndef __STL_CONFIG_H
-#include <stl_config.h>
-#endif
-
-/*
-This header file provides a framework for allowing compile time dispatch
-based on type attributes. This is useful when writing template code.
-For example, when making a copy of an array of an unknown type, it helps
-to know if the type has a trivial copy constructor or not, to help decide
-if a memcpy can be used.
-
-The class template __type_traits provides a series of typedefs each of
-which is either __true_type or __false_type. The argument to
-__type_traits can be any type. The typedefs within this template will
-attain their correct values by one of these means:
-    1. The general instantiation contain conservative values which work
-       for all types.
-    2. Specializations may be declared to make distinctions between types.
-    3. Some compilers (such as the Silicon Graphics N32 and N64 compilers)
-       will automatically provide the appropriate specializations for all
-       types.
-
-EXAMPLE:
-
-//Copy an array of elements which have non-trivial copy constructors
-template <class T> void copy(T* source, T* destination, int n, __false_type);
-//Copy an array of elements which have trivial copy constructors. Use memcpy.
-template <class T> void copy(T* source, T* destination, int n, __true_type);
-
-//Copy an array of any type by using the most efficient copy mechanism
-template <class T> inline void copy(T* source,T* destination,int n) {
-   copy(source, destination, n,
-        typename __type_traits<T>::has_trivial_copy_constructor());
-}
-*/
-
-
-struct __true_type {
-};
-
-struct __false_type {
-};
-
-template <class _Tp>
-struct __type_traits { 
-   typedef __true_type     this_dummy_member_must_be_first;
-                   /* Do not remove this member. It informs a compiler which
-                      automatically specializes __type_traits that this
-                      __type_traits template is special. It just makes sure that
-                      things work if an implementation is using a template
-                      called __type_traits for something unrelated. */
-
-   /* The following restrictions should be observed for the sake of
-      compilers which automatically produce type specific specializations 
-      of this class:
-          - You may reorder the members below if you wish
-          - You may remove any of the members below if you wish
-          - You must not rename members without making the corresponding
-            name change in the compiler
-          - Members you add will be treated like regular members unless
-            you add the appropriate support in the compiler. */
- 
-
-   typedef __false_type    has_trivial_default_constructor;
-   typedef __false_type    has_trivial_copy_constructor;
-   typedef __false_type    has_trivial_assignment_operator;
-   typedef __false_type    has_trivial_destructor;
-   typedef __false_type    is_POD_type;
-};
-
-
-
-// Provide some specializations.  This is harmless for compilers that
-//  have built-in __types_traits support, and essential for compilers
-//  that don't.
-
-#ifndef __STL_NO_BOOL
-
-__STL_TEMPLATE_nullptr struct __type_traits<bool> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-#endif /* __STL_NO_BOOL */
-
-__STL_TEMPLATE_nullptr struct __type_traits<char> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<signed char> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<unsigned char> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-#ifdef __STL_HAS_WCHAR_T
-
-__STL_TEMPLATE_nullptr struct __type_traits<wchar_t> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-#endif /* __STL_HAS_WCHAR_T */
-
-__STL_TEMPLATE_nullptr struct __type_traits<short> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<unsigned short> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<int> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<unsigned int> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<long> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<unsigned long> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-#ifdef __STL_LONG_LONG
-
-__STL_TEMPLATE_nullptr struct __type_traits<long long> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<unsigned long long> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-#endif /* __STL_LONG_LONG */
-
-__STL_TEMPLATE_nullptr struct __type_traits<float> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<double> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<long double> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-#ifdef __STL_CLASS_PARTIAL_SPECIALIZATION
-
-template <class _Tp>
-struct __type_traits<_Tp*> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-#else /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-__STL_TEMPLATE_nullptr struct __type_traits<char*> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<signed char*> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<unsigned char*> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<const char*> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<const signed char*> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-__STL_TEMPLATE_nullptr struct __type_traits<const unsigned char*> {
-   typedef __true_type    has_trivial_default_constructor;
-   typedef __true_type    has_trivial_copy_constructor;
-   typedef __true_type    has_trivial_assignment_operator;
-   typedef __true_type    has_trivial_destructor;
-   typedef __true_type    is_POD_type;
-};
-
-#endif /* __STL_CLASS_PARTIAL_SPECIALIZATION */
-
-
-// The following could be written in terms of numeric_limits.  
-// We're doing it separately to reduce the number of dependencies.
-
-template <class _Tp> struct _Is_integer {
-  typedef __false_type _Integral;
-};
-
-#ifndef __STL_NO_BOOL
-
-__STL_TEMPLATE_nullptr struct _Is_integer<bool> {
-  typedef __true_type _Integral;
-};
-
-#endif /* __STL_NO_BOOL */
-
-__STL_TEMPLATE_nullptr struct _Is_integer<char> {
-  typedef __true_type _Integral;
-};
-
-__STL_TEMPLATE_nullptr struct _Is_integer<signed char> {
-  typedef __true_type _Integral;
-};
-
-__STL_TEMPLATE_nullptr struct _Is_integer<unsigned char> {
-  typedef __true_type _Integral;
-};
-
-#ifdef __STL_HAS_WCHAR_T
-
-__STL_TEMPLATE_nullptr struct _Is_integer<wchar_t> {
-  typedef __true_type _Integral;
-};
-
-#endif /* __STL_HAS_WCHAR_T */
-
-__STL_TEMPLATE_nullptr struct _Is_integer<short> {
-  typedef __true_type _Integral;
-};
-
-__STL_TEMPLATE_nullptr struct _Is_integer<unsigned short> {
-  typedef __true_type _Integral;
-};
-
-__STL_TEMPLATE_nullptr struct _Is_integer<int> {
-  typedef __true_type _Integral;
-};
-
-__STL_TEMPLATE_nullptr struct _Is_integer<unsigned int> {
-  typedef __true_type _Integral;
-};
-
-__STL_TEMPLATE_nullptr struct _Is_integer<long> {
-  typedef __true_type _Integral;
-};
-
-__STL_TEMPLATE_nullptr struct _Is_integer<unsigned long> {
-  typedef __true_type _Integral;
-};
-
-#ifdef __STL_LONG_LONG
-
-__STL_TEMPLATE_nullptr struct _Is_integer<long long> {
-  typedef __true_type _Integral;
-};
-
-__STL_TEMPLATE_nullptr struct _Is_integer<unsigned long long> {
-  typedef __true_type _Integral;
-};
-
-#endif /* __STL_LONG_LONG */
-
-#endif /* __TYPE_TRAITS_H */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/utility b/lib/include/stl/utility
deleted file mode 100644
index df8c224..0000000
--- a/lib/include/stl/utility
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996,1997
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_UTILITY
-#define __SGI_STL_UTILITY
-
-#include <stl_config.h>
-#include <stl_relops.h>
-#include <stl_pair.h>
-
-#endif /* __SGI_STL_UTILITY */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/valarray b/lib/include/stl/valarray
deleted file mode 100644
index c86633e..0000000
--- a/lib/include/stl/valarray
+++ /dev/null
@@ -1,1780 +0,0 @@
-/*
- * Copyright (c) 1999
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */ 
-
-#ifndef __SGI_STL_VALARRAY
-#define __SGI_STL_VALARRAY
-
-#ifdef STM32PLUS_BUILD
-#include <new.h>
-#undef round
-#undef abs
-#else
-#include <new>
-#endif
-
-#include <type_traits.h>
-#include <math.h>
-#include <algorithm>
-#include <numeric>
-#include <limits>
-
-
-__STL_BEGIN_NAMESPACE
-
-class slice;
-class gslice;
-
-template <class _Tp> class valarray;
-template <class _Tp> class slice_array;
-template <class _Tp> class gslice_array;
-template <class _Tp> class mask_array;
-template <class _Tp> class indirect_array;
-
-//----------------------------------------------------------------------
-// class valarray
-
-// Base class to handle memory allocation and deallocation.  We can't just
-// use vector<>, because vector<bool> would be unsuitable as an internal 
-// representation for valarray<bool>.
-
-template <class _Tp> 
-struct _Valarray_base
-{
-  _Tp*   _M_first;
-  size_t _M_size;
-
-  _Valarray_base() : _M_first(0), _M_size(0) {}
-  _Valarray_base(size_t __n) : _M_first(0), _M_size(0) { _M_allocate(__n); }
-  ~_Valarray_base() { _M_deallocate(); }
-
-  void _M_allocate(size_t __n) {
-    if (__n != 0) {
-      _M_first = static_cast<_Tp*>(malloc(__n * sizeof(_Tp)));
-      _M_size  = __n;
-#   if !defined(__STL_NO_BAD_ALLOC) && defined(__STL_USE_EXCEPTIONS)
-      if (_M_first == 0) {
-        _M_size = 0;
-        throw std::bad_alloc();
-      }
-#   endif
-    }
-    else {
-      _M_first = 0;
-      _M_size = 0;
-    }
-  }
-
-  void _M_deallocate() {
-    free(_M_first);
-    _M_first = 0;
-    _M_size = 0;
-  }
-};
-
-template <class _Tp> 
-class valarray : private _Valarray_base<_Tp>
-{
-  friend class gslice;
-
-public:
-  typedef _Tp value_type;
-
-  // Basic constructors
-  valarray() : _Valarray_base<_Tp>() {}
-  valarray(size_t __n) : _Valarray_base<_Tp>(__n)
-    { uninitialized_fill_n(this->_M_first, this->_M_size, value_type()); }
-  valarray(const value_type& __x, size_t __n) : _Valarray_base<_Tp>(__n)
-    { uninitialized_fill_n(this->_M_first, this->_M_size, __x); }
-  valarray(const value_type* __p, size_t __n) : _Valarray_base<_Tp>(__n)
-    { uninitialized_copy(__p, __p + __n, this->_M_first); } 
-  valarray(const valarray& __x) : _Valarray_base<_Tp>(__x._M_size) {
-    uninitialized_copy(__x._M_first, __x._M_first + __x._M_size,
-                       this->_M_first);
-  }
-
-  // Constructors from auxiliary array types
-  valarray(const slice_array<_Tp>&);
-  valarray(const gslice_array<_Tp>&);
-  valarray(const mask_array<_Tp>&);
-  valarray(const indirect_array<_Tp>&);
-
-  // Destructor
-  ~valarray() { destroy(this->_M_first, this->_M_first + this->_M_size); }
-
-  // Extension: constructor that doesn't initialize valarray elements to a
-  // specific value.  This is faster for types such as int and double.
-private:
-  void _M_initialize(__true_type) {}
-  void _M_initialize(__false_type)
-    { uninitialized_fill_n(this->_M_first, this->_M_size, value_type()); }
-
-public:
-  struct _NoInit {};
-  valarray(size_t __n, _NoInit) : _Valarray_base<_Tp>(__n) {
-    typedef typename __type_traits<_Tp>::has_trivial_default_constructor
-            _Is_Trivial;
-    _M_initialize(_Is_Trivial());
-  }
-
-public:                         // Assignment
-  // Basic assignment.  Note that 'x = y' is undefined if x.size() != y.size()
-  valarray& operator=(const valarray& __x) {
-    if (this != &__x)
-      copy(__x._M_first, __x._M_first + __x._M_size, this->_M_first);
-    return *this;
-  }
-
-  // Scalar assignment
-  valarray& operator=(const value_type& __x) {
-    fill_n(this->_M_first, this->_M_size, __x);
-    return *this;
-  }
-
-  // Assignment of auxiliary array types
-  valarray& operator=(const slice_array<_Tp>&);
-  valarray& operator=(const gslice_array<_Tp>&);
-  valarray& operator=(const mask_array<_Tp>&);
-  valarray& operator=(const indirect_array<_Tp>&);
-
-public:                         // Element access
-  value_type  operator[](size_t __n) const { return this->_M_first[__n]; }
-  value_type& operator[](size_t __n)       { return this->_M_first[__n]; }
-  size_t size() const { return this->_M_size; }
-
-public:                         // Subsetting operations with auxiliary type
-  valarray            operator[](slice) const;
-  slice_array<_Tp>    operator[](slice);
-  valarray            operator[](gslice) const;
-  gslice_array<_Tp>   operator[](gslice);  
-  valarray            operator[](const valarray<bool>&) const;
-  mask_array<_Tp>     operator[](const valarray<bool>&);
-  valarray            operator[](const valarray<size_t>&) const;
-  indirect_array<_Tp> operator[](const valarray<size_t>&);
-  
-public:                         // Unary operators.
-  valarray operator+() const { return *this; }
-
-  valarray operator-() const {
-    valarray __tmp(this->size(), _NoInit());
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      __tmp[__i] = -(*this)[__i];
-    return __tmp;
-  }
-  
-  valarray operator~() const {
-    valarray __tmp(this->size(), _NoInit());
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      __tmp[__i] = ~(*this)[__i];
-    return __tmp;
-  }
-
-  valarray<bool> operator!() const {
-    valarray<bool> __tmp(this->size(), valarray<bool>::_NoInit());
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      __tmp[__i] = !(*this)[__i];
-    return __tmp;
-  }
-
-public:                         // Scalar computed assignment.
-  valarray& operator*= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] *= __x;
-    return *this;
-  }
-    
-  valarray& operator/= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] /= __x;
-    return *this;
-  }
-
-  valarray& operator%= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] %= __x;
-    return *this;
-  }
-
-  valarray& operator+= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] += __x;
-    return *this;
-  }
-
-  valarray& operator-= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] -= __x;
-    return *this;
-  }
-
-  valarray& operator^= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] ^= __x;
-    return *this;
-  }
-
-  valarray& operator&= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] &= __x;
-    return *this;
-  }
-
-  valarray& operator|= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] |= __x;
-    return *this;
-  }
-
-  valarray& operator<<= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] <<= __x;
-    return *this;
-  }
-
-  valarray& operator>>= (const value_type& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] >>= __x;
-    return *this;
-  }
-
-public:                         // Array computed assignment.
-  valarray& operator*= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] *= __x[__i];
-    return *this;
-  }
-    
-  valarray& operator/= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] /= __x[__i];
-    return *this;
-  }
-
-  valarray& operator%= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] %= __x[__i];
-    return *this;
-  }
-
-  valarray& operator+= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] += __x[__i];
-    return *this;
-  }
-
-  valarray& operator-= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] -= __x[__i];
-    return *this;
-  }
-
-  valarray& operator^= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] ^= __x[__i];
-    return *this;
-  }
-
-  valarray& operator&= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] &= __x[__i];
-    return *this;
-  }
-
-  valarray& operator|= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] |= __x[__i];
-    return *this;
-  }
-
-  valarray& operator<<= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] <<= __x[__i];
-    return *this;
-  }
-
-  valarray& operator>>= (const valarray& __x) {
-    for (size_t __i = 0; __i < this->size(); ++__i)
-      (*this)[__i] >>= __x[__i];
-    return *this;
-  }
-
-public:                         // Other member functions.
-
-  // The result is undefined for zero-length arrays
-  value_type sum() const {
-    return accumulate(this->_M_first + 1, this->_M_first + this->_M_size,
-                      (*this)[0]);
-  }
-
-  // The result is undefined for zero-length arrays
-  value_type min() const {
-    return *min_element(this->_M_first + 0, this->_M_first + this->_M_size);
-  }
-
-  value_type max() const {
-    return *max_element(this->_M_first + 0, this->_M_first + this->_M_size);
-  }
-
-  valarray shift(int __n) const;
-  valarray cshift(int __n) const;
-
-  valarray apply(value_type __f(value_type)) const {
-    valarray __tmp(this->size());
-    transform(this->_M_first, this->_M_first + this->_M_size, __tmp._M_first,
-              __f);
-    return __tmp;
-  }
-  valarray apply(value_type __f(const value_type&)) const {
-    valarray __tmp(this->size());
-    transform(this->_M_first, this->_M_first + this->_M_size, __tmp._M_first,
-              __f);
-    return __tmp;
-  }
-  
-  void resize(size_t __n, value_type __x = value_type()) {
-    destroy(this->_M_first, this->_M_first + this->_M_size);
-    this->_Valarray_base<_Tp>::_M_deallocate();
-    this->_Valarray_base<_Tp>::_M_allocate(__n);
-    uninitialized_fill_n(this->_M_first, this->_M_size, __x);
-  }
-};
-
-//----------------------------------------------------------------------
-// valarray non-member functions.
-
-// Binary arithmetic operations between two arrays.  Behavior is
-// undefined if the two arrays do not have the same length.
-
-template <class _Tp> 
-inline valarray<_Tp> operator*(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] * __y[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator/(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] / __y[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator%(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] % __y[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator+(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] + __y[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator-(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] - __y[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator^(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] ^ __y[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator&(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] & __y[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator|(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] | __y[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator<<(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] << __y[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator>>(const valarray<_Tp>& __x,
-                               const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] >> __y[__i];
-  return __tmp;
-}
-
-// Binary arithmetic operations between an array and a scalar.
-
-template <class _Tp> 
-inline valarray<_Tp> operator*(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  * __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator*(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c * __x[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator/(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  / __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator/(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c / __x[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator%(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  % __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator%(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c % __x[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator+(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  + __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator+(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c + __x[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator-(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  - __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator-(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c - __x[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator^(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  ^ __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator^(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c ^ __x[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator&(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  & __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator&(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c & __x[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator|(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  | __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator|(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c | __x[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator<<(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  << __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator<<(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c << __x[__i];
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator>>(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  >> __c;
-  return __tmp;
-}
-
-template <class _Tp> 
-inline valarray<_Tp> operator>>(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c >> __x[__i];
-  return __tmp;
-}
-
-// Binary logical operations between two arrays.  Behavior is undefined
-// if the two arrays have different lengths.  Note that operator== does
-// not do what you might at first expect.
-
-template <class _Tp> 
-inline valarray<bool> operator==(const valarray<_Tp>& __x,
-                                 const valarray<_Tp>& __y)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] == __y[__i];
-  return __tmp;  
-}
-
-template <class _Tp> 
-inline valarray<bool> operator<(const valarray<_Tp>& __x,
-                                const valarray<_Tp>& __y)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] < __y[__i];
-  return __tmp;  
-}
-
-#ifdef __STL_FUNCTION_TMPL_PARTIAL_ORDER
-
-template <class _Tp> 
-inline valarray<bool> operator!=(const valarray<_Tp>& __x,
-                                 const valarray<_Tp>& __y)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] != __y[__i];
-  return __tmp;  
-}
-
-template <class _Tp> 
-inline valarray<bool> operator>(const valarray<_Tp>& __x,
-                                const valarray<_Tp>& __y)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] > __y[__i];
-  return __tmp;  
-}
-
-template <class _Tp> 
-inline valarray<bool> operator<=(const valarray<_Tp>& __x,
-                                 const valarray<_Tp>& __y)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] <= __y[__i];
-  return __tmp;  
-}
-
-template <class _Tp> 
-inline valarray<bool> operator>=(const valarray<_Tp>& __x,
-                                 const valarray<_Tp>& __y)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] >= __y[__i];
-  return __tmp;  
-}
-
-#endif /* __STL_FUNCTION_TMPL_PARTIAL_ORDER */
-
-template <class _Tp> 
-inline valarray<bool> operator&&(const valarray<_Tp>& __x,
-                                 const valarray<_Tp>& __y)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] && __y[__i];
-  return __tmp;  
-}
-
-template <class _Tp> 
-inline valarray<bool> operator||(const valarray<_Tp>& __x,
-                                 const valarray<_Tp>& __y)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] || __y[__i];
-  return __tmp;  
-}
-
-// Logical operations between an array and a scalar.
-
-template <class _Tp>
-inline valarray<bool> operator==(const valarray<_Tp>& __x, const _Tp& __c)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] == __c;
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator==(const _Tp& __c, const valarray<_Tp>& __x)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c == __x[__i];
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator!=(const valarray<_Tp>& __x, const _Tp& __c)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] != __c;
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator!=(const _Tp& __c, const valarray<_Tp>& __x)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c != __x[__i];
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator<(const valarray<_Tp>& __x, const _Tp& __c)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] < __c;
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator<(const _Tp& __c, const valarray<_Tp>& __x)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c < __x[__i];
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator>(const valarray<_Tp>& __x, const _Tp& __c)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] > __c;
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator>(const _Tp& __c, const valarray<_Tp>& __x)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c > __x[__i];
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator<=(const valarray<_Tp>& __x, const _Tp& __c)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i]  <= __c;
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator<=(const _Tp& __c, const valarray<_Tp>& __x)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c <= __x[__i];
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator>=(const valarray<_Tp>& __x, const _Tp& __c)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] >= __c;
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator>=(const _Tp& __c, const valarray<_Tp>& __x)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c >= __x[__i];
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator&&(const valarray<_Tp>& __x, const _Tp& __c)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] && __c;
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator&&(const _Tp& __c, const valarray<_Tp>& __x)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c && __x[__i];
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator||(const valarray<_Tp>& __x, const _Tp& __c)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __x[__i] || __c;
-  return __tmp;  
-}
-
-template <class _Tp>
-inline valarray<bool> operator||(const _Tp& __c, const valarray<_Tp>& __x)
-{
-  valarray<bool> __tmp(__x.size(), valarray<bool>::_NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = __c || __x[__i];
-  return __tmp;  
-}
-
-// valarray "transcendentals" (the list includes abs and sqrt, which,
-// of course, are not transcendental).
-
-template <class _Tp>
-inline valarray<_Tp> abs(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = abs(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> acos(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = acos(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> asin(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = asin(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> atan(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = atan(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> atan2(const valarray<_Tp>& __x,
-                           const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = atan2(__x[__i], __y[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> atan2(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = atan2(__x[__i], __c);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> atan2(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = atan2(__c, __x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> cos(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = cos(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> cosh(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = cosh(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> exp(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = exp(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> log(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = log(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> log10(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = log10(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> pow(const valarray<_Tp>& __x,
-                           const valarray<_Tp>& __y) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = pow(__x[__i], __y[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> pow(const valarray<_Tp>& __x, const _Tp& __c) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = pow(__x[__i], __c);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> pow(const _Tp& __c, const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = pow(__c, __x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> sin(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = sin(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> sinh(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = sinh(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> sqrt(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = sqrt(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> tan(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = tan(__x[__i]);
-  return __tmp;
-}
-
-template <class _Tp>
-inline valarray<_Tp> tanh(const valarray<_Tp>& __x) {
-  typedef typename valarray<_Tp>::_NoInit _NoInit;
-  valarray<_Tp> __tmp(__x.size(), _NoInit());
-  for (size_t __i = 0; __i < __x.size(); ++__i)
-    __tmp[__i] = tanh(__x[__i]);
-  return __tmp;
-}
-
-//----------------------------------------------------------------------
-// slice and slice_array
-
-class slice {
-public:
-  slice() : _M_start(0), _M_length(0), _M_stride(0) {}
-  slice(size_t __start, size_t __length, size_t __stride)
-    : _M_start(__start), _M_length(__length), _M_stride(__stride)
-    {}
-
-  size_t start()  const { return _M_start; }
-  size_t size()   const { return _M_length; }
-  size_t stride() const { return _M_stride; }
-
-   
-private:
-  size_t _M_start;
-  size_t _M_length;
-  size_t _M_stride;
-};
-
-template <class _Tp>
-class slice_array {
-  friend class valarray<_Tp>;
-public:
-  typedef _Tp value_type;
-
-  void operator=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] = __x[__i];
-  }
-
-  void operator*=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] *= __x[__i];
-  }
-
-  void operator/=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] /= __x[__i];
-  }
-
-  void operator%=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] %= __x[__i];
-  }
-
-  void operator+=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] += __x[__i];
-  }
-
-  void operator-=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] -= __x[__i];
-  }
-
-  void operator^=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] ^= __x[__i];
-  }
-
-  void operator&=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] &= __x[__i];
-  }
-
-  void operator|=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] |= __x[__i];
-  }
-
-  void operator<<=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] <<= __x[__i];
-  }
-
-  void operator>>=(const valarray<value_type>& __x) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] >>= __x[__i];
-  }
-
-  void operator=(const value_type& __c) const {
-    size_t __index = _M_slice.start();
-    for (size_t __i = 0;
-         __i < _M_slice.size();
-         ++__i, __index += _M_slice.stride())
-      _M_array[__index] = __c;
-  }
-
-  ~slice_array() {}
-
-private:
-  slice_array(const slice& __slice, valarray<_Tp>& __array)
-    : _M_slice(__slice), _M_array(__array)
-    {}
-
-  slice          _M_slice;
-  valarray<_Tp>& _M_array;
-
-private:                        // Disable assignment and default constructor
-  slice_array();
-};
-
-// valarray member functions dealing with slice and slice_array
-
-template <class _Tp>
-inline valarray<_Tp>::valarray(const slice_array<_Tp>& __x)
-  : _Valarray_base<_Tp>(__x._M_slice.size())
-{
-  typedef typename __type_traits<_Tp>::has_trivial_default_constructor
-          _Is_Trivial;
-  _M_initialize(_Is_Trivial());  
-  *this = __x;
-}
-
-// Behavior is undefined if __x and *this have different sizes
-template <class _Tp>
-valarray<_Tp>& valarray<_Tp>::operator=(const slice_array<_Tp>& __x)
-{
-  size_t __index = __x._M_slice.start();
-  for (size_t __i = 0;
-       __i < __x._M_slice.size();
-       ++__i, __index += __x._M_slice.stride())
-    (*this)[__i] = __x._M_array[__index];
-  return *this;
-}
-
-template <class _Tp>
-valarray<_Tp> valarray<_Tp>::operator[](slice __slice) const {
-  valarray<_Tp> __tmp(__slice.size(), _NoInit());
-  size_t __index = __slice.start();
-  for (size_t __i = 0;
-       __i < __slice.size();
-       ++__i, __index += __slice.stride())
-    __tmp[__i] = (*this)[__index];
-  return __tmp;
-}
-
-template <class _Tp>
-inline slice_array<_Tp> valarray<_Tp>::operator[](slice __slice) {
-  return slice_array<_Tp>(__slice, *this);
-}
-
-//----------------------------------------------------------------------
-// gslice and gslice_array
-
-struct _Gslice_Iter;
-
-class gslice {
-  friend struct _Gslice_Iter;
-public:
-  gslice() : _M_start(0), _M_lengths(0), _M_strides(0) {}
-  gslice(size_t __start,
-         const valarray<size_t>& __lengths, const valarray<size_t>& __strides)
-    : _M_start(__start), _M_lengths(__lengths), _M_strides(__strides)
-    {}
-
-  size_t start()            const { return _M_start; }
-  valarray<size_t> size()   const { return _M_lengths; }
-  valarray<size_t> stride() const { return _M_strides; }
-
-  // Extension: check for an empty gslice.
-  bool _M_empty() const { return _M_lengths.size() == 0; }
-
-  // Extension: number of indices this gslice represents.  (For a degenerate
-  // gslice, they're not necessarily all distinct.)
-  size_t _M_size() const {
-    return !this->_M_empty()
-      ? accumulate(_M_lengths._M_first + 1,
-                   _M_lengths._M_first + _M_lengths._M_size,
-                   _M_lengths[0],
-                   multiplies<size_t>())
-      : 0;
-  }
-
-private:
-  size_t _M_start;
-  valarray<size_t> _M_lengths;
-  valarray<size_t> _M_strides;
-};
-
-// This is not an STL iterator.  It is constructed from a gslice, and it
-// steps through the gslice indices in sequence.  See 23.3.6 of the C++
-// standard, paragraphs 2-3, for an explanation of the sequence.  At
-// each step we get two things: the ordinal (i.e. number of steps taken),
-// and the one-dimensional index.
-
-struct _Gslice_Iter {
-  _Gslice_Iter(const gslice& __gslice)
-    : _M_step(0), _M_1d_idx(__gslice.start()),
-      _M_indices(size_t(0), __gslice._M_lengths.size()),
-      _M_gslice(__gslice)
-    {}
-    
-  bool _M_done() const { return _M_indices[0] == _M_gslice._M_lengths[0]; }
-
-  bool _M_incr() {
-    size_t __dim = _M_indices.size() - 1;
-    ++_M_step;
-    while (true) {
-      _M_1d_idx += _M_gslice._M_strides[__dim];
-      if (++_M_indices[__dim] != _M_gslice._M_lengths[__dim])
-        return true;
-      else if (__dim != 0) {
-        _M_1d_idx -=
-          _M_gslice._M_strides[__dim] * _M_gslice._M_lengths[__dim];
-        _M_indices[__dim] = 0;
-        --__dim;
-      }
-      else
-        return false;
-    }
-  }
-
-  size_t _M_step;
-  size_t _M_1d_idx;
-
-  valarray<size_t> _M_indices;
-  const gslice& _M_gslice;
-};
-
-template <class _Tp>
-class gslice_array {
-  friend class valarray<_Tp>;
-public:
-  typedef _Tp value_type;
-
-  void operator= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] = __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator*= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] *= __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator/= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] /= __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator%= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] %= __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator+= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] += __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator-= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] -= __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator^= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] ^= __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator&= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] &= __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator|= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] |= __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator<<= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] <<= __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator>>= (const valarray<value_type>& __x) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] >>= __x[__i._M_step]; while(__i._M_incr());
-    }
-  }
-
-  void operator= (const value_type& __c) const {
-    if (!_M_gslice._M_empty()) {
-      _Gslice_Iter __i(_M_gslice);
-      do _M_array[__i._M_1d_idx] = __c; while(__i._M_incr());
-    }
-  }
-
-  ~gslice_array() {}
-
-private:                        
-  gslice_array(gslice __gslice, valarray<_Tp>& __array)
-    : _M_gslice(__gslice), _M_array(__array)
-    {}
-
-  gslice                _M_gslice;
-  valarray<value_type>& _M_array;
-
-private:                        // Disable assignment
-  void operator=(const gslice_array&);
-};
-
-// valarray member functions dealing with gslice and gslice_array.  Note
-// that it is illegal (behavior is undefined) to construct a gslice_array
-// from a degenerate gslice.
-
-template <class _Tp>
-inline valarray<_Tp>::valarray(const gslice_array<_Tp>& __x)
-  : _Valarray_base<_Tp>(__x._M_gslice._M_size())
-{
-  typedef typename __type_traits<_Tp>::has_trivial_default_constructor
-          _Is_Trivial;
-  _M_initialize(_Is_Trivial());  
-  *this = __x;
-}
-
-// Behavior is undefined if __x and *this have different sizes, or if
-// __x was constructed from a degenerate gslice.
-template <class _Tp>
-valarray<_Tp>& valarray<_Tp>::operator=(const gslice_array<_Tp>& __x)
-{
-  if (this->size() != 0) {
-    _Gslice_Iter __i(__x._M_gslice);
-    do
-      (*this)[__i._M_step] = __x._M_array[__i._M_1d_idx];
-    while(__i._M_incr());
-  }
-  return *this;
-}
-
-template <class _Tp>
-inline gslice_array<_Tp> valarray<_Tp>::operator[](gslice __slice) {
-  return gslice_array<_Tp>(__slice, *this);
-}
-
-template <class _Tp>
-valarray<_Tp> valarray<_Tp>::operator[](gslice __slice) const
-{
-  valarray __tmp(__slice._M_size(), _NoInit());
-  if (__tmp.size() != 0) {
-    _Gslice_Iter __i(__slice);
-    do __tmp[__i._M_step] = (*this)[__i._M_1d_idx]; while(__i._M_incr());
-  }
-  return __tmp;
-}
-
-//----------------------------------------------------------------------
-// mask_array
-
-template <class _Tp>
-class mask_array {
-  friend class valarray<_Tp>;
-public:
-  typedef _Tp value_type;
-
-  void operator=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] = __x[__idx++];
-  }
-
-  void operator*=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] *= __x[__idx++];
-  }
-
-  void operator/=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] /= __x[__idx++];
-  }
-
-  void operator%=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] %= __x[__idx++];
-  }
-
-  void operator+=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] += __x[__idx++];
-  }
-
-  void operator-=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] -= __x[__idx++];
-  }
-  
-  void operator^=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] ^= __x[__idx++];
-  }
-
-  void operator&=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] &= __x[__idx++];
-  }
-
-  void operator|=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] |= __x[__idx++];
-  }
-
-  void operator<<=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] <<= __x[__idx++];
-  }
-
-  void operator>>=(const valarray<value_type>& __x) const {
-    size_t __idx = 0;
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] >>= __x[__idx++];
-  }
-
-  void operator=(const value_type& __c) const {
-    for (size_t __i = 0; __i < _M_array.size(); ++__i)
-      if (_M_mask[__i]) _M_array[__i] = __c;
-  }
-
-  ~mask_array() {}
-
-  // Extension: number of true values in the mask
-  size_t _M_num_true() const {
-    size_t __result = 0;
-    for (size_t __i = 0; __i < _M_mask.size(); ++__i)
-      if (_M_mask[__i]) ++__result;
-    return __result;
-  }
-
-private:
-  mask_array(const valarray<bool>& __mask, valarray<_Tp>& __array)
-    : _M_mask(__mask), _M_array(__array)
-    {}
-
-  valarray<bool> _M_mask;
-  valarray<_Tp>& _M_array;
-
-private:                        // Disable assignment
-  void operator=(const mask_array&);
-};
-
-// valarray member functions dealing with mask_array
-
-template <class _Tp>
-inline valarray<_Tp>::valarray(const mask_array<_Tp>& __x)
-  : _Valarray_base<_Tp>(__x._M_num_true())
-{
-  typedef typename __type_traits<_Tp>::has_trivial_default_constructor
-          _Is_Trivial;
-  _M_initialize(_Is_Trivial());  
-  *this = __x;
-}
-
-// Behavior is undefined if __x._M_num_true() != this->size()
-template <class _Tp>
-inline valarray<_Tp>& valarray<_Tp>::operator=(const mask_array<_Tp>& __x) {
-  size_t __idx = 0;
-  for (size_t __i = 0; __i < __x._M_array.size(); ++__i)
-    if (__x._M_mask[__i]) (*this)[__idx++] = __x._M_array[__i];
-  return *this;
-}
-
-template <class _Tp>
-inline mask_array<_Tp> valarray<_Tp>::operator[](const valarray<bool>& __mask)
-{
-  return mask_array<_Tp>(__mask, *this);
-}
-
-template <class _Tp>
-valarray<_Tp> valarray<_Tp>::operator[](const valarray<bool>& __mask) const
-{
-  size_t __size = 0;
-  {
-    for (size_t __i = 0; __i < __mask.size(); ++__i)
-      if (__mask[__i]) ++__size;
-  }
-
-  valarray __tmp(__size, _NoInit());
-  size_t __idx = 0;
-  {
-    for (size_t __i = 0; __i < __mask.size(); ++__i)
-      if (__mask[__i]) __tmp[__idx++] = (*this)[__i];
-  }
-
-  return __tmp;
-}
-
-//----------------------------------------------------------------------
-// indirect_array
-
-template <class _Tp>
-class indirect_array {
-  friend class valarray<_Tp>;
-public:
-  typedef _Tp value_type;
-
-  void operator=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] = __x[__i];
-  }
-
-  void operator*=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] *= __x[__i];
-  }
-
-  void operator/=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] /= __x[__i];
-  }
-
-  void operator%=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] %= __x[__i];
-  }
-
-  void operator+=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] += __x[__i];
-  }
-
-  void operator-=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] -= __x[__i];
-  }
-
-  void operator^=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] ^= __x[__i];
-  }
-
-  void operator&=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] &= __x[__i];
-  }
-
-  void operator|=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] |= __x[__i];
-  }
-
-  void operator<<=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] <<= __x[__i];
-  }
-
-  void operator>>=(const valarray<value_type>& __x) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] >>= __x[__i];
-  }
-
-  void operator=(const value_type& __c) const {
-    for (size_t __i = 0; __i < _M_addr.size(); ++__i)
-      _M_array[_M_addr[__i]] = __c;
-  }
-
-  ~indirect_array() {}
-
-private:
-  indirect_array(const valarray<size_t>& __addr, valarray<_Tp>& __array)
-    : _M_addr(__addr), _M_array(__array)
-    {}
-
-  valarray<size_t> _M_addr;
-  valarray<_Tp>&   _M_array;
-
-private:                        // Disable assignment
-  void operator=(const indirect_array&);
-};
-
-// valarray member functions dealing with indirect_array
-
-template <class _Tp>
-inline valarray<_Tp>::valarray(const indirect_array<_Tp>& __x)
-  : _Valarray_base<_Tp>(__x._M_addr.size())
-{
-  typedef typename __type_traits<_Tp>::has_trivial_default_constructor
-          _Is_Trivial;
-  _M_initialize(_Is_Trivial());  
-  *this = __x;
-}
-
-template <class _Tp>
-valarray<_Tp>& valarray<_Tp>::operator=(const indirect_array<_Tp>& __x) {
-  for (size_t __i = 0; __i < __x._M_addr.size(); ++__i)
-    (*this)[__i] = __x._M_array[__x._M_addr[__i]];
-  return *this;
-}
-
-template <class _Tp>
-inline indirect_array<_Tp>
-valarray<_Tp>::operator[](const valarray<size_t>& __addr)
-{
-  return indirect_array<_Tp>(__addr, *this);
-}
-
-template <class _Tp>
-valarray<_Tp>
-valarray<_Tp>::operator[](const valarray<size_t>& __addr) const
-{
-  valarray<_Tp> __tmp(__addr.size(), _NoInit());
-  for (size_t __i = 0; __i < __addr.size(); ++__i)
-    __tmp[__i] = (*this)[__addr[__i]];
-  return __tmp;
-}
-
-//----------------------------------------------------------------------
-// Other valarray noninline member functions
-
-// Shift and cshift
-
-template <class _Tp>
-valarray<_Tp> valarray<_Tp>::shift(int __n) const
-{
-  valarray<_Tp> __tmp(this->size());
-
-  if (__n >= 0) {
-    if (__n < this->size())
-      copy(this->_M_first + __n, this->_M_first + this->size(),
-           __tmp._M_first);
-  }
-  else {
-    if (-__n < this->size())
-      copy(this->_M_first, this->_M_first + this->size() + __n,
-           __tmp._M_first - __n);
-  }
-  return __tmp;
-}
-
-template <class _Tp>
-valarray<_Tp> valarray<_Tp>::cshift(int __m) const
-{
-  valarray<_Tp> __tmp(this->size());
-
-  // Reduce __m to an equivalent number in the range [0, size()).  We
-  // have to be careful with negative numbers, since the sign of a % b
-  // is unspecified when a < 0.
-  long __n = __m;
-  if (this->size() < numeric_limits<long>::max())
-    __n %= long(this->size());
-  if (__n < 0)
-    __n += this->size();
-
-  copy(this->_M_first,       this->_M_first + __n,
-       __tmp._M_first + (this->size() - __n));
-  copy(this->_M_first + __n, this->_M_first + this->size(),
-       __tmp._M_first);
-
-  return __tmp;
-}
-
-__STL_END_NAMESPACE
-
-#endif /* __SGI_STL_VALARRAY */
-
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stl/vector b/lib/include/stl/vector
deleted file mode 100644
index 272f60f..0000000
--- a/lib/include/stl/vector
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- *
- * Copyright (c) 1994
- * Hewlett-Packard Company
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Hewlett-Packard Company makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- *
- * Copyright (c) 1996
- * Silicon Graphics Computer Systems, Inc.
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Silicon Graphics makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- */
-
-#ifndef __SGI_STL_VECTOR
-#define __SGI_STL_VECTOR
-
-#include <stl_range_errors.h>
-#include <stl_algobase.h>
-#include <stl_alloc.h>
-#include <stl_construct.h>
-#include <stl_uninitialized.h>
-#include <stl_vector.h>
-#include <stl_bvector.h>
-
-#endif /* __SGI_STL_VECTOR */
-
-// Local Variables:
-// mode:C++
-// End:
diff --git a/lib/include/stream/BufferedInputOutputStream.h b/lib/include/stream/BufferedInputOutputStream.h
index faeb113..4d0f50a 100644
--- a/lib/include/stream/BufferedInputOutputStream.h
+++ b/lib/include/stream/BufferedInputOutputStream.h
@@ -71,5 +71,18 @@ namespace stm32plus {
           free(_buffer);
       }
 
+			virtual size_t write(const void* buffer,size_t size) override;
+
   };
+
+		/**
+     * Seven Robotics Extension. Dummy Implementation.
+     */
+
+			inline size_t BufferedInputOutputStream::write(const void* buffer,size_t size) {
+			
+				(void)buffer;	
+				(void)size;
+				return 0;
+			} 	
 }
diff --git a/lib/include/stream/ByteArrayOutputStream.h b/lib/include/stream/ByteArrayOutputStream.h
index c268421..9ad4b92 100644
--- a/lib/include/stream/ByteArrayOutputStream.h
+++ b/lib/include/stream/ByteArrayOutputStream.h
@@ -38,7 +38,15 @@ namespace stm32plus {
 
       virtual bool write(uint8_t c) override;
       virtual bool write(const void *buffer,uint32_t size) override;
+			virtual size_t write (const void* buffer,size_t size) override;
       virtual bool close() override;
       virtual bool flush() override;
   };
+
+	inline size_t ByteArrayOutputStream::write(const void* buffer,size_t size) {
+	
+		(void)buffer;
+		(void)size;
+		return 0;
+	}
 }
diff --git a/lib/include/stream/OutputStream.h b/lib/include/stream/OutputStream.h
index d0417a0..19d1cc9 100644
--- a/lib/include/stream/OutputStream.h
+++ b/lib/include/stream/OutputStream.h
@@ -50,7 +50,19 @@ namespace stm32plus {
        */
 
       virtual bool write(const void *buffer,uint32_t size)=0;
+		
+		 /**
+ 			*	Extended by Seven Robotics. Providing a pure virtual
+ 			*	write method which returns the number of bytes written 
+ 			*	to the stream. Required by the Memory stream class.
+ 			*	Which copies the data pointed to by buffer into its
+ 			*	local buffer.
+ 			*	TODO: Provide a timeout mechanism. For non-blocking IO.
+ 			*/
+      virtual size_t write(const void *buffer,size_t size)=0;                                                                                              
+			/* Seven Robotics Extension*/
 
+//			virtual size_t read(void* buffer,size_t size)=0;
       /**
        * Flush any cached data to the stream. If the stream does not support
        * caching then it returns true.
diff --git a/lib/include/stream/TextOutputStream.h b/lib/include/stream/TextOutputStream.h
index a71a2cd..bd7ab54 100644
--- a/lib/include/stream/TextOutputStream.h
+++ b/lib/include/stream/TextOutputStream.h
@@ -41,6 +41,7 @@ namespace stm32plus {
 
       virtual bool write(uint8_t c) override;
       virtual bool write(const void *buffer,uint32_t size) override;
+			virtual size_t write(const void* buffer,size_t size) override;
       virtual bool close() override;
       virtual bool flush() override;
   };
@@ -185,6 +186,17 @@ namespace stm32plus {
     return _stream.write(buffer,size);
   }
 
+	/**
+ 	 * Seven Robotics Extension. Dummy implementation.
+ 	 * Always Returns zero.
+ 	 */
+	inline size_t  TextOutputStream::write(const void* buffer,size_t size)
+	{
+		(void)buffer;
+		(void)size;
+		return 0;
+	}
+ 	 
 
   /**
    * Close the stream (do nothing)
diff --git a/lib/include/usart/UsartPollingOutputStream.h b/lib/include/usart/UsartPollingOutputStream.h
index 66ef950..f99aca8 100644
--- a/lib/include/usart/UsartPollingOutputStream.h
+++ b/lib/include/usart/UsartPollingOutputStream.h
@@ -27,7 +27,8 @@ namespace stm32plus {
 
       virtual bool write(uint8_t c) override;
       virtual bool write(const void *buffer,uint32_t size) override;
-
+			virtual size_t write(const void* buffer,size_t size) override;
+//			virtual size_t read(const void* buffer,size_t size) override;
       /**
        * Always true.
        * @return always true
diff --git a/lib/include/usart/features/f4/UsartInterruptFeature.h b/lib/include/usart/features/f4/UsartInterruptFeature.h
index c5a4fa8..785a3d4 100644
--- a/lib/include/usart/features/f4/UsartInterruptFeature.h
+++ b/lib/include/usart/features/f4/UsartInterruptFeature.h
@@ -40,7 +40,7 @@ namespace stm32plus {
       static FPTR _forceLinkage;
 
     public:
-      static void enable();
+      static void enable(uint8_t priority, uint8_t subpriority);
   };
 
 
@@ -55,6 +55,8 @@ namespace stm32plus {
 
     protected:
       uint16_t _interruptMask;
+			uint8_t _nvicPriority;
+			uint8_t _nvicSubPriority;
 
     public:
 
@@ -68,7 +70,10 @@ namespace stm32plus {
     public:
       UsartInterruptFeature(Usart& usart);
       ~UsartInterruptFeature();
-
+			
+			/* Seven Robotics edit. setNvicProperties not provided
+ 			*	for USART*/
+			void setNvicPriorities(uint8_t priority,uint8_t subpriority);
       void enableInterrupts(uint16_t interruptMask);
       void disableInterrupts(uint16_t interruptMask);
       void clearPendingInterruptsFlag(uint16_t interruptMask) const;
@@ -119,6 +124,14 @@ namespace stm32plus {
       disableInterrupts(_interruptMask);
   }
 
+	
+	template<uint8_t TUsartNumber>
+	inline void UsartInterruptFeature<TUsartNumber>::setNvicPriorities(uint8_t priority,uint8_t subpriority) {
+	
+	_nvicPriority=priority;
+	_nvicSubPriority=subpriority;
+	}
+
 
   /**
    * Enable the interrupts specified in the mask
@@ -129,7 +142,7 @@ namespace stm32plus {
   inline void UsartInterruptFeature<TUsartNumber>::enableInterrupts(uint16_t interruptMask) {
 
     _interruptMask|=interruptMask;
-    UsartInterruptFeatureEnabler<TUsartNumber>::enable();
+    UsartInterruptFeatureEnabler<TUsartNumber>::enable(_nvicPriority,_nvicSubPriority);
     USART_ITConfig(_usart,interruptMask,ENABLE);
   }
 
@@ -160,9 +173,9 @@ namespace stm32plus {
    */
 
   template<>
-  inline void UsartInterruptFeatureEnabler<1>::enable() {
+  inline void UsartInterruptFeatureEnabler<1>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&USART1_IRQHandler;
-    Nvic::configureIrq(USART1_IRQn);
+    Nvic::configureIrq(USART1_IRQn,ENABLE,priority,subpriority);
   }
 
   /**
@@ -170,9 +183,9 @@ namespace stm32plus {
    */
 
   template<>
-  inline void UsartInterruptFeatureEnabler<2>::enable() {
+  inline void UsartInterruptFeatureEnabler<2>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&USART2_IRQHandler;
-    Nvic::configureIrq(USART2_IRQn);
+    Nvic::configureIrq(USART2_IRQn,ENABLE,priority,subpriority);
   }
 
   /**
@@ -180,9 +193,9 @@ namespace stm32plus {
    */
 
   template<>
-  inline void UsartInterruptFeatureEnabler<3>::enable() {
+  inline void UsartInterruptFeatureEnabler<3>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&USART3_IRQHandler;
-    Nvic::configureIrq(USART3_IRQn);
+    Nvic::configureIrq(USART3_IRQn,ENABLE,priority,subpriority);
   }
 
   /**
@@ -190,9 +203,9 @@ namespace stm32plus {
    */
 
   template<>
-  inline void UsartInterruptFeatureEnabler<4>::enable() {
+  inline void UsartInterruptFeatureEnabler<4>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&UART4_IRQHandler;
-    Nvic::configureIrq(UART4_IRQn);
+    Nvic::configureIrq(UART4_IRQn,ENABLE,priority,subpriority);
   }
 
   /**
@@ -200,9 +213,9 @@ namespace stm32plus {
    */
 
   template<>
-  inline void UsartInterruptFeatureEnabler<5>::enable() {
+  inline void UsartInterruptFeatureEnabler<5>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&UART5_IRQHandler;
-    Nvic::configureIrq(UART5_IRQn);
+    Nvic::configureIrq(UART5_IRQn,ENABLE,priority,subpriority);
   }
 
 
@@ -211,8 +224,8 @@ namespace stm32plus {
    */
 
   template<>
-  inline void UsartInterruptFeatureEnabler<6>::enable() {
+  inline void UsartInterruptFeatureEnabler<6>::enable(uint8_t priority,uint8_t subpriority) {
     _forceLinkage=&USART6_IRQHandler;
-    Nvic::configureIrq(USART6_IRQn);
+    Nvic::configureIrq(USART6_IRQn,ENABLE,priority,subpriority);
   }
 }
diff --git a/lib/src/device/BlockDeviceOutputStream.cpp b/lib/src/device/BlockDeviceOutputStream.cpp
index 1fa6d98..79e8e53 100644
--- a/lib/src/device/BlockDeviceOutputStream.cpp
+++ b/lib/src/device/BlockDeviceOutputStream.cpp
@@ -45,7 +45,7 @@ namespace stm32plus {
    */
 
   bool BlockDeviceOutputStream::write(uint8_t c) {
-    return write(&c,1);
+    return write(&c,static_cast<uint32_t>(1));
   }
 
 
diff --git a/lib/src/dma/f4/interrupts/Dma1Stream1InterruptHandler.cpp b/lib/src/dma/f4/interrupts/Dma1Stream1InterruptHandler.cpp
index d421381..7efc70d 100644
--- a/lib/src/dma/f4/interrupts/Dma1Stream1InterruptHandler.cpp
+++ b/lib/src/dma/f4/interrupts/Dma1Stream1InterruptHandler.cpp
@@ -27,7 +27,7 @@ extern "C" {
    */
 
   #if defined(USE_DMA1_1_INTERRUPT)
-    void __attribute__ ((interrupt("IRQ"))) DMA1_Stream1_IRQHandler() {
+    void DMA1_Stream1_IRQHandler() {
 
       if(DMA_GetITStatus(DMA1_Stream1,DMA_IT_TCIF1)!=RESET) {
         DmaInterruptFeature<1,1>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
diff --git a/lib/src/net/network/ip/features/IpPacketReassemblerFeature.cpp b/lib/src/net/network/ip/features/IpPacketReassemblerFeature.cpp
index be15d6d..b9dccd2 100644
--- a/lib/src/net/network/ip/features/IpPacketReassemblerFeature.cpp
+++ b/lib/src/net/network/ip/features/IpPacketReassemblerFeature.cpp
@@ -185,15 +185,15 @@ namespace stm32plus {
 
       // check each entry and delete if expired
 
-      for(auto it=_frags.begin();it!=_frags.end();) {
+      for(auto it=_frags.before_begin();it!=_frags.end();) {
 
-        if(nitd.timeNow>(*it)->expiryTime) {
+        if(nitd.timeNow>(*next(it))->expiryTime) {
 
-          _totalFragmentSize-=(*it)->packetLength;
+          _totalFragmentSize-=(*next(it))->packetLength;
           _inFlightPacketCount--;
 
-          delete *it;
-          it=_frags.erase(it);
+          delete *next(it);
+          it=_frags.erase_after(it);
         }
         else
           it++;
@@ -215,9 +215,9 @@ namespace stm32plus {
 
       // find and free the packet
 
-      for(auto it=_frags.begin();it!=_frags.end();it++) {
+      for(auto it=_frags.before_begin();it!=_frags.end();it++) {
         if(*it==packetToFree) {
-          _frags.erase(it);
+          _frags.erase_after(it);
           break;
         }
       }
@@ -259,8 +259,17 @@ namespace stm32plus {
     bool IpPacketReassemblerFeature::createNewFragment(IpFragmentedPacket::PacketId pid,IpFragmentedPacket *&fp) {
 
       // check for the maximum fragmented packets
-
-      if(_frags.size()==_params.ip_maxInProgressFragmentedPackets)
+			/**
+ 			 * Seven Robotics Extension. Since slist has been replaced with forward_list for future
+ 			 * compatibility with libstdc++. An in place method is being implemented below to get number
+ 			 * of packets. Because this will not be a very large number (default=2). Traversing the list 
+ 			 * linearly will not add alot of overhead.
+ 			 * Note: std::distance returns difference_type of the iterator type.
+ 			 * Which for _Fwd_list_iterator is ptrdiff_t.
+ 			 */ 
+			auto len = std::distance(_frags.begin(),_frags.end());
+
+      if(len ==_params.ip_maxInProgressFragmentedPackets)
         return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_IP_PACKET_REASSEMBLER,E_TOO_MANY_FRAGMENTED_PACKETS);
 
       // create the new entry (expiry time is not set here)
diff --git a/lib/src/stream/ByteArrayOutputStream.cpp b/lib/src/stream/ByteArrayOutputStream.cpp
index 0e43a66..407d6f0 100644
--- a/lib/src/stream/ByteArrayOutputStream.cpp
+++ b/lib/src/stream/ByteArrayOutputStream.cpp
@@ -61,7 +61,7 @@ namespace stm32plus {
    */
 
   bool ByteArrayOutputStream::write(uint8_t c) {
-    return write(&c,1);
+    return write(&c,static_cast<uint32_t>(1));
   }
 
 
diff --git a/lib/src/usart/UsartPollingOutputStream.cpp b/lib/src/usart/UsartPollingOutputStream.cpp
index 0958019..9ab7204 100644
--- a/lib/src/usart/UsartPollingOutputStream.cpp
+++ b/lib/src/usart/UsartPollingOutputStream.cpp
@@ -43,4 +43,20 @@ namespace stm32plus {
 
     return true;
   }
+
+	size_t UsartPollingOutputStream::write(const void* buffer,size_t size){
+
+		const uint8_t* ptr;
+		size_t n=0;
+		ptr= static_cast<const uint8_t*>(buffer);
+
+		while(size--)
+		{
+			_usart.send(*ptr++);
+			n++;
+		}
+		
+		return n;
+	}
+
 }
diff --git a/lib/src/usart/interrupts/Usart3InterruptHandler.cpp b/lib/src/usart/interrupts/Usart3InterruptHandler.cpp
index c12eabd..655536b 100644
--- a/lib/src/usart/interrupts/Usart3InterruptHandler.cpp
+++ b/lib/src/usart/interrupts/Usart3InterruptHandler.cpp
@@ -24,7 +24,7 @@ extern "C" {
 
   #if defined(USE_USART3_INTERRUPT)
 
-    void __attribute__ ((interrupt("IRQ"))) USART3_IRQHandler(void) {
+    void  USART3_IRQHandler(void) {
       if(USART_GetITStatus(USART3,USART_IT_RXNE)!=RESET) {
         UsartInterruptFeature<3>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_RECEIVE);
         USART_ClearITPendingBit(USART3,USART_IT_RXNE);
-- 
2.7.4

